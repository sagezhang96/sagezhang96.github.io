<!DOCTYPE html>
<html>
<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
    <title>Sage自留地😎</title>
    
<link rel="stylesheet" href="/css/style.css">

    <link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=JetBrains+Mono:wght@400;500;600&display=swap">
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.16.8/dist/katex.min.css">
<meta name="generator" content="Hexo 7.3.0"><link rel="alternate" href="/atom.xml" title="Sage自留地😎" type="application/atom+xml">
</head>
<body>
    <div class="container">
        <header class="header">
    <div class="site-title">
        <a href="/">Sage自留地😎</a>
    </div>
    <div class="nav-toggle">
        <span></span>
        <span></span>
        <span></span>
    </div>
    <nav class="nav">
        <ul class="nav-list">
            
                
                    <li class="nav-item">
                        <a href="/">首页</a>
                    </li>
                
            
                
                    <li class="nav-item has-children">
                        <a href="javascript:void(0);">文章</a>
                        <ul class="nav-submenu">
                            
                                <li class="nav-submenu-item">
                                    <a href="/archives">归档</a>
                                </li>
                            
                                <li class="nav-submenu-item">
                                    <a href="/categories">分类</a>
                                </li>
                            
                                <li class="nav-submenu-item">
                                    <a href="/tags">标签</a>
                                </li>
                            
                        </ul>
                    </li>
                
            
                
                    <li class="nav-item">
                        <a href="/about">关于</a>
                    </li>
                
            
        </ul>
    </nav>
</header>

        <div class="main-container">
            <main class="main-content">
                <article class="post-detail">
    <header class="post-header">
        <h1 class="post-title">给产品经理讲技术笔记</h1>
        <div class="post-meta">
            <span class="post-date">
                2024-03-07
            </span>
            
                <span class="post-category">
                    <a class="category-link" href="/categories/%E4%BA%A7%E5%93%81/">产品</a>
                </span>
            
            
                <span class="post-tags">
                    <a class="tag-none-link" href="/tags/%E4%BA%A7%E5%93%81%E7%BB%8F%E9%AA%8C/" rel="tag">产品经验</a>
                </span>
            
        </div>
    </header>

    <div class="post-content">
        <h1 id="Web前端技术"><a href="#Web前端技术" class="headerlink" title="Web前端技术"></a>Web前端技术</h1><h2 id="AJAX"><a href="#AJAX" class="headerlink" title="AJAX"></a>AJAX</h2><p>这种只让部分页面刷新的技术叫作AJAX（汉语读音为“阿贾克斯”或“额寨克思”），它是“Asynchronous JavaScript And XML”的首字母缩写，翻译为“异步JavaScript和XML”。</p>
<p>AJAX可以发起网络请求，无需刷新即可动态操作网页。</p>
<p>总结：AJAX是一项用于异步拉取数据并展示在当前页面的技术，这对需要延迟加载数据和触发式加载数据的页面有很大益处。绝大多数网页为了加速响应，都会用到这项技术。</p>
<h2 id="DOM"><a href="#DOM" class="headerlink" title="DOM"></a>DOM</h2><p>HTML文档中的层次分明的结构组织，就是DOM，是网页的框架。</p>
<p>操纵DOM本身是一件效率非常低的事情。一个网页往往很复杂，浏览器构造出来的DOM树往往很庞大。</p>
<p>虚拟DOM可以从整体上大大提高了JavaScript操纵DOM树的效率。</p>
<h2 id="静态网页与动态网页"><a href="#静态网页与动态网页" class="headerlink" title="静态网页与动态网页"></a>静态网页与动态网页</h2><p>静态网页无须经过后台程序的处理。动态网页要经过后台程序的处理，我们常见的ASP、JSP、PHP都是后台处理程序。</p>
<p>总结：<br>（1）静态网页和动态网页都是网页。<br>（2）静态网页不需要后台程序干预处理，直接由服务器返回。实现为静态网页后，一般不需要维护，因为数据不需要更新。<br>（3）动态网页一般需要由程序来处理（ASP、JSP、PHP、Python、Ruby等），并由数据库提供数据支撑。<br>（4）不要以URL的形式来判断一个网页是静态的还是动态的，而应该看页面的属性（产品经理最好具备一些调试技巧和经验）。<br>（5）动态网页更灵活。</p>
<h2 id="URL结构"><a href="#URL结构" class="headerlink" title="URL结构"></a>URL结构</h2><p>一个标准的 URL 地址由protocol、hostname、port、path、parameters、query 几部分组成。</p>
<p>再长的URL也是由这几个关键部分组成的，只要读者能分割出上面介绍的几个主要部件，就能看出各部分的意义。</p>
<h2 id="表单"><a href="#表单" class="headerlink" title="表单"></a>表单</h2><p>表单在很早的 HTML 版本中就已经存在，它是用户输入和网页之间数据交互的一个界面，在HTML中用<code>&lt;form&gt;</code>标签标记。</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">&quot;en&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">form</span> <span class="attr">name</span>=<span class="string">&quot;input&quot;</span></span></span><br><span class="line"><span class="tag"><span class="attr">action</span>=<span class="string">&quot;http://www.***.com/index.html&quot;</span><span class="attr">method</span>=<span class="string">&quot;GET&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span> <span class="attr">name</span>=<span class="string">&quot;user&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;submit&quot;</span> <span class="attr">value</span>=<span class="string">&quot;Submit&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">form</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>效果如下：</p>
<html lang="en">
<form name="input"
action="http://www.***.com/index.html"method="GET">
<input type="text" name="user"/>
<input type="submit" value="Submit"/>
</form>
</html>

<p>总结：表单是用户和服务器数据交互的用户界面，一切向服务器提交的数据都是由其中的几个简单的标签组成的。</p>
<h2 id="H5缓存技术"><a href="#H5缓存技术" class="headerlink" title="H5缓存技术"></a>H5缓存技术</h2><p>Application Cache技术通过缓存资源到本地，避免了每次打开网页都会从服务器拉取大量数据的过程，取而代之的只是一个轻量级的更新检查请求，这样，开发者的服务器带宽就被大大地释放出来</p>
<h2 id="在Chrome中使用F12开启开发者模式"><a href="#在Chrome中使用F12开启开发者模式" class="headerlink" title="在Chrome中使用F12开启开发者模式"></a>在Chrome中使用F12开启开发者模式</h2><p>DevTools： 如果读者在浏览某些网站时按“F12”键启动开发者工具，会在Console这个Tab下收到网站开发者的留言，不过这些留言大多是一些招聘信息，因为这样做针对性很强，这些信息几乎只有开发工程师才能看到。</p>
<p>恐龙小游戏： 当没有网络时，浏览器也就没有什么作用了，用户会很无聊，于是Chrome 免费送了一款小游戏，给用户消磨时间。触发方法：先断开网络，然后在Chrome里随便打开一个网址，读者会看到如图1-3所示的小恐龙，再按“空格”键，游戏就开始了。如果是在手机版浏览器上，就直接单击小恐龙开始游戏。</p>
<p>变色的标题栏： 在Android版的Chrome浏览器里访问某些网站时，读者会发现标题栏和状态栏的颜色变成了该网站的主题色。这其实是Chrome的一个特性，只要开发者在网页的header里设置了themecolor的属性，Android版的Chrome就会选择当前网页的theme-color表示的颜色作为标题栏和状态栏的背景色。</p>
<p>指定搜索引擎： 如果读者想在淘宝搜索某件商品，或者想在知乎搜索某个问题，可以在Chrome的地址栏里直接输入淘宝或者知乎的域名，然后按“Tab”键，Chrome的地址栏就显示“用××搜索”，我们紧接着输入想搜索的内容，按回车键，结果就直接显示出来了，如图1-4所示。</p>
<p>计算器： 临时要做一些简单的计算，又不想打开计算机里的计算器程序，则可以直接在 Chrome 的地址栏里进行计算。例如，在地址栏输入“1+1&#x3D;×”，地址栏下方就会显示计算结果。</p>
<p>执行 JavaScript 语句： 同样在地址栏里，使用“javascript:××”就能执行相应的JavaScript语句，读者可以尝试在地址栏里输入如下代码：javascript:alert（”hello guoguo”）;注意要手动输入，若采用复制&#x2F;粘贴的方式，Chrome会默认清理“javascript:”这个前缀，输入后就会看到一个显示“hello guoguo”的对话框。</p>
<p>将网页存为PDF文件： 有时我们需要将一个页面保存下来，除了用Evernote等工具，还可以在Chrome里直接将该网页存成PDF，只需按“Ctrl+P”组合键唤起“打印网页”对话框，然后在目标打印机的选项中选择“另存为PDF”选项。</p>
<h2 id="UA-UserAgent"><a href="#UA-UserAgent" class="headerlink" title="UA:UserAgent"></a>UA:UserAgent</h2><p>“UA”是“UserAgent”（用户代理）的简写，一般用来区分不同的浏览器。</p>
<p>Chrome的UA</p>
<p>Mozilla&#x2F;5.0（Windows; U; Windows NT 5.1; en-US）AppleWebKit&#x2F;525.13（KHTML,like Gecko）Chrome&#x2F;0.2.149.29Safari&#x2F;525.13</p>
<h2 id="URL编码"><a href="#URL编码" class="headerlink" title="URL编码"></a>URL编码</h2><p>中文会被编码，如“%e5%82%bb%e5%91%80”，这就是URL中的中文被编码后的结果。</p>
<h2 id="简单理解HTML、CSS和JavaScript"><a href="#简单理解HTML、CSS和JavaScript" class="headerlink" title="简单理解HTML、CSS和JavaScript"></a>简单理解HTML、CSS和JavaScript</h2><p>HTML、CSS、JavaScript共同构建了读者看到的所有网页展示和交互。</p>
<p>HTML（HyperText Markup Language）是超文本标记语言 。</p>
<p>CSS（Cascading Style Sheets）是级联样式表 ，外观。</p>
<p>JavaScript 是一种脚本语言 ，主要用于前端页面的DOM处理。</p>
<p>当前互联网上的任何一个网页都是由它们三个构建起来的，虽然简<br>单，但不可不知。</p>
<h2 id="跨域与同源"><a href="#跨域与同源" class="headerlink" title="跨域与同源"></a>跨域与同源</h2><p>同源就是同域，“跨域”也可以说成“跨源”。不同源，就不能修改另一个页面，更不能获取与另一个页面相关的内容。只有同源的页面才可以相互访问。</p>
<p>浏览器提供了原生的同源机制来保证不同域下的网站互相隔离，正是这种机制的存在，保证了Web生态下各个网站不乱套。</p>
<p>什么是同源呢？只要两个页面的协议、主机名、端口一样，就是同源的，否则就是非同源的。同源要同时满足3个特征，例如<a target="_blank" rel="noopener" href="http://www.a.com/index.html">http://www.a.com/index.html</a> 和 <a target="_blank" rel="noopener" href="http://www.b.com/index.html">http://www.b.com/index.html</a> 不同源，因为主机名不同，一个为a.com，另一个为b.com。<a target="_blank" rel="noopener" href="http://www.a.com/index.html">http://www.a.com/index.html</a> 和 <a target="_blank" rel="noopener" href="https://www.a.com/index.html">https://www.a.com/index.html</a> 不同源，因为协议不同，一个为HTTP，另一个为HTTPS。<a target="_blank" rel="noopener" href="https://www.a.com:80/index.html">https://www.a.com:80/index.html</a>  和 <a target="_blank" rel="noopener" href="https://www.a.com:81/index.html">https://www.a.com:81/index.html</a> 不同源，因为端口号不同，一个为80，另一个为81。</p>
<p>合理的跨域沟通的方法有以下几种：<br>（1）JSONP<br>（2）iframe document.domain<br>（3）iframe location.hash<br>（4）HTML 5 PostMessage</p>
<h2 id="Cookie和广告联盟"><a href="#Cookie和广告联盟" class="headerlink" title="Cookie和广告联盟"></a>Cookie和广告联盟</h2><p>Cookie 是浏览器每次向网站服务器请求数据时携带的一些额外信息，这些信息一般非常少（最多4KB），主要就是为了解决服务器“记性不好”的问题。</p>
<h2 id="HTTP-Header是什么"><a href="#HTTP-Header是什么" class="headerlink" title="HTTP Header是什么"></a>HTTP Header是什么</h2><p>HTTP 协议的 Header 是一块数据区域，分为请求头和响应头两种类型，客户端向服务区发送请求时带的是请求头，而服务器响应客户端数据时带的是响应头。请求头里主要是客户端的一些基础信息，UA（user-agent）就是其中的一部分，而响应头里是响应数据的一些信息，以及服务器要求客户端如何处理这些响应数据的指令。请求头里面的关键信息如下：<br>（1）accept，表示当前浏览器可以接受的文件类型，假设这里有image&#x2F;webp，表示当前浏览器可以支持webp格式的图片，那么当服务器给当前浏览器下发webp的图片时，可以更省流量。<br>（2）accept-encoding，表示当前浏览器可以接受的数据编码，如果服务器吐出的数据不是浏览器可接受的编码，就会产生乱码。<br>（3）accept-language，表示当前使用的浏览语言。<br>（4）Cookie，很多和用户相关的信息都存在 Cookie 里，用户在向服务器发送请求数据时会带上。例如，用户在一个网站上登录了一次之后，下次访问时就不用再登录了，就是因为登录成功的 token 放在了Cookie 中，而且随着每次请求发送给服务器，服务器就知道当前用户已登录。<br>（5）user-agent，表示浏览器的版本信息。当服务器收到浏览器的这个请求后，会经过一系列处理，返回一个数据包给浏览器，而响应头里就会描述这个数据包的基本信息。</p>
<p>响应头里的关键信息有：<br>（1）content-encoding，表示返回内容的压缩编码类型，如“Content-Encoding:gzip”表示这次回包是以gzip格式压缩编码的，这种压缩格式可以减少流量的消耗。<br>（2）content-length，表示这次回包的数据大小，如果数据大小不匹配，要当作异常处理。<br>（3）content-type，表示数据的格式，它是一个 HTML页面，同时页面的编码格式是 UTF-8，按照这些信息，可以正常地解析出内容。content-type 为不同的值时，浏览器会做不同的操作，如果content-type是application&#x2F;octet-stream，表示数据是一个二进制流，此时浏览器会走下载文件的逻辑，而不是打开一个页面。<br>（4）set-cookie，服务器通知浏览器设置一个Cookie；通过HTTP的Header，可以识别出用户的一些详细信息，方便做更定制化的需求，如果读者想探索自己发出的请求中头里面有些什么，可以这样做：打开Chrome浏览器并按“F12”键，唤起Chrome开发者工具，选择network这个Tab，浏览器发出的每个请求的详情都会在这里显示。</p>
<h2 id="HTTP中的GET和POST"><a href="#HTTP中的GET和POST" class="headerlink" title="HTTP中的GET和POST"></a>HTTP中的GET和POST</h2><p>通常认为GET 就是拉取服务器的数据，POST 就是向服务器提交数据，但实际上两者并没有这种明确的界限</p>
<h2 id="WebSocket"><a href="#WebSocket" class="headerlink" title="WebSocket"></a>WebSocket</h2><p>将更新逻辑从HTTP迁移到WebSocket是很简单的，只需要实现WebSocket的几个接口，就能在支持的浏览器上使用WebSocket的双工特性。如果读者想做一个实时性很强的网页，或者想向网页及时推送一些信息，尽量选择WebSocket。</p>
<h2 id="直出"><a href="#直出" class="headerlink" title="直出"></a>直出</h2><p>总结一下：浏览器直接输出渲染好数据的HTML页面，简称“直出”。直出没什么神秘的，只不过需要Node.js的支持，服务器和前端都用JavaScript语言编写，相当于在服务器上也运行一个浏览器，它把渲染好的内容直接输出给客户端的浏览器。</p>
<h2 id="WEB应用"><a href="#WEB应用" class="headerlink" title="WEB应用"></a>WEB应用</h2><p>要理解单页Web应用，需要和非单页Web应用，也就是多页Web应用做对比。</p>
<p>这种包含多个页面，通过链接切换的网站，就是多页Web应用。</p>
<p>单页的 Web 应用会在用户单击链接之后直接和服务器联系（不会告诉浏览器页面切换了），拉取数据。虽然看起来与多页Web应用没什么区别，但技术上的区别很大</p>
<p>单页Web应用，更像是一个原生的Android或者iOS应用，只不过现在浏览器成了一个操作系统。</p>
<p>单页 Web 应用如何能在一个页面里把多个页面才能做的事情做完呢？这就需要以下两个必备技术：</p>
<p>（1）AJAX。作者之前介绍过，有了它，前端的 JavaScript 代码就可以拉取服务器上的数据了。<br>（2）页面历史栈。前面介绍过，单页 Web 应用只有一个页面，也就是只有一个URL，那么用户想前进或者后退该怎么办呢？这就依赖单页Web页面自己的处理了。</p>
<h2 id="锚点与网页内跳转"><a href="#锚点与网页内跳转" class="headerlink" title="锚点与网页内跳转"></a>锚点与网页内跳转</h2><p>锚点定义位置，用#号完成对锚点位置的跳转，无论是在输入的URL中还是网页中，各种位置跳转的需求都可以这样简单完成。这个锚点的跳转仅仅是浏览器的操作行为，并不会发起任何网络请求和服务器交互。</p>
<h2 id="适配手机屏幕"><a href="#适配手机屏幕" class="headerlink" title="适配手机屏幕"></a>适配手机屏幕</h2><p>总结一下，viewport是一块区域，手机上的浏览器为了适配桌面上的网页，把它设置成宽980像素，但是这样的网页要正确地显示出来必须经过缩放或者用滚动条，所以开发者在写前端网页的时候，会用一个width&#x3D;device-width的viewport，这样CSS里看到的屏幕总宽度在320像素左右，1像素代表的物理像素数会自动根据屏幕密度进行换算。这样就完成了设计师的目标：标注80像素的按钮，在不同的手机上，看起来一样大。</p>

    </div>

    <footer class="post-footer">
        <div class="post-nav">
            
                <div class="post-nav-prev">
                    <span>上一篇</span>
                    <a href="/article/47367.html">《积极心理课》彭凯平</a>
                </div>
            
            
                <div class="post-nav-next">
                    <span>下一篇</span>
                    <a href="/article/46973.html">如何执行PDCA循环</a>
                </div>
            
        </div>
    </footer>

    
        <div class="post-comments">
            <h3 class="comments-title">评论</h3>
            <div id="waline"></div>
        </div>
    
</article>


    <script type="module">
        import { init } from 'https://unpkg.com/@waline/client@v3/dist/waline.js';

        init({
            el: '#waline',
            serverURL: 'https://walinecomments.five2fire.top',
            dark: '',
            lang: 'zh-CN',
            pageview: true,
            comment: true,
            emoji: ["https://cdn.jsdelivr.net/gh/walinejs/emojis@1.0.0/bilibili","https://cdn.jsdelivr.net/gh/walinejs/emojis/weibo"]
        });
    </script>
    <link rel="stylesheet" href="https://unpkg.com/@waline/client@v3/dist/waline.css" />



            </main>
        </div>
        
    </div>
    
<script src="/js/main.js"></script>

    <script defer src="https://cdn.jsdelivr.net/npm/katex@0.16.8/dist/katex.min.js"></script>
    <script defer src="https://cdn.jsdelivr.net/npm/katex@0.16.8/dist/contrib/auto-render.min.js" onload="renderMathInElement(document.body);"></script>
</body>
</html>

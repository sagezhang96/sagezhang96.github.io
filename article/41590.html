<!DOCTYPE html>
<html>
<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
    <title>Sage自留地😎</title>
    
<link rel="stylesheet" href="/css/style.css">

    <link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=JetBrains+Mono:wght@400;500;600&display=swap">
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.16.8/dist/katex.min.css">
<meta name="generator" content="Hexo 7.3.0"><link rel="alternate" href="/atom.xml" title="Sage自留地😎" type="application/atom+xml">
</head>
<body>
    <div class="container">
        <header class="header">
    <div class="site-title">
        <a href="/">Sage自留地😎</a>
    </div>
    <div class="nav-toggle">
        <span></span>
        <span></span>
        <span></span>
    </div>
    <nav class="nav">
        <ul class="nav-list">
            
                
                    <li class="nav-item">
                        <a href="/">首页</a>
                    </li>
                
            
                
                    <li class="nav-item has-children">
                        <a href="javascript:void(0);">文章</a>
                        <ul class="nav-submenu">
                            
                                <li class="nav-submenu-item">
                                    <a href="/archives">归档</a>
                                </li>
                            
                                <li class="nav-submenu-item">
                                    <a href="/categories">分类</a>
                                </li>
                            
                                <li class="nav-submenu-item">
                                    <a href="/tags">标签</a>
                                </li>
                            
                        </ul>
                    </li>
                
            
                
                    <li class="nav-item">
                        <a href="/about">关于</a>
                    </li>
                
            
        </ul>
    </nav>
</header>

        <div class="main-container">
            <main class="main-content">
                <article class="post-detail">
    <header class="post-header">
        <h1 class="post-title">【Hacking With Swift】Project3_ViewsAndModels</h1>
        <div class="post-meta">
            <span class="post-date">
                2024-06-03
            </span>
            
                <span class="post-category">
                    <a class="category-link" href="/categories/%E6%8A%80%E6%9C%AF/">技术</a>
                </span>
            
            
                <span class="post-tags">
                    <a class="tag-none-link" href="/tags/Hacking-with-Swift/" rel="tag">Hacking with Swift</a> <a class="tag-none-link" href="/tags/Swift/" rel="tag">Swift</a> <a class="tag-none-link" href="/tags/%E7%BC%96%E7%A8%8B/" rel="tag">编程</a>
                </span>
            
        </div>
    </header>

    <div class="post-content">
        <p><em><strong><font color=red>英文原博博主是</font></strong></em>   <a target="_blank" rel="noopener" href="https://www.youtube.com/c/PaulHudson">Paul Hudson</a>    <i aria-hidden="true" class="fab fa-twitter" style="color: #4099ff"></i> <a href="https://twitter.com/twostraws" target="_blank">@twostraws</a></p>
<p><em><strong><font color=red>本文是学习Swift过程中翻译该网站的内容:</font></strong></em>   <a target="_blank" rel="noopener" href="https://www.hackingwithswift.com/">https://www.hackingwithswift.com/</a></p>
<h2 id="1-视图和修饰符的简介"><a href="#1-视图和修饰符的简介" class="headerlink" title="1.视图和修饰符的简介"></a>1.视图和修饰符的简介</h2><p>在这个项目中，我们将弄明白为什么Swift中使用结构体而不是用类来编程，以及为什么<code>some View</code>有那么多。</p>
<p>在项目结尾希望你能够彻底了解Swift是通过什么运转起来的。</p>
<h2 id="2-为什么-SwiftUI-对视图使用结构体？"><a href="#2-为什么-SwiftUI-对视图使用结构体？" class="headerlink" title="2.为什么 SwiftUI 对视图使用结构体？"></a>2.为什么 SwiftUI 对视图使用结构体？</h2><p>一个是为了性能考虑，结构体的创建很简单，可以包含一个整数，也可以包含一个复杂结构。</p>
<p>另外，除了性能方面，还有一个很重要的原因，就是隔离。我们可以更改类中的值，这会导致混乱，但想要更改结构体中的值，需要使用特定的方法。</p>
<h2 id="3-SwiftUI-主视图的背后是什么？"><a href="#3-SwiftUI-主视图的背后是什么？" class="headerlink" title="3.SwiftUI 主视图的背后是什么？"></a>3.SwiftUI 主视图的背后是什么？</h2><p>在刚创建一个新项目的时候，会有以下默认代码，如果希望修改背景颜色，仅仅做出以下改变是不够的：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">ContentView</span>: <span class="title class_">View</span> &#123;</span><br><span class="line">    <span class="keyword">var</span> body: <span class="keyword">some</span> <span class="type">View</span> &#123;</span><br><span class="line">        <span class="type">Text</span>(<span class="string">&quot;Hello, world!&quot;</span>)</span><br><span class="line">            .padding()</span><br><span class="line">            .background(.red)</span><br><span class="line">    &#125;</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>

<p>因为这里的<code>.background(.red)</code>只作用于Text这么大小的视图，并不能应用于整个背景，事实上，整个视图除了这个Text视图外，并没有一个叫“背景”的视图，如果你想要填充背景，正确的解决方案就是让文本视图占用更多空间，可以使用<code>frame()</code>修饰符来做到这一点。</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Text</span>(<span class="string">&quot;Hello, world!&quot;</span>)</span><br><span class="line">    .frame(maxWidth: .infinity, maxHeight: .infinity)</span><br><span class="line">    .background(.red)</span><br></pre></td></tr></table></figure>
<h2 id="4-修饰顺序也很重要"><a href="#4-修饰顺序也很重要" class="headerlink" title="4.修饰顺序也很重要"></a>4.修饰顺序也很重要</h2><p>每个修饰符都创建一个应用了该修饰符的新结构，而不是仅仅在视图上设置一个属性。</p>
<p>使用修饰符的一个重要副作用是我们可以多次应用相同的效果：每个都只是添加到之前的任何内容上。 </p>
<p>例如，SwiftUI 为我们提供了padding()修饰符，它在视图周围增加了一点空间，这样它就不会向上推到其他视图或屏幕边缘。如果我们应用 padding 然后是背景颜色，然后是更多的 padding 和不同的背景颜色，我们可以给视图多个边框，像这样： </p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Text</span>(<span class="string">&quot;Hello, world!&quot;</span>)</span><br><span class="line">    .padding()</span><br><span class="line">    .background(.red)</span><br><span class="line">    .padding()</span><br><span class="line">    .background(.blue)</span><br><span class="line">    .padding()</span><br><span class="line">    .background(.green)</span><br><span class="line">    .padding()</span><br><span class="line">    .background(.yellow)</span><br></pre></td></tr></table></figure>

<h2 id="5-为什么-SwiftUI-使用“some-View”作为它的视图类型？"><a href="#5-为什么-SwiftUI-使用“some-View”作为它的视图类型？" class="headerlink" title="5.为什么 SwiftUI 使用“some View”作为它的视图类型？"></a>5.为什么 SwiftUI 使用“some View”作为它的视图类型？</h2><p>表示这个结构中包含不同种视图类型，如果只包含一种，比如Text类型，也可以使用Text作为视图类型，例如</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">ContentView</span>: <span class="title class_">View</span> &#123;</span><br><span class="line">    <span class="keyword">var</span> body: <span class="type">Text</span> &#123;</span><br><span class="line">        <span class="type">Text</span>(<span class="string">&quot;Hello World&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>
<p>这个也是完全合法的</p>
<h2 id="6-条件修饰符"><a href="#6-条件修饰符" class="headerlink" title="6.条件修饰符"></a>6.条件修饰符</h2><p>使用三元运算符替代if语句，if语句在一些情况下效率比较低，使用三元运算符会大大简化代码。例如：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">ContentView</span>: <span class="title class_">View</span> &#123;</span><br><span class="line">    <span class="meta">@State</span> <span class="keyword">private</span> <span class="keyword">var</span> useRedText <span class="operator">=</span> <span class="literal">false</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> body: <span class="keyword">some</span> <span class="type">View</span> &#123;</span><br><span class="line">        <span class="type">Button</span>(<span class="string">&quot;Hello World&quot;</span>) &#123;</span><br><span class="line">            <span class="comment">// flip the Boolean between true and false</span></span><br><span class="line">            useRedText.toggle()</span><br><span class="line">        &#125;</span><br><span class="line">        .foregroundColor(useRedText <span class="operator">?</span> .red : .blue)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>因此，当<code>useRedText</code>为 <code>true </code>时，修饰符有效地读取<code>.foregroundColor(.red)</code>，而当它为<code>false</code>时，修饰符变为<code>.foregroundColor(.blue)</code>。因为 SwiftUI 会监视我们<code>@State属性</code>的变化并重新调用我们的body属性，所以只要该属性发生变化，颜色就会立即更新。  </p>
<h2 id="7-环境修饰符"><a href="#7-环境修饰符" class="headerlink" title="7.环境修饰符"></a>7.环境修饰符</h2><p>许多修饰符可以应用于容器，这允许我们同时将相同的修饰符应用于多个视图。</p>
<p>例如，如果我们在一个 VStack中有四个文本视图，并希望为它们提供相同的字体修饰符，我们可以直接将修饰符应用于VStack并将该更改应用于所有四个文本视图：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">VStack</span> &#123;</span><br><span class="line">    <span class="type">Text</span>(<span class="string">&quot;Gryffindor&quot;</span>)</span><br><span class="line">    <span class="type">Text</span>(<span class="string">&quot;Hufflepuff&quot;</span>)</span><br><span class="line">    <span class="type">Text</span>(<span class="string">&quot;Ravenclaw&quot;</span>)</span><br><span class="line">    <span class="type">Text</span>(<span class="string">&quot;Slytherin&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line">.font(.title)</span><br></pre></td></tr></table></figure>

<p>这称为环境修改器，不同于应用于视图的常规修改器。</p>
<p>从编码的角度来看，这些修饰符的使用方式与常规修饰符完全相同。但是，它们的行为略有不同，因为如果这些子视图中的任何一个覆盖了相同的修饰符，则子视图的版本优先。</p>
<p>例如，这显示了我们的四个带有标题字体的文本视图，但其中一个标题较大：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">VStack</span> &#123;</span><br><span class="line">    <span class="type">Text</span>(<span class="string">&quot;Gryffindor&quot;</span>)</span><br><span class="line">        .font(.largeTitle)</span><br><span class="line">    <span class="type">Text</span>(<span class="string">&quot;Hufflepuff&quot;</span>)</span><br><span class="line">    <span class="type">Text</span>(<span class="string">&quot;Ravenclaw&quot;</span>)</span><br><span class="line">    <span class="type">Text</span>(<span class="string">&quot;Slytherin&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line">.font(.title)</span><br></pre></td></tr></table></figure>

<p>那里有font()一个环境修饰符，这意味着 Gryffindor 文本视图可以用自定义字体覆盖它。</p>
<p>但是，这对VStack然后尝试在其中一个文本视图上禁用模糊应用了模糊效果：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">VStack</span> &#123;</span><br><span class="line">    <span class="type">Text</span>(<span class="string">&quot;Gryffindor&quot;</span>)</span><br><span class="line">        .blur(radius: <span class="number">0</span>)</span><br><span class="line">    <span class="type">Text</span>(<span class="string">&quot;Hufflepuff&quot;</span>)</span><br><span class="line">    <span class="type">Text</span>(<span class="string">&quot;Ravenclaw&quot;</span>)</span><br><span class="line">    <span class="type">Text</span>(<span class="string">&quot;Slytherin&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line">.blur(radius: <span class="number">5</span>)</span><br></pre></td></tr></table></figure>

<p>这不会以相同的方式工作：blur()是常规修改器，因此应用于子视图的任何模糊都将添加到VStack模糊而不是替换它。</p>
<p>但我们没有办法提前知道哪些修改器是环境修改器，哪些是常规修改器，除非阅读每个修改器的单独文档并希望它被提及。尽管如此，有总比没有好。</p>
<h2 id="8-视图作为属性"><a href="#8-视图作为属性" class="headerlink" title="8.视图作为属性"></a>8.视图作为属性</h2><p>有很多方法可以让 SwiftUI 中的复杂视图层次结构更容易使用，其中一种选择是使用属性——创建一个视图作为你自己视图的属性，然后在你的布局中使用该属性。</p>
<p>例如，我们可以像这样创建两个文本视图作为属性，然后在一个VStack中使用它们：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">ContentView</span>: <span class="title class_">View</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> motto1 <span class="operator">=</span> <span class="type">Text</span>(<span class="string">&quot;Draco dormiens&quot;</span>)</span><br><span class="line">    <span class="keyword">let</span> motto2 <span class="operator">=</span> <span class="type">Text</span>(<span class="string">&quot;nunquam titillandus&quot;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> body: <span class="keyword">some</span> <span class="type">View</span> &#123;</span><br><span class="line">        <span class="type">VStack</span> &#123;</span><br><span class="line">            motto1</span><br><span class="line">            motto2</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>你甚至可以在使用这些属性时直接将修饰符应用于它们，如下所示：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">VStack</span> &#123;</span><br><span class="line">    motto1</span><br><span class="line">        .foregroundColor(.red)</span><br><span class="line">    motto2</span><br><span class="line">        .foregroundColor(.blue)</span><br><span class="line">&#125;  </span><br></pre></td></tr></table></figure>
<p>将视图创建为属性有助于使你的body代码更清晰——它不仅有助于避免重复，而且还可以从body属性中获取更复杂的代码。  </p>
<h2 id="9-查看组成"><a href="#9-查看组成" class="headerlink" title="9.查看组成"></a>9.查看组成</h2><p>SwiftUI 让我们可以将复杂的视图分解成更小的视图，而不会对性能产生太大影响。这意味着我们可以将一个大视图拆分为多个较小的视图，而 SwiftUI 会负责为我们重新组装它们。</p>
<p>例如，在这个视图中，我们有一种特殊的方式来设置文本视图的样式——它们有一个大字体、一些填充、前景色和背景色，以及一个胶囊形状：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">ContentView</span>: <span class="title class_">View</span> &#123;</span><br><span class="line">    <span class="keyword">var</span> body: <span class="keyword">some</span> <span class="type">View</span> &#123;</span><br><span class="line">        <span class="type">VStack</span>(spacing: <span class="number">10</span>) &#123;</span><br><span class="line">            <span class="type">Text</span>(<span class="string">&quot;First&quot;</span>)</span><br><span class="line">                .font(.largeTitle)</span><br><span class="line">                .padding()</span><br><span class="line">                .foregroundColor(.white)</span><br><span class="line">                .background(.blue)</span><br><span class="line">                .clipShape(<span class="type">Capsule</span>())</span><br><span class="line"></span><br><span class="line">            <span class="type">Text</span>(<span class="string">&quot;Second&quot;</span>)</span><br><span class="line">                .font(.largeTitle)</span><br><span class="line">                .padding()</span><br><span class="line">                .foregroundColor(.white)</span><br><span class="line">                .background(.blue)</span><br><span class="line">                .clipShape(<span class="type">Capsule</span>())</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>因为这两个文本视图除了文本之外是相同的，所以我们可以将它们包装在一个新的自定义视图中，如下所示：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">CapsuleText</span>: <span class="title class_">View</span> &#123;</span><br><span class="line">    <span class="keyword">var</span> text: <span class="type">String</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> body: <span class="keyword">some</span> <span class="type">View</span> &#123;</span><br><span class="line">        <span class="type">Text</span>(text)</span><br><span class="line">            .font(.largeTitle)</span><br><span class="line">            .padding()</span><br><span class="line">            .foregroundColor(.white)</span><br><span class="line">            .background(.blue)</span><br><span class="line">            .clipShape(<span class="type">Capsule</span>())</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>然后我们可以在原始视图中使用该CapsuleText视图，如下所示：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">ContentView</span>: <span class="title class_">View</span> &#123;</span><br><span class="line">    <span class="keyword">var</span> body: <span class="keyword">some</span> <span class="type">View</span> &#123;</span><br><span class="line">        <span class="type">VStack</span>(spacing: <span class="number">10</span>) &#123;</span><br><span class="line">            <span class="type">CapsuleText</span>(text: <span class="string">&quot;First&quot;</span>)</span><br><span class="line">            <span class="type">CapsuleText</span>(text: <span class="string">&quot;Second&quot;</span>)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>当然，我们也可以在视图中存储一些修饰符，在使用时自定义其他的。例如，如果我们从CapsuleText中删除foregroundColor()，那么我们可以在创建该视图的实例时应用自定义颜色，如下所示：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">VStack</span>(spacing: <span class="number">10</span>) &#123;</span><br><span class="line">    <span class="type">CapsuleText</span>(text: <span class="string">&quot;First&quot;</span>)</span><br><span class="line">        .foregroundColor(.white)</span><br><span class="line">    <span class="type">CapsuleText</span>(text: <span class="string">&quot;Second&quot;</span>)</span><br><span class="line">        .foregroundColor(.yellow)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>不要担心这里的性能问题——以这种方式分解 SwiftUI 视图非常有效。  </p>
<h2 id="10-自定义修饰符"><a href="#10-自定义修饰符" class="headerlink" title="10.自定义修饰符"></a>10.自定义修饰符</h2><p>要创建自定义修饰符，请创建一个符合ViewModifier协议的新结构。这只有一个要求，即一种被调用的方法body，它接受要处理的任何内容，并且必须返回some View。 </p>
<p>例如：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Title</span>: <span class="title class_">ViewModifier</span> &#123;</span><br><span class="line">    <span class="keyword">func</span> <span class="title function_">body</span>(<span class="params">content</span>: <span class="type">Content</span>) -&gt; <span class="keyword">some</span> <span class="type">View</span> &#123;</span><br><span class="line">        content</span><br><span class="line">            .font(.largeTitle)</span><br><span class="line">            .foregroundColor(.white)</span><br><span class="line">            .padding()</span><br><span class="line">            .background(.blue)</span><br><span class="line">            .clipShape(<span class="type">RoundedRectangle</span>(cornerRadius: <span class="number">10</span>))</span><br><span class="line">    &#125;</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>

<p>我们现在可以将它与modifier()修饰符一起使用——是的，它是一个名为“modifier”的修饰符，但它允许我们将任何类型的修饰符应用于视图，如下所示：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Text</span>(<span class="string">&quot;Hello World&quot;</span>)</span><br><span class="line">    .modifier(<span class="type">Title</span>()) </span><br></pre></td></tr></table></figure>

<p>创建自定义View之后，创建扩展以View使其更易于使用 例如，我们可以将Title修饰符包装在这样的扩展中：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">extension</span> <span class="title class_">View</span> &#123;</span><br><span class="line">    <span class="keyword">func</span> <span class="title function_">titleStyle</span>() -&gt; <span class="keyword">some</span> <span class="type">View</span> &#123;</span><br><span class="line">        modifier(<span class="type">Title</span>())</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们现在可以像这样使用修饰符：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Text</span>(<span class="string">&quot;Hello World&quot;</span>)</span><br><span class="line">    .titleStyle() </span><br></pre></td></tr></table></figure>

<p>自定义修饰符可以做的不仅仅是应用其他现有修饰符——它们还可以根据需要创建新的视图结构。请记住，修饰符返回新对象而不是修改现有对象，因此我们可以创建一个将视图嵌入堆栈并添加另一个视图的对象：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Watermark</span>: <span class="title class_">ViewModifier</span> &#123;</span><br><span class="line">    <span class="keyword">var</span> text: <span class="type">String</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">func</span> <span class="title function_">body</span>(<span class="params">content</span>: <span class="type">Content</span>) -&gt; <span class="keyword">some</span> <span class="type">View</span> &#123;</span><br><span class="line">        <span class="type">ZStack</span>(alignment: .bottomTrailing) &#123;</span><br><span class="line">            content</span><br><span class="line">            <span class="type">Text</span>(text)</span><br><span class="line">                .font(.caption)</span><br><span class="line">                .foregroundColor(.white)</span><br><span class="line">                .padding(<span class="number">5</span>)</span><br><span class="line">                .background(.black)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">extension</span> <span class="title class_">View</span> &#123;</span><br><span class="line">    <span class="keyword">func</span> <span class="title function_">watermarked</span>(<span class="params">with</span> <span class="params">text</span>: <span class="type">String</span>) -&gt; <span class="keyword">some</span> <span class="type">View</span> &#123;</span><br><span class="line">        modifier(<span class="type">Watermark</span>(text: text))</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>有了它，我们现在可以像这样向任何视图添加水印：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Color</span>.blue</span><br><span class="line">    .frame(width: <span class="number">300</span>, height: <span class="number">200</span>)</span><br><span class="line">    .watermarked(with: <span class="string">&quot;Hacking with Swift&quot;</span>)</span><br></pre></td></tr></table></figure>

<p>提示：通常人们想知道什么时候添加自定义视图修饰符比只添加一个新方法给View更好，实际上这归结为一个主要原因：自定义视图修饰符可以有自己的存储属性，而扩展View则不能。 </p>
<h2 id="11-定制容器"><a href="#11-定制容器" class="headerlink" title="11.定制容器"></a>11.定制容器</h2><p>利用泛型创建一些自定义容器，并在容器中加入任何自定义内容。</p>
<p>在 Swift 中，我们会这样写：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">GridStack</span>&lt;<span class="title class_">Content</span>: <span class="title class_">View</span>&gt;: <span class="title class_">View</span> &#123; <span class="comment">//这一部分是Swift的一个高级特性，称为泛型。</span></span><br><span class="line">    <span class="keyword">let</span> rows: <span class="type">Int</span></span><br><span class="line">    <span class="keyword">let</span> columns: <span class="type">Int</span></span><br><span class="line">    <span class="keyword">let</span> content: (<span class="type">Int</span>, <span class="type">Int</span>) -&gt; <span class="type">Content</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> body: <span class="keyword">some</span> <span class="type">View</span> &#123;</span><br><span class="line">        <span class="comment">// more to come</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>
<p>特别注意这一let content行——它定义了一个必须能够接受两个整数并返回某种我们可以显示的内容的闭包。拥有这一行所以才叫做定制容器。</p>
<p>在body中我们可以这么写</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> body: <span class="keyword">some</span> <span class="type">View</span> &#123;</span><br><span class="line">    <span class="type">VStack</span> &#123;</span><br><span class="line">        <span class="type">ForEach</span>(<span class="number">0</span><span class="operator">..&lt;</span>rows, id: \.<span class="keyword">self</span>) &#123; row <span class="keyword">in</span></span><br><span class="line">            <span class="type">HStack</span> &#123;</span><br><span class="line">                <span class="type">ForEach</span>(<span class="number">0</span><span class="operator">..&lt;</span>columns, id: \.<span class="keyword">self</span>) &#123; column <span class="keyword">in</span></span><br><span class="line">                    content(row, column)</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>现在我们有了一个自定义容器，我们可以像这样使用它编写一个视图：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">ContentView</span>: <span class="title class_">View</span> &#123;</span><br><span class="line">    <span class="keyword">var</span> body: <span class="keyword">some</span> <span class="type">View</span> &#123;</span><br><span class="line">        <span class="type">GridStack</span>(rows: <span class="number">4</span>, columns: <span class="number">4</span>) &#123; row, col <span class="keyword">in</span></span><br><span class="line">            <span class="type">Text</span>(<span class="string">&quot;R<span class="subst">\(row)</span> C<span class="subst">\(col)</span>&quot;</span>)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
    </div>

    <footer class="post-footer">
        <div class="post-nav">
            
                <div class="post-nav-prev">
                    <span>上一篇</span>
                    <a href="/article/5898.html">【Hacking With Swift】Project4_BetterRest</a>
                </div>
            
            
                <div class="post-nav-next">
                    <span>下一篇</span>
                    <a href="/article/2890.html">【Hacking With Swift】Project2_GuessTheFlag</a>
                </div>
            
        </div>
    </footer>

    
        <div class="post-comments">
            <h3 class="comments-title">评论</h3>
            <div id="waline"></div>
        </div>
    
</article>


    <script type="module">
        import { init } from 'https://unpkg.com/@waline/client@v3/dist/waline.js';

        init({
            el: '#waline',
            serverURL: 'https://walinecomments.five2fire.top',
            dark: 'auto',
            lang: 'zh-CN',
            pageview: true,
            comment: true,
            emoji: ["https://unpkg.com/@waline/emojis@1.1.0/weibo","https://unpkg.com/@waline/emojis@1.1.0/bilibili"]
        });
    </script>
    <link rel="stylesheet" href="https://unpkg.com/@waline/client@v3/dist/waline.css" />



            </main>
        </div>
        
    </div>
    
<script src="/js/main.js"></script>

    <script defer src="https://cdn.jsdelivr.net/npm/katex@0.16.8/dist/katex.min.js"></script>
    <script defer src="https://cdn.jsdelivr.net/npm/katex@0.16.8/dist/contrib/auto-render.min.js" onload="renderMathInElement(document.body);"></script>
</body>
</html>

<!DOCTYPE html>
<html>
<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
    <title>Sage自留地😎</title>
    
<link rel="stylesheet" href="/css/style.css">

<meta name="generator" content="Hexo 7.3.0"><link rel="alternate" href="/atom.xml" title="Sage自留地😎" type="application/atom+xml">
</head>
<body>
    <div class="container">
        <header class="header">
    <div class="site-title">
        <a href="/">Sage自留地😎</a>
    </div>
    <div class="nav-toggle">
        <span></span>
        <span></span>
        <span></span>
    </div>
    <nav class="nav">
        <ul class="nav-list">
            
                
                    <li class="nav-item">
                        <a href="/">首页</a>
                    </li>
                
            
                
                    <li class="nav-item has-children">
                        <a href="javascript:void(0);">文章</a>
                        <ul class="nav-submenu">
                            
                                <li class="nav-submenu-item">
                                    <a href="/archives">归档</a>
                                </li>
                            
                                <li class="nav-submenu-item">
                                    <a href="/categories">分类</a>
                                </li>
                            
                                <li class="nav-submenu-item">
                                    <a href="/tags">标签</a>
                                </li>
                            
                        </ul>
                    </li>
                
            
                
                    <li class="nav-item">
                        <a href="/about">关于</a>
                    </li>
                
            
        </ul>
    </nav>
</header>

        <div class="main-container">
            <main class="main-content">
                <div class="main-content">
    <article class="post-detail">
        <header class="post-header">
            <h1 class="post-title">【Hacking With Swift】project8_MoonShot</h1>
            <div class="post-meta">
                <span class="post-date">
                    2024-06-25
                </span>
                
                    <span class="post-category">
                        <a class="category-link" href="/categories/%E6%8A%80%E6%9C%AF/">技术</a>
                    </span>
                
                
                    <span class="post-tags">
                        <a class="tag-none-link" href="/tags/Hacking-with-Swift/" rel="tag">Hacking with Swift</a> <a class="tag-none-link" href="/tags/Swift/" rel="tag">Swift</a> <a class="tag-none-link" href="/tags/%E7%BC%96%E7%A8%8B/" rel="tag">编程</a>
                    </span>
                
            </div>
        </header>

        <div class="post-content">
            <p><em><strong><font color=red>英文原博博主是</font></strong></em>   <a target="_blank" rel="noopener" href="https://www.youtube.com/c/PaulHudson">Paul Hudson</a>    <i aria-hidden="true" class="fab fa-twitter" style="color: #4099ff"></i> <a href="https://twitter.com/twostraws" target="_blank">@twostraws</a></p>
<p><em><strong><font color=red>本文是学习Swift过程中翻译该网站的内容:</font></strong></em>   <a target="_blank" rel="noopener" href="https://www.hackingwithswift.com/">https://www.hackingwithswift.com/</a></p>
<!-- # MoonShotd登月项目 -->

<h1 id="引入"><a href="#引入" class="headerlink" title="引入"></a>引入</h1><p>在这个项目中，我们将构建一个应用程序，让用户了解组成 NASA 阿波罗太空计划的任务和宇航员。您将获得更多使用 Codable 的经验，但更重要的是，您还将使用滚动视图、导航和更有趣的布局。</p>
<p>是的，您将获得一些使用 List 、 Text 等内容的练习时间，但您还将开始解决重要的 SwiftUI 问题 – 如何使图像适合其空间正确吗？我们如何使用计算属性来清理代码？我们如何将较小的视图组合成较大的视图以帮助保持我们的项目井井有条？</p>
<p>一如既往，有很多事情要做，所以让我们开始吧：使用应用程序模板创建一个新的 iOS 应用程序，并将其命名为“Moonshot”。我们将在项目中使用它，但首先让我们仔细看看您需要熟悉的新技术……</p>
<h2 id="调整图像大小以适合可用的空间"><a href="#调整图像大小以适合可用的空间" class="headerlink" title="调整图像大小以适合可用的空间"></a>调整图像大小以适合可用的空间</h2><p>首先在项目中导入一个图片“example”，我们可以这样在视图中调用它</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">ContentView</span>: <span class="title class_">View</span> &#123;</span><br><span class="line">    <span class="keyword">var</span> body: <span class="keyword">some</span> <span class="type">View</span> &#123;</span><br><span class="line">        <span class="type">Image</span>(<span class="string">&quot;Example&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>你也可以将“example”替换成<code>.example </code>，这在SwiftUI中将会更安全。</p>
<p>此时你想要修改这个图像的大小，因为他看起来有些大。图像是一个视图，它和其他视图一样都有<code>frame() </code>修饰符，所以可以尝试添加这个修饰符</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Image</span>(.example)</span><br><span class="line">    .frame(width: <span class="number">300</span>, height: <span class="number">300</span>)</span><br></pre></td></tr></table></figure>
<p>然而，这是行不通的——你的图像仍然会显示为完整尺寸。<br><img src="https://sageimg.oss-cn-shenzhen.aliyuncs.com/image/20240625111438.png"><br>如果您想知道原因，请将 Xcode 的预览模式从“实时”更改为“可选”——查找 Xcode 预览左下角的三个按钮，然后单击其中有鼠标光标的按钮。</p>
<p>启用可选模式后，仔细查看预览窗口：您会看到图像是全尺寸的，但现在有一个 300x300 的框位于中间。图像视图的框架已正确设置，但图像内容仍按其原始大小显示</p>
<p>这样更改</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Image</span>(.example)</span><br><span class="line">    .frame(width: <span class="number">300</span>, height: <span class="number">300</span>)</span><br><span class="line">    .clipped()</span><br></pre></td></tr></table></figure>
<p><img src="https://sageimg.oss-cn-shenzhen.aliyuncs.com/image/20240625111555.png"><br>现在你会看得更清楚了：我们的图像视图确实是 300x300，但这并不是我们真正想要的。</p>
<p>也许你需要添加<code>.resizable() </code>修饰符，就像这样</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Image</span>(.example)</span><br><span class="line">    .resizable()</span><br><span class="line">    .frame(width: <span class="number">300</span>, height: <span class="number">300</span>)</span><br></pre></td></tr></table></figure>
<p>但是现在你会看到，图像现在已正确调整大小，但它可能看起来被压扁了。我的图像不是方形的，所以现在它被调整为方形后看起来扭曲了。<br><img src="https://sageimg.oss-cn-shenzhen.aliyuncs.com/image/20240625111804.png"></p>
<p>这里给出两个方案，<code>scaledToFit() </code>以及<code>scaledToFill() </code>，你可以看到他的不同效果<br><img src="https://sageimg.oss-cn-shenzhen.aliyuncs.com/image/20240625111951.png"></p>
<p>如果我们想要固定大小的图像，那么所有这些都非常有用，但通常您希望图像能够自动放大以在一维或两个维度上填充更多屏幕。也就是说，您真正想说的是“使该图像填充屏幕宽度的 80%”，而不是硬编码宽度 300。、</p>
<p>wiftUI 没有强制使用特定的框架，而是有一个专用的 <code>containerRelativeFrame() </code> 修饰符，可以让我们准确地获得我们想要的结果。 “容器”部分可能是整个屏幕，但也可能只是该视图的直接父级占据的屏幕部分 - 也许我们的图像与其他视图一起显示在 VStack 内。</p>
<p>这是个占屏幕宽度80%的图像的例子</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Image</span>(.example)</span><br><span class="line">    .resizable()</span><br><span class="line">    .scaledToFit()</span><br><span class="line">    .containerRelativeFrame(.horizontal) &#123; size, axis <span class="keyword">in</span></span><br><span class="line">        size <span class="operator">*</span> <span class="number">0.8</span></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p><img src="https://sageimg.oss-cn-shenzhen.aliyuncs.com/image/20240625112214.png"></p>
<p>我们不需要在这里指定高度。这是因为我们已经给了 SwiftUI 足够的信息，它可以自动计算出高度：它知道原始宽度，它知道我们的目标宽度，它知道我们的内容模式，所以它知道图像的目标高度将如何与目标宽度成正比。</p>
<h2 id="滚动视图"><a href="#滚动视图" class="headerlink" title="滚动视图"></a>滚动视图</h2><p>首先创建一个1——100的滚动列表<br><img src="https://sageimg.oss-cn-shenzhen.aliyuncs.com/image/20240625112358.png"></p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">ScrollView</span> &#123;</span><br><span class="line">    <span class="type">VStack</span>(spacing: <span class="number">10</span>) &#123;</span><br><span class="line">        <span class="type">ForEach</span>(<span class="number">0</span><span class="operator">..&lt;</span><span class="number">100</span>) &#123;</span><br><span class="line">            <span class="type">Text</span>(<span class="string">&quot;Item <span class="subst">\(<span class="variable">$0</span>)</span>&quot;</span>)</span><br><span class="line">                .font(.title)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>这些视图会立即创建，也就是说，在你还没有滚动到第100行的时候，它已经被创建好了，SwiftUI 不会等到你向下滚动才能看到它们，它只会立即创建它们。</p>
<p>为了演示这一点，我们可以围绕常规文本视图创建一个简单的包装器，并在ForEach中使用它，如下所示：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">CustomText</span>: <span class="title class_">View</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> text: <span class="type">String</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> body: <span class="keyword">some</span> <span class="type">View</span> &#123;</span><br><span class="line">        <span class="type">Text</span>(text)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">init</span>(<span class="keyword">_</span> <span class="params">text</span>: <span class="type">String</span>) &#123;</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;Creating a new CustomText&quot;</span>)</span><br><span class="line">        <span class="keyword">self</span>.text <span class="operator">=</span> text</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">ForEach</span>(<span class="number">0</span><span class="operator">..&lt;</span><span class="number">100</span>) &#123;</span><br><span class="line">    <span class="type">CustomText</span>(<span class="string">&quot;Item <span class="subst">\(<span class="variable">$0</span>)</span>&quot;</span>)</span><br><span class="line">        .font(.title)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>你会看到“Creating a new CustomText”在 Xcode 日志中打印了一百次</p>
<p>如果您想避免这种情况发生，可以为 VStack 和 HStack 提供一个替代方案，分别称为 <code> LazyVStack</code> 和 <code>LazyHStack </code> 。它们的使用方式与常规堆栈完全相同，但会按需加载其内容 - 在实际显示之前它们不会创建视图，因此最大限度地减少了所使用的系统资源量。</p>
<p>最后，可以在创建 ScrollView 时通过传递 .horizontal 作为参数来创建水平滚动视图，传递.vertical参数创建垂直滚动视图（默认的）<br><img src="https://sageimg.oss-cn-shenzhen.aliyuncs.com/image/20240625113144.png"></p>
<h2 id="使用-NavigationLink-将新视图推送到堆栈上"><a href="#使用-NavigationLink-将新视图推送到堆栈上" class="headerlink" title="使用 NavigationLink 将新视图推送到堆栈上"></a>使用 NavigationLink 将新视图推送到堆栈上</h2><p>SwiftUI 的 NavigationStack 在视图顶部显示一个导航栏，但还执行其他操作：它允许我们将视图推送到视图堆栈上。事实上，这确实是 iOS 导航的最基本形式 - 当您点击 Wi-Fi 或常规时，您可以在“设置”中看到它，或者当您点击某人的名字时，您可以在“消息”中看到它。</p>
<p>这个视图堆栈系统与我们之前使用的工作表（.sheet）非常不同。是的，两者都显示了某种新视图，但它们的呈现方式存在差异，影响了用户对它们的思考方式。</p>
<p>对比一下这两个代码</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">ContentView</span>: <span class="title class_">View</span> &#123;</span><br><span class="line">    <span class="keyword">var</span> body: <span class="keyword">some</span> <span class="type">View</span> &#123;</span><br><span class="line">        <span class="type">NavigationStack</span> &#123;</span><br><span class="line">            <span class="type">Text</span>(<span class="string">&quot;Tap Me&quot;</span>)</span><br><span class="line">                .navigationTitle(<span class="string">&quot;SwiftUI&quot;</span>)</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="type">NavigationStack</span> &#123;</span><br><span class="line">            <span class="type">NavigationLink</span>(<span class="string">&quot;Tap Me&quot;</span>) &#123;</span><br><span class="line">                <span class="type">Text</span>(<span class="string">&quot;Detail View&quot;</span>)</span><br><span class="line">            &#125;</span><br><span class="line">            .navigationTitle(<span class="string">&quot;SwiftUI&quot;</span>)</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="https://sageimg.oss-cn-shenzhen.aliyuncs.com/image/navigationlink.gif"><br>您会看到“点击我”现在看起来像一个按钮，点击它会使一个新视图从右侧滑入，显示“详细信息视图”。更好的是，您会看到“SwiftUI”标题向下动画变成后退按钮，您可以点击该按钮或从左边缘滑动以返回。</p>
<p>如果您想要简单文本视图以外的其他内容作为标签，则可以在 NavigationLink 中使用两个尾随闭包。例如，我们可以用多个文本视图和图像制作标签：<br><img src="https://sageimg.oss-cn-shenzhen.aliyuncs.com/image/20240625114527.png"></p>
<p>因此， sheet() 和 NavigationLink 都允许我们显示当前视图的新视图，但它们的方式不同，您应该仔细选择它们：</p>
<pre><code>    NavigationLink 用于显示有关用户选择的详细信息，就像您正在深入研究某个主题一样。
    sheet() 用于显示不相关的内容，例如设置或撰写窗口。
</code></pre>
<p>接下来用navigationlink改写ForEach列表：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">NavigationStack</span> &#123;</span><br><span class="line">    <span class="type">List</span>(<span class="number">0</span><span class="operator">..&lt;</span><span class="number">100</span>) &#123; row <span class="keyword">in</span></span><br><span class="line">        <span class="type">NavigationLink</span>(<span class="string">&quot;Row <span class="subst">\(row)</span>&quot;</span>) &#123;</span><br><span class="line">            <span class="type">Text</span>(<span class="string">&quot;Detail <span class="subst">\(row)</span>&quot;</span>)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    .navigationTitle(<span class="string">&quot;SwiftUI&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>navifationlink后面跟随的闭包则是详细视图内的内容。</p>
<h2 id="使用分层可编码数据（Working-with-hierarchical-Codable-data）"><a href="#使用分层可编码数据（Working-with-hierarchical-Codable-data）" class="headerlink" title="使用分层可编码数据（Working with hierarchical Codable data）"></a>使用分层可编码数据（Working with hierarchical Codable data）</h2><figure class="highlight plaintext"><figcaption><span>``` 协议使得解码平面数据变得很简单：如果您正在解码类型的单个实例，或者这些实例的数组或字典，那么事情就可以了。然而，在这个项目中，我们将解码稍微复杂的 JSON：一个数组位于另一个数组中，使用不同的数据类型。</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">如果您想解码这种分层数据，关键是为每个级别创建单独的类型。只要数据与您要求的层次结构相匹配， ``` Codable``` 就能够解码所有内容，无需我们进行进一步的工作。</span><br><span class="line"></span><br><span class="line">为了演示这一点，请将此按钮放入您的内容视图中：</span><br><span class="line">```swift</span><br><span class="line">Button(&quot;Decode JSON&quot;) &#123;</span><br><span class="line">    let input = &quot;&quot;&quot;</span><br><span class="line">    &#123;</span><br><span class="line">        &quot;name&quot;: &quot;Taylor Swift&quot;,</span><br><span class="line">        &quot;address&quot;: &#123;</span><br><span class="line">            &quot;street&quot;: &quot;555, Taylor Swift Avenue&quot;,</span><br><span class="line">            &quot;city&quot;: &quot;Nashville&quot;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    &quot;&quot;&quot;</span><br><span class="line"></span><br><span class="line">    // more code to come</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>创建与json格式匹配的结构：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">User</span>: <span class="title class_">Codable</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> name: <span class="type">String</span></span><br><span class="line">    <span class="keyword">let</span> address: <span class="type">Address</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Address</span>: <span class="title class_">Codable</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> street: <span class="type">String</span></span><br><span class="line">    <span class="keyword">let</span> city: <span class="type">String</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>然后将解析步骤写入到按钮的执行函数中</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> data <span class="operator">=</span> <span class="type">Data</span>(input.utf8)</span><br><span class="line"><span class="keyword">let</span> decoder <span class="operator">=</span> <span class="type">JSONDecoder</span>()</span><br><span class="line"><span class="keyword">if</span> <span class="keyword">let</span> user <span class="operator">=</span> <span class="keyword">try?</span> decoder.decode(<span class="type">User</span>.<span class="keyword">self</span>, from: data) &#123;</span><br><span class="line">    <span class="built_in">print</span>(user.address.street)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果您运行该程序并点击按钮，您应该会看到打印出的地址。Codable 将经历的级别数量没有限制 - 重要的是您定义的结构与您的 JSON 字符串相匹配。</p>
<h2 id="如何在滚动网格中布局视图"><a href="#如何在滚动网格中布局视图" class="headerlink" title="如何在滚动网格中布局视图"></a>如何在滚动网格中布局视图</h2><p>我们前面学习过HStack以及VStack等，还有List来显示滚动数据行，但如果需要显示网格要如何做呢？——通过两个视图<code>LazyVGrid </code>和<code> LazyHGrid</code>。</p>
<p>LazyHGrid 用于显示水平数据， LazyVGrid 用于显示垂直数据。就像惰性堆栈一样，名称中的“惰性”部分之所以存在，是因为 SwiftUI 会自动延迟加载它包含的视图，直到需要它们的那一刻，这意味着我们可以显示更多数据，而无需消耗大量系统资源。</p>
<p>创建网格分两步完成。首先，我们需要定义我们想要的行或列——我们只定义两者之一，具体取决于我们想要哪种类型的网格。</p>
<p>例如，如果我们有一个垂直滚动的网格，那么我们可能会说，通过将此属性添加到我们的视图中，我们希望将数据布局在三列中，宽度正好为 80 点：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> layout <span class="operator">=</span> [</span><br><span class="line">    <span class="type">GridItem</span>(.fixed(<span class="number">80</span>)),</span><br><span class="line">    <span class="type">GridItem</span>(.fixed(<span class="number">80</span>)),</span><br><span class="line">    <span class="type">GridItem</span>(.fixed(<span class="number">80</span>))</span><br><span class="line">]</span><br></pre></td></tr></table></figure>

<p>定义布局后，您应该将网格以及所需数量的项目放置在 ScrollView 内。您在网格中创建的每个项目都会自动分配一列，就像列表中的行自动放置在其父项中一样。例如，我们可以在三列网格内渲染 1000 个项目，如下所示：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">ScrollView</span> &#123;</span><br><span class="line">    <span class="type">LazyVGrid</span>(columns: layout) &#123;</span><br><span class="line">        <span class="type">ForEach</span>(<span class="number">0</span><span class="operator">..&lt;</span><span class="number">1000</span>) &#123;</span><br><span class="line">            <span class="type">Text</span>(<span class="string">&quot;Item <span class="subst">\(<span class="variable">$0</span>)</span>&quot;</span>)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>还可以创建自适应各种屏幕尺寸的网格，同时指定每一列的最小宽度和最大宽度。SwiftUI会根据屏幕大小自动填充列数。</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> layout <span class="operator">=</span> [</span><br><span class="line">    <span class="type">GridItem</span>(.adaptive(minimum: <span class="number">80</span>, maximum: <span class="number">120</span>)),</span><br><span class="line">]</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>可以比较一下指定列宽以及自适应列数的效果<br><img src="https://sageimg.oss-cn-shenzhen.aliyuncs.com/image/20240625141930.png"></p>
<p>在我们完成之前，我想简要向您展示如何制作水平网格。该过程几乎相同，您只需使 ScrollView 水平工作，然后使用行而不是列创建 LazyHGrid 。同样的，如果你使用了自适应视图，那会自动填充行数</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">ScrollView</span>(.horizontal) &#123;</span><br><span class="line">    <span class="type">LazyHGrid</span>(rows: layout) &#123;</span><br><span class="line">        <span class="type">ForEach</span>(<span class="number">0</span><span class="operator">..&lt;</span><span class="number">1000</span>) &#123;</span><br><span class="line">            <span class="type">Text</span>(<span class="string">&quot;Item <span class="subst">\(<span class="variable">$0</span>)</span>&quot;</span>)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><img src="https://sageimg.oss-cn-shenzhen.aliyuncs.com/image/20240625142250.png"></p>
<h1 id="正式开始构建项目"><a href="#正式开始构建项目" class="headerlink" title="正式开始构建项目"></a>正式开始构建项目</h1><h2 id="加载特定类型的可编码数据"><a href="#加载特定类型的可编码数据" class="headerlink" title="加载特定类型的可编码数据"></a>加载特定类型的可编码数据</h2><p>在此应用程序中，我们将把两种不同类型的 JSON 加载到 Swift 结构中：一种用于宇航员，一种用于任务。以一种易于维护且不会使我们的代码混乱的方式实现这一点需要一些思考，但我们将逐步努力实现这一目标。</p>
<p>将两个JSON文件拖入项目内，分别是astronauts.json 和missions.json。</p>
<p>接下来让我们将宇航员数据转换为 Swift 结构 - 按 Cmd+N 创建一个新文件，选择 Swift 文件，然后将其命名为 Astronaut.swift。（根据json文件中的格式来创建）</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Astronaut</span>: <span class="title class_">Codable</span>, <span class="title class_">Identifiable</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> id: <span class="type">String</span></span><br><span class="line">    <span class="keyword">let</span> name: <span class="type">String</span></span><br><span class="line">    <span class="keyword">let</span> description: <span class="type">String</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>接下来我们要将 astronauts.json 转换为 Astronaut 实例的字典，这意味着我们需要使用 Bundle 查找文件的路径，将其加载到 Data ，并将其传递给 JSONDecoder 。之前我们将其放入 ContentView 的方法中，但在这里我想向您展示一种更好的方法：我们将在 Bundle 上编写一个扩展来完成这一切一个集中的地方。</p>
<p>创建另一个新的 Swift 文件，这次名为 Bundle-Decodable.swift。这将主要使用您以前见过的代码，但有一个小区别：之前我们使用 String(contentsOf:) 将文件加载到字符串中，但因为 Codable 使用 Data 我们将使用 Data(contentsOf:) 。它的工作方式与 String(contentsOf:) 相同：给它一个要加载的文件 URL，它要么返回其内容，要么抛出错误。</p>
<p>现在将其添加到 Bundle-Decodable.swift 中：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">extension</span> <span class="title class_">Bundle</span> &#123;</span><br><span class="line">    <span class="keyword">func</span> <span class="title function_">decode</span>(<span class="keyword">_</span> <span class="params">file</span>: <span class="type">String</span>) -&gt; [<span class="type">String</span>: <span class="type">Astronaut</span>] &#123;</span><br><span class="line">        <span class="keyword">guard</span> <span class="keyword">let</span> url <span class="operator">=</span> <span class="keyword">self</span>.url(forResource: file, withExtension: <span class="literal">nil</span>) <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="built_in">fatalError</span>(<span class="string">&quot;Failed to locate <span class="subst">\(file)</span> in bundle.&quot;</span>)</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">guard</span> <span class="keyword">let</span> data <span class="operator">=</span> <span class="keyword">try?</span> <span class="type">Data</span>(contentsOf: url) <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="built_in">fatalError</span>(<span class="string">&quot;Failed to load <span class="subst">\(file)</span> from bundle.&quot;</span>)</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">let</span> decoder <span class="operator">=</span> <span class="type">JSONDecoder</span>()</span><br><span class="line"></span><br><span class="line">        <span class="keyword">guard</span> <span class="keyword">let</span> loaded <span class="operator">=</span> <span class="keyword">try?</span> decoder.decode([String: <span class="type">Astronaut</span>].<span class="keyword">self</span>, from: data) <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="built_in">fatalError</span>(<span class="string">&quot;Failed to decode <span class="subst">\(file)</span> from bundle.&quot;</span>)</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> loaded</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们稍后会回到这个问题，但正如您所看到的，它充分利用了 fatalError() ：如果无法找到、加载或解码文件，应用程序将崩溃。不过，和以前一样，除非您犯了错误，否则这种情况永远不会真正发生，例如，如果您忘记将 JSON 文件复制到项目中。</p>
<p>现在，您可能想知道为什么我们在这里使用扩展而不是方法，但当我们将该 JSON 加载到内容视图中时，原因就会变得清晰。现在将此属性添加到 ContentView 结构中：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> astronauts <span class="operator">=</span> <span class="type">Bundle</span>.main.decode(<span class="string">&quot;astronauts.json&quot;</span>)</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>你可以使用<code>Text(String(astronauts.count)) </code>来查看是否真的读取成功了。</p>
<p>在我们完成之前，我想回到我们的小扩展并更仔细地看看它。我们拥有的代码非常适合此应用程序，但如果您想在将来使用它，我建议您添加一些额外的代码来帮助您诊断问题。</p>
<p>将方法的第二部分替换为：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> decoder <span class="operator">=</span> <span class="type">JSONDecoder</span>()</span><br><span class="line"></span><br><span class="line"><span class="keyword">do</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">try</span> decoder.decode([String: <span class="type">Astronaut</span>].<span class="keyword">self</span>, from: data)</span><br><span class="line">&#125; <span class="keyword">catch</span> <span class="type">DecodingError</span>.keyNotFound(<span class="keyword">let</span> key, <span class="keyword">let</span> context) &#123;</span><br><span class="line">    <span class="built_in">fatalError</span>(<span class="string">&quot;Failed to decode <span class="subst">\(file)</span> from bundle due to missing key &#x27;<span class="subst">\(key.stringValue)</span>&#x27; – <span class="subst">\(context.debugDescription)</span>&quot;</span>)</span><br><span class="line">&#125; <span class="keyword">catch</span> <span class="type">DecodingError</span>.typeMismatch(<span class="keyword">_</span>, <span class="keyword">let</span> context) &#123;</span><br><span class="line">    <span class="built_in">fatalError</span>(<span class="string">&quot;Failed to decode <span class="subst">\(file)</span> from bundle due to type mismatch – <span class="subst">\(context.debugDescription)</span>&quot;</span>)</span><br><span class="line">&#125; <span class="keyword">catch</span> <span class="type">DecodingError</span>.valueNotFound(<span class="keyword">let</span> type, <span class="keyword">let</span> context) &#123;</span><br><span class="line">    <span class="built_in">fatalError</span>(<span class="string">&quot;Failed to decode <span class="subst">\(file)</span> from bundle due to missing <span class="subst">\(type)</span> value – <span class="subst">\(context.debugDescription)</span>&quot;</span>)</span><br><span class="line">&#125; <span class="keyword">catch</span> <span class="type">DecodingError</span>.dataCorrupted(<span class="keyword">_</span>) &#123;</span><br><span class="line">    <span class="built_in">fatalError</span>(<span class="string">&quot;Failed to decode <span class="subst">\(file)</span> from bundle because it appears to be invalid JSON.&quot;</span>)</span><br><span class="line">&#125; <span class="keyword">catch</span> &#123;</span><br><span class="line">    <span class="built_in">fatalError</span>(<span class="string">&quot;Failed to decode <span class="subst">\(file)</span> from bundle: <span class="subst">\(error.localizedDescription)</span>&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这不是一个大的变化，但这意味着该方法现在会告诉您解码出了什么问题 - 当您的 Swift 代码和 JSON 文件不太匹配时，这非常有用！</p>
<h2 id="使用泛型来加载任何类型的可编码数据"><a href="#使用泛型来加载任何类型的可编码数据" class="headerlink" title="使用泛型来加载任何类型的可编码数据"></a>使用泛型来加载任何类型的可编码数据</h2><p>在上一节，我们添加了一个 Bundle 扩展，用于从应用程序包中加载一种特定类型的 JSON 数据，但现在我们有第二种类型：missions.json。这包含稍微复杂一点的 JSON：</p>
<ul>
<li>每个任务都有一个ID号，这意味着我们可以轻松使用 Identifiable 。</li>
<li>每个任务都有一个描述，它是来自维基百科的自由文本字符串。</li>
<li>每个任务都有一组机组人员，每个机组人员都有名字和角色。</li>
<li>除一项任务外，所有任务都有发射日期。遗憾的是，阿波罗一号从未发射，因为发射排练舱火灾摧毁了指挥舱并杀死了机组人员。</li>
</ul>
<p>接下来转换Json为Swift数据。要创建多个结构来存储数据<br>你可以这样创建</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">CrewRole</span>: <span class="title class_">Codable</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> name: <span class="type">String</span></span><br><span class="line">    <span class="keyword">let</span> role: <span class="type">String</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Mission</span>: <span class="title class_">Codable</span>, <span class="title class_">Identifiable</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> id: <span class="type">Int</span></span><br><span class="line">    <span class="keyword">let</span> launchDate: <span class="type">String</span>?</span><br><span class="line">    <span class="keyword">let</span> crew: [<span class="type">CrewRole</span>]</span><br><span class="line">    <span class="keyword">let</span> description: <span class="type">String</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>首先注意在Mission结构中，launchDate是一个可选项，因为上面提到</p>
<pre><code>    除一项任务外，所有任务都有发射日期。遗憾的是，阿波罗一号从未发射，因为发射排练舱火灾摧毁了指挥舱并杀死了机组人员。
</code></pre>
<p>因此可能有项目是没有发射日期的。事实上，如果我们将某个属性标记为可选，如果输入 JSON 中缺少该值， Codable 将自动跳过该属性。</p>
<p>另外还要注意，我们的 CrewRole 结构是专门用来保存有关任务的数据的，因此我们实际上可以将 CrewRole 结构也放到Misson的结构内</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Mission</span>: <span class="title class_">Codable</span>, <span class="title class_">Identifiable</span> &#123;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">CrewRole</span>: <span class="title class_">Codable</span> &#123;</span><br><span class="line">        <span class="keyword">let</span> name: <span class="type">String</span></span><br><span class="line">        <span class="keyword">let</span> role: <span class="type">String</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> id: <span class="type">Int</span></span><br><span class="line">    <span class="keyword">let</span> launchDate: <span class="type">String</span>?</span><br><span class="line">    <span class="keyword">let</span> crew: [<span class="type">CrewRole</span>]</span><br><span class="line">    <span class="keyword">let</span> description: <span class="type">String</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这称为嵌套结构，只是将一个结构放置在另一个结构中。这不会影响我们在这个项目中的代码，但在其他地方它有助于保持代码的组织性：而不是说 CrewRole 你会写 Mission.CrewRole 。如果您可以想象一个具有数百个自定义类型的项目，那么添加这个额外的上下文确实会有帮助！</p>
<p>现在让我们考虑如何将 Mission.json 加载到 Mission 结构数组中。我们已经添加了一个 Bundle 扩展，它将一些 JSON 文件加载到 Astronaut 结构的字典中，因此我们可以非常轻松地复制和粘贴它，然后对其进行调整，以便它加载任务而不是宇航员。然而，有一个更好的解决方案：我们可以利用 Swift 的泛型系统。</p>
<p>泛型允许我们编写能够处理各种不同类型的代码。在这个项目中，我们编写了 Bundle 扩展来处理宇航员字典，但实际上我们希望能够处理宇航员字典、任务数组或可能的许多其他东西。</p>
<p>为了使方法具有通用性，我们为它提供了某些类型的占位符。这写在方法名称之后、参数之前的尖括号（ &lt; 和 &gt; ）中，如下所示：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">func</span> <span class="title function_">decode</span>&lt;<span class="type">T</span>&gt;(<span class="keyword">_</span> <span class="params">file</span>: <span class="type">String</span>) -&gt; [<span class="type">String</span>: <span class="type">Astronaut</span>] &#123;</span><br></pre></td></tr></table></figure>
<p>我们可以使用任何东西作为该占位符——我们可以写“Type”、“TypeOfThing”，甚至“Fish”；没关系。 “T”是编码中的一种约定，作为“type”的简写占位符。</p>
<p>在方法内部，我们现在可以在任何需要使用 [String: Astronaut] 的地方使用“T”——它实际上是我们想要使用的类型的占位符。因此，我们不会返回 [String: Astronaut] 我们会使用这个：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">func</span> <span class="title function_">decode</span>&lt;<span class="type">T</span>&gt;(<span class="keyword">_</span> <span class="params">file</span>: <span class="type">String</span>) -&gt; <span class="type">T</span> &#123;</span><br></pre></td></tr></table></figure>
<p>要非常小心： T 和 [T] 之间有很大的区别。请记住， T 是我们要求的任何类型的占位符，因此如果我们说“解码我们的宇航员字典”，那么 T 就会变成 [String: Astronaut] 。如果我们尝试从 decode() 返回 [T] 那么我们实际上会返回 [[String: Astronaut]] – 宇航员字典的数组！</p>
<p>在 decode() 方法的中间还有一个使用 [String: Astronaut] 的地方，再次，请将其更改为 T ，如下所示：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">return</span> <span class="keyword">try</span> decoder.decode([String: <span class="type">Astronaut</span>].<span class="keyword">self</span>, from: data)</span><br><span class="line"></span><br><span class="line"><span class="comment">//改为</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="keyword">try</span> decoder.decode(<span class="type">T</span>.<span class="keyword">self</span>, from: data)</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>因此，我们所说的是 decode() 将与某种类型一起使用，例如 [String: Astronaut] ，并且它应该尝试将其加载的文件解码为该类型。</p>
<p>如果您尝试编译此代码，您将在 Xcode 中看到错误：“实例方法 ‘decode(_:from:)’ 要求 ‘T’ 符合 ‘Decodable’”。它的意思是 T 可以是任何东西：它可以是宇航员的字典，也可以是完全其他东西的字典。问题是 Swift 无法确定我们正在使用的类型是否符合 Codable 协议，因此与其冒险，不如拒绝构建我们的代码。</p>
<p>幸运的是，我们可以通过一个约束来解决这个问题：我们可以告诉 Swift T 可以是我们想要的任何东西，只要它符合 Codable 。这样 Swift 就知道它可以安全使用，并确保我们不会尝试使用不符合 Codable 的类型的方法。</p>
<p>要添加约束，请将方法签名更改为：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">func</span> <span class="title function_">decode</span>&lt;<span class="type">T</span>: <span class="type">Codable</span>&gt;(<span class="keyword">_</span> <span class="params">file</span>: <span class="type">String</span>) -&gt; <span class="type">T</span> &#123;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>如果您尝试再次编译，您会发现事情仍然无法正常工作，但现在是由于不同的原因：“无法推断通用参数’T’”，在 astronauts 属性中 ContentView 。这条线以前工作得很好，但现在有一个重要的变化：以前 decode() 总是返回宇航员的字典，但现在它返回任何我们想要的东西，只要它符合 Codable .</p>
<p>我们知道它仍然会返回宇航员字典，因为实际的底层数据没有改变，但 Swift 不知道这一点。我们的问题是 decode() 可以返回任何符合 Codable 的类型，但 Swift 需要更多信息——它想知道它到底是什么类型。</p>
<p>因此，为了解决这个问题，我们需要使用类型注释，以便 Swift 确切地知道 astronauts 是什么：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> astronauts: [<span class="type">String</span>: <span class="type">Astronaut</span>] <span class="operator">=</span> <span class="type">Bundle</span>.main.decode(<span class="string">&quot;astronauts.json&quot;</span>)</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>终于——在所有工作之后！ – 我们现在还可以将 Mission.json 加载到 ContentView 中的另一个属性中。请在下面添加此 astronauts ：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> missions: [<span class="type">Mission</span>] <span class="operator">=</span> <span class="type">Bundle</span>.main.decode(<span class="string">&quot;missions.json&quot;</span>)</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>这就是泛型的力量：我们可以使用相同的 decode() 方法将我们的包中的任何 JSON 加载到符合 Codable 的任何 Swift 类型中 - 我们不需要半个同一方法的十几种变体。</p>
<p>在我们结束之前，我想解释最后一件事。之前您看到消息“实例方法 ‘decode(_:from:)’ 要求 ‘T’ 符合 ‘Decodable’”，您可能想知道 Decodable 是什么 - 毕竟，我们已经到处都在使用 Codable 。好吧，在幕后， Codable 只是两个单独协议的别名： Encodable 和 Decodable 。如果需要，您可以使用 Codable ，如果您喜欢具体，则可以使用 Encodable 和 Decodable – 这取决于您。</p>
<p>现在我们可以同时解析宇航员和任务了：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> astronauts: [<span class="type">String</span>: <span class="type">Astronaut</span>] <span class="operator">=</span> <span class="type">Bundle</span>.main.decode(<span class="string">&quot;astronauts.json&quot;</span>)</span><br><span class="line"><span class="keyword">let</span> missions: [<span class="type">Mission</span>] <span class="operator">=</span> <span class="type">Bundle</span>.main.decode(<span class="string">&quot;missions.json&quot;</span>)</span><br></pre></td></tr></table></figure>

<h2 id="格式化任务视图"><a href="#格式化任务视图" class="headerlink" title="格式化任务视图"></a>格式化任务视图</h2><p>现在我们已经有了所有数据，我们可以看看第一个屏幕的设计：所有任务的网格，位于任务徽章旁边。</p>
<p>我们之前添加的资产包含名为“<a href="mailto:&#x61;&#112;&#111;&#108;&#x6c;&#111;&#49;&#64;&#50;&#x78;&#46;&#112;&#x6e;&#x67;">&#x61;&#112;&#111;&#108;&#x6c;&#111;&#49;&#64;&#50;&#x78;&#46;&#112;&#x6e;&#x67;</a>”和类似的图片，这意味着它们可以在资产目录中以“apollo1”、“apollo12”等形式访问。我们的 Mission 结构有一个 id 整数提供数字部分，因此我们可以使用字符串插值，例如 <code>&quot;apollo\(mission.id)&quot; </code> 来获取图像名称和 <code>&quot;Apollo \(mission.id)&quot; </code>来获取任务名称</p>
<p>不过，在这里，我们将采取不同的方法：我们将向 Mission 结构添加一些计算属性以发回相同的数据。结果将是相同的 - “apollo1”和“Apollo 1” - 但现在代码位于一个位置：我们的 Mission 结构体。这意味着任何其他视图都可以使用相同的数据，而不必重复我们的字符串插值代码，这反过来意味着如果我们改变这些东西的格式化方式 - 即我们将图像名称更改为“apollo-1”或其他东西 - 那么我们只需更改 Mission 中的属性即可更新所有代码。</p>
<p>因此，请立即将这两个属性添加到 Mission 结构中：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> displayName: <span class="type">String</span> &#123;</span><br><span class="line">    <span class="string">&quot;Apollo <span class="subst">\(id)</span>&quot;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> image: <span class="type">String</span> &#123;</span><br><span class="line">    <span class="string">&quot;apollo<span class="subst">\(id)</span>&quot;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>有了这两个，我们现在可以第一次填写 ContentView ：它将有一个带有标题的 NavigationStack ，一个使用我们的 missions 数组作为输入，里面的每一行都会有一个 NavigationLink 包含任务的图像、名称和发射日期。其中唯一的小复杂性是我们的启动日期是一个可选字符串，因此我们需要使用 nil 合并来确保文本视图有一个要显示的值。</p>
<p>首先，将此属性添加到 ContentView 以定义自适应列布局：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> columns <span class="operator">=</span> [</span><br><span class="line">    <span class="type">GridItem</span>(.adaptive(minimum: <span class="number">150</span>))</span><br><span class="line">]</span><br></pre></td></tr></table></figure>
<p>现在用以下内容替换现有的 body 属性：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">NavigationStack</span> &#123;</span><br><span class="line">    <span class="type">ScrollView</span> &#123;</span><br><span class="line">        <span class="type">LazyVGrid</span>(columns: columns) &#123;</span><br><span class="line">            <span class="type">ForEach</span>(missions) &#123; mission <span class="keyword">in</span></span><br><span class="line">                <span class="type">NavigationLink</span> &#123;</span><br><span class="line">                    <span class="type">Text</span>(<span class="string">&quot;Detail view&quot;</span>)</span><br><span class="line">                &#125; label: &#123;</span><br><span class="line">                    <span class="type">VStack</span> &#123;</span><br><span class="line">                        <span class="type">Image</span>(mission.image)</span><br><span class="line">                            .resizable()</span><br><span class="line">                            .scaledToFit()</span><br><span class="line">                            .frame(width: <span class="number">100</span>, height: <span class="number">100</span>)</span><br><span class="line"></span><br><span class="line">                        <span class="type">VStack</span> &#123;</span><br><span class="line">                            <span class="type">Text</span>(mission.displayName)</span><br><span class="line">                                .font(.headline)</span><br><span class="line">                            <span class="type">Text</span>(mission.launchDate <span class="operator">??</span> <span class="string">&quot;N/A&quot;</span>)</span><br><span class="line">                                .font(.caption)</span><br><span class="line">                        &#125;</span><br><span class="line">                        .frame(maxWidth: .infinity)</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    .navigationTitle(<span class="string">&quot;Moonshot&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="优化显示"><a href="#优化显示" class="headerlink" title="优化显示"></a>优化显示</h2><p>接下来优化一下显示。</p>
<p>Swift 的 JSONDecoder 类型有一个名为 dateDecodingStrategy 的属性，它决定了它应该如何解码日期。我们可以提供一个 DateFormatter 实例来描述日期的格式。在本例中，我们的日期写为年-月-日，在 DateFormat 的世界中写为“y-MM-dd”——这意味着“一年，然后是破折号，然后是零填充的月份，然后是破折号，然后是零填充的日”，其中“零填充”意味着一月写为“01”而不是“1”。</p>
<pre><code>    警告：日期格式区分大小写！ mm 表示“零填充分钟”， MM 表示“零填充月份”。
</code></pre>
<p>因此，打开 Bundle-Decodable.swift 并直接在 let decoder &#x3D; JSONDecoder() 之后添加此代码：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> formatter <span class="operator">=</span> <span class="type">DateFormatter</span>()</span><br><span class="line">formatter.dateFormat <span class="operator">=</span> <span class="string">&quot;y-MM-dd&quot;</span></span><br><span class="line">decoder.dateDecodingStrategy <span class="operator">=</span> .formatted(formatter)</span><br></pre></td></tr></table></figure>

<p>如果你现在运行代码……事情看起来会完全一样。是的，什么都没有改变，但这没关系：什么都没有改变，因为 Swift 没有意识到 launchDate 是一个日期。毕竟，我们是这样声明的：<code>let launchDate: String? </code>，现在把他改成<code>let launchDate: Date? </code>，你会发现这里出错了</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Text</span>(mission.launchDate <span class="operator">??</span> <span class="string">&quot;N/A&quot;</span>)</span><br></pre></td></tr></table></figure>

<p>它尝试在文本视图中使用可选的 Date ，或者如果日期为空，则将其替换为“N&#x2F;A”。这是计算属性效果更好的另一个地方：我们可以要求任务本身提供格式化的启动日期，将可选日期转换为格式整齐的字符串，或者针对缺失的日期发回“N&#x2F;A”。</p>
<p>这使用了我们之前使用过的相同的 formatted() 方法，所以这对你来说应该有点熟悉。现在将此计算属性添加到 Mission 中：然后将<code>Text(mission.launchDate ?? &quot;N/A&quot;) </code>替换为<code>Text(mission.formattedLaunchDate) </code></p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> formattedLaunchDate: <span class="type">String</span> &#123;</span><br><span class="line">    launchDate<span class="operator">?</span>.formatted(date: .abbreviated, time: .omitted) <span class="operator">??</span> <span class="string">&quot;N/A&quot;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>通过这一更改，我们的日期将以更自然的方式呈现，甚至更好，将以适合用户区域的任何方式呈现 - 您看到的不一定是我看到的。<br><img src="https://sageimg.oss-cn-shenzhen.aliyuncs.com/image/20240625161122.png"></p>
<p>现在让我们关注更大的问题：我们的布局非常乏味！</p>
<p>为了稍微美化一下，我想向您介绍两个有用的功能：如何轻松共享自定义应用程序颜色，以及如何为我们的应用程序强制使用深色主题。</p>
<p>首先，颜色。有两种方法可以做到这一点，两种方法都很有用：您可以使用特定名称将颜色添加到资产目录中，或者可以将它们添加为 Swift 扩展。它们都有各自的优点——使用资产目录可以让您直观地工作，但使用代码可以更轻松地使用 GitHub 等工具来监控更改。</p>
<p>在这两种方法中，我更喜欢代码方法，因为当您在团队中工作时，它可以更轻松地跟踪更改，因此我们将把颜色名称作为扩展放入 Swift 中。</p>
<p>如果我们在 Color 上进行这些扩展，我们可以在 SwiftUI 中的几个地方使用它们，但 Swift 为我们提供了一个更好的选择，只需要多一点代码。您会看到， Color 符合一个名为 ShapeStyle 的更大协议，该协议允许我们使用颜色、渐变、材质等，就好像它们是同一事物一样。</p>
<p>这个 ShapeStyle 协议是 background() 修饰符使用的，所以我们真正想做的是扩展 Color 但这样做的方式是所有 SwiftUI 修饰符都使用 ShapeStyle 也可以工作。这可以通过非常精确的扩展来完成，字面意思是“我们想向 ShapeStyle 添加功能，但仅限于它被用作颜色的时候。”</p>
<p>要尝试此操作，请创建一个名为 Color-Theme.swift 的新 Swift 文件，将其更改为 SwiftUI 的 Foundation import，然后为其提供以下代码：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">extension</span> <span class="title class_">ShapeStyle</span> <span class="title class_">where</span> <span class="title class_">Self</span> == <span class="title class_">Color</span> &#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">var</span> darkBackground: <span class="type">Color</span> &#123;</span><br><span class="line">        <span class="type">Color</span>(red: <span class="number">0.1</span>, green: <span class="number">0.1</span>, blue: <span class="number">0.2</span>)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">var</span> lightBackground: <span class="type">Color</span> &#123;</span><br><span class="line">        <span class="type">Color</span>(red: <span class="number">0.2</span>, green: <span class="number">0.2</span>, blue: <span class="number">0.3</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这添加了两种新颜色，称为 darkBackground 和 lightBackground ，每种颜色都有红色、绿色和蓝色的精确值。但更重要的是，他们将它们放置在一个非常具体的扩展中，使我们可以在 SwiftUI 需要 ShapeStyle 的任何地方使用这些颜色。</p>
<p>我想立即将这些新颜色付诸实践。首先，找到包含任务名称和发射日期的 VStack - 它应该已经有 .frame(maxWidth: .infinity) 了，但我希望您将其修饰符顺序更改为：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">.padding(.vertical)</span><br><span class="line">.frame(maxWidth: .infinity)</span><br><span class="line">.background(.lightBackground)</span><br></pre></td></tr></table></figure>

<p>最终其他的显示优化代码如下：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">ContentView</span>: <span class="title class_">View</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> astronauts: [<span class="type">String</span>: <span class="type">Astronaut</span>] <span class="operator">=</span> <span class="type">Bundle</span>.main.decode(<span class="string">&quot;astronauts.json&quot;</span>)</span><br><span class="line">    <span class="keyword">let</span> missions: [<span class="type">Mission</span>] <span class="operator">=</span> <span class="type">Bundle</span>.main.decode(<span class="string">&quot;missions.json&quot;</span>)</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">let</span> columns <span class="operator">=</span> [</span><br><span class="line">        <span class="type">GridItem</span>(.adaptive(minimum: <span class="number">150</span>))</span><br><span class="line">    </span><br><span class="line">    ]</span><br><span class="line">    <span class="keyword">var</span> body: <span class="keyword">some</span> <span class="type">View</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="type">NavigationStack</span> &#123;</span><br><span class="line">            <span class="type">ScrollView</span> &#123;</span><br><span class="line">                <span class="type">LazyVGrid</span>(columns: columns) &#123;</span><br><span class="line">                    <span class="type">ForEach</span>(missions) &#123; mission <span class="keyword">in</span></span><br><span class="line">                        <span class="type">NavigationLink</span> &#123;</span><br><span class="line">                            <span class="type">Text</span>(<span class="string">&quot;Detail View&quot;</span>)</span><br><span class="line">                        &#125; label: &#123;</span><br><span class="line">                            <span class="type">VStack</span> &#123;</span><br><span class="line">                                <span class="type">Image</span>(mission.image)</span><br><span class="line">                                    .resizable()</span><br><span class="line">                                    .scaledToFit()</span><br><span class="line">                                    .frame(width: <span class="number">100</span>, height: <span class="number">100</span>)</span><br><span class="line">                                    .padding()</span><br><span class="line">                                <span class="type">VStack</span> &#123;</span><br><span class="line">                                    <span class="type">Text</span>(mission.displayName)</span><br><span class="line">                                        .font(.headline)</span><br><span class="line">                                        .foregroundStyle(.white)</span><br><span class="line">                                    <span class="type">Text</span>(mission.formattedLaunchDate)</span><br><span class="line">                                        .font(.caption)</span><br><span class="line">                                        .foregroundStyle(.white.opacity(<span class="number">0.5</span>))</span><br><span class="line">                                &#125;</span><br><span class="line">                                .padding(.vertical)</span><br><span class="line">                                .frame(maxWidth: .infinity)</span><br><span class="line">                                .background(.lightBackground)</span><br><span class="line">                            &#125;</span><br><span class="line">                            .clipShape(.rect(cornerRadius: <span class="number">10</span>))</span><br><span class="line">                            .overlay(</span><br><span class="line">                                <span class="type">RoundedRectangle</span>(cornerRadius: <span class="number">10</span>)</span><br><span class="line">                                    .stroke(.lightBackground)</span><br><span class="line">                            )</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                    </span><br><span class="line">                &#125;</span><br><span class="line">                .padding([.horizontal, .bottom])</span><br><span class="line">                .preferredColorScheme(.dark)</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            .navigationTitle(<span class="string">&quot;MoonShot&quot;</span>)</span><br><span class="line">            .background(.darkBackground)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>如果您现在运行该应用程序，您会看到我们有一个精美的任务数据滚动网格，可以平滑地适应各种设备尺寸，无论用户启用什么外观，我们都有明亮的白色导航文本和深色导航背景，点击我们的任何任务都会带来临时的详细视图。一个好的开始！</p>
<h2 id="使用-ScrollView-和-containerRelativeFrame-显示任务详细信息"><a href="#使用-ScrollView-和-containerRelativeFrame-显示任务详细信息" class="headerlink" title="使用 ScrollView 和 containerRelativeFrame() 显示任务详细信息"></a>使用 ScrollView 和 containerRelativeFrame() 显示任务详细信息</h2><p>当用户从我们的主列表中选择一项阿波罗任务时，我们希望显示有关该任务的信息：其任务徽章、任务描述以及机组人员中的所有宇航员及其角色。前两个并不太难，但第三个需要更多工作，因为我们需要将两个 JSON 文件中的船员 ID 与船员详细信息进行匹配。</p>
<p>让我们从简单的开始，逐步完善：创建一个名为 MissionView.swift 的新 SwiftUI 视图。最初，它只有一个 mission 属性，以便我们可以显示任务徽章和描述，但很快我们将添加更多内容。</p>
<p>在布局方面，这个东西需要有一个滚动 VStack 和一个可调整大小的任务徽章图像，然后是一个文本视图。我们将使用 containerRelativeFrame() 来设置任务图像的宽度 - 通过一些试验和错误，我发现任务徽章在不是全宽时效果最好 - 看起来宽度在 50% 到 70% 之间更好的是，避免它在屏幕上变得异常大。</p>
<p>现在将此代码放入 MissionView.swift 中：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">MissionView</span>: <span class="title class_">View</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> mission: <span class="type">Mission</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> body: <span class="keyword">some</span> <span class="type">View</span> &#123;</span><br><span class="line">        <span class="type">ScrollView</span> &#123;</span><br><span class="line">            <span class="type">VStack</span> &#123;</span><br><span class="line">                <span class="type">Image</span>(mission.image)</span><br><span class="line">                    .resizable()</span><br><span class="line">                    .scaledToFit()</span><br><span class="line">                    .containerRelativeFrame(.horizontal) &#123; width, axis <span class="keyword">in</span></span><br><span class="line">                        width <span class="operator">*</span> <span class="number">0.6</span></span><br><span class="line">                    &#125;</span><br><span class="line">                    .padding(.top)</span><br><span class="line"></span><br><span class="line">                <span class="type">VStack</span>(alignment: .leading) &#123;</span><br><span class="line">                    <span class="type">Text</span>(<span class="string">&quot;Mission Highlights&quot;</span>)</span><br><span class="line">                        .font(.title.bold())</span><br><span class="line">                        .padding(.bottom, <span class="number">5</span>)</span><br><span class="line"></span><br><span class="line">                    <span class="type">Text</span>(mission.description)</span><br><span class="line">                &#125;</span><br><span class="line">                .padding(.horizontal)</span><br><span class="line">            &#125;</span><br><span class="line">            .padding(.bottom)</span><br><span class="line">        &#125;</span><br><span class="line">        .navigationTitle(mission.displayName)</span><br><span class="line">        .navigationBarTitleDisplayMode(.inline)</span><br><span class="line">        .background(.darkBackground)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>效果如下：<br><img src="https://sageimg.oss-cn-shenzhen.aliyuncs.com/image/moonshot.gif"></p>
<h2 id="合并可编码结构"><a href="#合并可编码结构" class="headerlink" title="合并可编码结构"></a>合并可编码结构</h2><p>在我们的任务描述下方，我们希望显示每个机组成员的图片、姓名和角色，这意味着匹配来自两个不同 JSON 文件的数据。</p>
<p>如果您还记得，我们的 JSON 数据分为 Mission.json 和 astronauts.json。这消除了数据中的重复，因为一些宇航员参加了多次任务，但这也意味着我们需要编写一些代码将我们的数据连接在一起 - 例如，将“阿姆斯特朗”解析为“尼尔·阿姆斯特朗”。你看，一方面我们的任务知道机组成员“阿姆斯特朗”的角色是“指挥官”，但不知道“阿姆斯特朗”是谁，而另一方面我们有“尼尔·阿姆斯特朗”和描述他，但不知道他是阿波罗 11 号的指挥官。</p>
<p>因此，我们需要做的是让我们的 MissionView 接受被点击的任务，以及我们完整的宇航员字典，然后让它找出哪些宇航员实际参加了发射。</p>
<p>现在在 MissionView 中添加这个嵌套结构：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">CrewMember</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> role: <span class="type">String</span></span><br><span class="line">    <span class="keyword">let</span> astronaut: <span class="type">Astronaut</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>但是我们如何设置该属性呢？好吧，想一想：如果我们让这个视图被赋予其任务和所有宇航员，我们可以遍历任务机组人员，然后为每个机组人员在字典中查找具有匹配 ID 的人员。当我们找到一个时，我们可以将其及其角色转换为 CrewMember 对象，但如果我们不这样做，则意味着我们有一个具有无效或未知名称的船员角色。</p>
<p>后一种情况绝对不应该发生。需要明确的是，如果您在项目中添加了一些指向应用程序中丢失数据的 JSON，那么您就犯了一个根本性错误 - 这不是您应该尝试在运行时编写错误处理的类型，因为它从一开始就不应该允许这种情况发生。所以，这是 fatalError() 有用的一个很好的例子：如果我们无法使用他们的 ID 找到宇航员，我们应该立即退出并大声抱怨。</p>
<p>让我们将所有这些都放入代码中，使用 MissionView 的自定义初始值设定项。就像我说的，这将接受它与所有宇航员一起代表的任务，它的工作是存储任务，然后找出已解决的宇航员数组。</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//    init(mission: Mission, crew: [CrewMember]) &#123;</span></span><br><span class="line"><span class="comment">//        self.mission = mission</span></span><br><span class="line"><span class="comment">//        self.crew = crew</span></span><br><span class="line"><span class="comment">//    &#125;</span></span><br><span class="line">    </span><br><span class="line"></span><br><span class="line">    <span class="keyword">init</span>(<span class="params">mission</span>: <span class="type">Mission</span>, <span class="params">astronauts</span>: [<span class="params">String</span>: <span class="type">Astronaut</span>]) &#123;</span><br><span class="line">        <span class="keyword">self</span>.mission <span class="operator">=</span> mission</span><br><span class="line">        <span class="keyword">self</span>.crew <span class="operator">=</span> mission.crew.map &#123; member <span class="keyword">in</span></span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">let</span> astronaut <span class="operator">=</span> astronauts[member.name] &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="type">CrewMember</span>(role: member.role, astronaut: astronaut)</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="built_in">fatalError</span>(<span class="string">&quot;Missing <span class="subst">\(member.name)</span>&quot;</span>)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>这里就是本节<strong>合并可编码结构</strong>的重点，注意和默认的init方法的区分，</p>
<p>一旦该代码进入，我们的预览结构将再次停止工作，因为它需要更多信息。因此，添加对 decode() 的第二次调用，以便加载所有宇航员，然后将它们也传递进去：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">#<span class="type">Preview</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> missions: [<span class="type">Mission</span>] <span class="operator">=</span> <span class="type">Bundle</span>.main.decode(<span class="string">&quot;missions.json&quot;</span>)</span><br><span class="line">    <span class="keyword">let</span> astronauts: [<span class="type">String</span>: <span class="type">Astronaut</span>] <span class="operator">=</span> <span class="type">Bundle</span>.main.decode(<span class="string">&quot;astronauts.json&quot;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="type">MissionView</span>(mission: missions[<span class="number">0</span>], astronauts: astronauts)</span><br><span class="line">        .preferredColorScheme(.dark)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>现在我们有了所有宇航员数据，我们可以使用水平滚动视图直接在任务描述下方显示这些数据。我们还将使用胶囊夹形状和叠加层为宇航员照片添加一些额外的样式，使它们看起来更好。</p>
<p>在 VStack(alignment: .leading) 之后添加此代码：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">ScrollView</span>(.horizontal, showsIndicators: <span class="literal">false</span>) &#123;</span><br><span class="line">    <span class="type">HStack</span> &#123;</span><br><span class="line">        <span class="type">ForEach</span>(crew, id: \.role) &#123; crewMember <span class="keyword">in</span></span><br><span class="line">            <span class="type">NavigationLink</span> &#123;</span><br><span class="line">                <span class="type">Text</span>(<span class="string">&quot;Astronaut details&quot;</span>)</span><br><span class="line">            &#125; label: &#123;</span><br><span class="line">                <span class="type">HStack</span> &#123;</span><br><span class="line">                    <span class="type">Image</span>(crewMember.astronaut.id)</span><br><span class="line">                        .resizable()</span><br><span class="line">                        .frame(width: <span class="number">104</span>, height: <span class="number">72</span>)</span><br><span class="line">                        .clipShape(.capsule)</span><br><span class="line">                        .overlay(</span><br><span class="line">                            <span class="type">Capsule</span>()</span><br><span class="line">                                .strokeBorder(.white, lineWidth: <span class="number">1</span>)</span><br><span class="line">                        )</span><br><span class="line"></span><br><span class="line">                    <span class="type">VStack</span>(alignment: .leading) &#123;</span><br><span class="line">                        <span class="type">Text</span>(crewMember.astronaut.name)</span><br><span class="line">                            .foregroundStyle(.white)</span><br><span class="line">                            .font(.headline)</span><br><span class="line">                        <span class="type">Text</span>(crewMember.role)</span><br><span class="line">                            .foregroundStyle(.white.opacity(<span class="number">0.5</span>))</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                .padding(.horizontal)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>ContentView也替换<code>MissionView(mission: mission, astronauts: astronauts)</code></p>
<p>在我的项目中，我认为在任务视图中添加一点视觉分离会很有用，这样任务徽章、描述和人员就可以更清晰地分开。</p>
<p>SwiftUI 确实提供了一个专用的 Divider 视图，用于在布局中创建视觉划分，但它不可自定义 - 它始终只是一条细线。因此，为了获得更有用的东西，我将绘制一个自定义分隔线来分隔我们的视图。</p>
<h2 id="完成最后一张视图"><a href="#完成最后一张视图" class="headerlink" title="完成最后一张视图"></a>完成最后一张视图</h2><p>为了完成这个程序，我们将制作第三个也是最后一个视图来显示宇航员的详细信息，这可以通过点击任务视图中的一名宇航员来实现。这主要应该只是您的练习，但我希望它也向您展示了 NavigationStack 的重要性 - 我们正在更深入地挖掘我们应用程序的信息，滑入和滑出视图的呈现确实能让您明白这一点给用户。</p>
<p>首先创建一个名为 AstronautView 的新 SwiftUI 视图。这将有一个 Astronaut 属性，因此它知道要显示什么，然后它将使用类似于 ScrollView &#x2F; VStack 组合来布局，就像我们在 &lt; b4&gt; 。给它这个代码：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">AstronautView</span>: <span class="title class_">View</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> astronaut: <span class="type">Astronaut</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> body: <span class="keyword">some</span> <span class="type">View</span> &#123;</span><br><span class="line">        <span class="type">ScrollView</span> &#123;</span><br><span class="line">            <span class="type">VStack</span> &#123;</span><br><span class="line">                <span class="type">Image</span>(astronaut.id)</span><br><span class="line">                    .resizable()</span><br><span class="line">                    .scaledToFit()</span><br><span class="line"></span><br><span class="line">                <span class="type">Text</span>(astronaut.description)</span><br><span class="line">                    .padding()</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        .background(.darkBackground)</span><br><span class="line">        .navigationTitle(astronaut.name)</span><br><span class="line">        .navigationBarTitleDisplayMode(.inline)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们需要再次更新预览，以便它使用一些数据创建视图：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">#<span class="type">Preview</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> astronauts: [<span class="type">String</span>: <span class="type">Astronaut</span>] <span class="operator">=</span> <span class="type">Bundle</span>.main.decode(<span class="string">&quot;astronauts.json&quot;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="type">AstronautView</span>(astronaut: astronauts[<span class="string">&quot;aldrin&quot;</span>]<span class="operator">!</span>)</span><br><span class="line">        .preferredColorScheme(.dark)</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>现在我们可以从 MissionView 内的 NavigationLink 来呈现它。现在它指向 Text(“Astronaut details”) ，但我们可以将其更新为指向新的 AstronautView ：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">AstronautView</span>(astronaut: crewMember.astronaut)</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>这很容易，对吧？但是，如果您现在运行该应用程序，您会发现它使我们的用户界面感觉多么自然 - 我们从最广泛的信息级别开始，显示我们的所有任务，然后点击以选择一项特定任务，然后点击以选择一名特定宇航员。 iOS 负责新视图中的动画，但也提供后退按钮和滑动以返回到以前的视图。</p>
<h1 id="最终效果图"><a href="#最终效果图" class="headerlink" title="最终效果图"></a>最终效果图</h1><p><img src="https://sageimg.oss-cn-shenzhen.aliyuncs.com/image/moonshot2.gif"></p>

        </div>

        <footer class="post-footer">
            <div class="post-nav">
                
                    <div class="post-nav-prev">
                        <span>上一篇</span>
                        <a href="/article/33439.html">【Hacking With Swift】Project9_Navigation</a>
                    </div>
                
                
                    <div class="post-nav-next">
                        <span>下一篇</span>
                        <a href="/article/16673.html">电脑自动重启的尝试解决办法记录</a>
                    </div>
                
            </div>
        </footer>

        
            <div class="post-comments">
                <h3 class="comments-title">评论</h3>
                <div id="waline"></div>
            </div>
        
    </article>
</div>


    <script type="module">
        import { init } from 'https://unpkg.com/@waline/client@v3/dist/waline.js';

        init({
            el: '#waline',
            serverURL: 'https://walinecomments.five2fire.top',
            dark: 'auto',
            lang: 'zh-CN',
            pageview: true,
            comment: true,
            emoji: ["https://unpkg.com/@waline/emojis@1.1.0/weibo","https://unpkg.com/@waline/emojis@1.1.0/bilibili"]
        });
    </script>
    <link rel="stylesheet" href="https://unpkg.com/@waline/client@v3/dist/waline.css" />


            </main>
        </div>
        
    </div>
    
<script src="/js/main.js"></script>

</body>
</html>

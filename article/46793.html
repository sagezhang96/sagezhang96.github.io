<!DOCTYPE html>
<html>
<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
    <title>Sage自留地😎</title>
    
<link rel="stylesheet" href="/css/style.css">

    <link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=JetBrains+Mono:wght@400;500;600&display=swap">
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.16.8/dist/katex.min.css">
<meta name="generator" content="Hexo 7.3.0"><link rel="alternate" href="/atom.xml" title="Sage自留地😎" type="application/atom+xml">
</head>
<body>
    <div class="container">
        <header class="header">
    <div class="site-title">
        <a href="/">Sage自留地😎</a>
    </div>
    <div class="nav-toggle">
        <span></span>
        <span></span>
        <span></span>
    </div>
    <nav class="nav">
        <ul class="nav-list">
            
                
                    <li class="nav-item">
                        <a href="/">首页</a>
                    </li>
                
            
                
                    <li class="nav-item has-children">
                        <a href="javascript:void(0);">文章</a>
                        <ul class="nav-submenu">
                            
                                <li class="nav-submenu-item">
                                    <a href="/archives">归档</a>
                                </li>
                            
                                <li class="nav-submenu-item">
                                    <a href="/categories">分类</a>
                                </li>
                            
                                <li class="nav-submenu-item">
                                    <a href="/tags">标签</a>
                                </li>
                            
                        </ul>
                    </li>
                
            
                
                    <li class="nav-item">
                        <a href="/about">关于</a>
                    </li>
                
            
        </ul>
    </nav>
</header>

        <div class="main-container">
            <main class="main-content">
                <article class="post-detail">
    <header class="post-header">
        <h1 class="post-title">【Hacking With Swift】project7_iExpense</h1>
        <div class="post-meta">
            <span class="post-date">
                2024-06-23
            </span>
            
                <span class="post-category">
                    <a class="category-link" href="/categories/%E6%8A%80%E6%9C%AF/">技术</a>
                </span>
            
            
                <span class="post-tags">
                    <a class="tag-none-link" href="/tags/Hacking-with-Swift/" rel="tag">Hacking with Swift</a> <a class="tag-none-link" href="/tags/Swift/" rel="tag">Swift</a> <a class="tag-none-link" href="/tags/%E7%BC%96%E7%A8%8B/" rel="tag">编程</a>
                </span>
            
        </div>
    </header>

    <div class="post-content">
        <p><em><strong><font color=red>英文原博博主是</font></strong></em>   <a target="_blank" rel="noopener" href="https://www.youtube.com/c/PaulHudson">Paul Hudson</a>    <i aria-hidden="true" class="fab fa-twitter" style="color: #4099ff"></i> <a href="https://twitter.com/twostraws" target="_blank">@twostraws</a></p>
<p><em><strong><font color=red>本文是学习Swift过程中翻译该网站的内容:</font></strong></em>   <a target="_blank" rel="noopener" href="https://www.hackingwithswift.com/">https://www.hackingwithswift.com/</a></p>
<h1 id="iExpense-电子记账"><a href="#iExpense-电子记账" class="headerlink" title="iExpense 电子记账"></a>iExpense 电子记账</h1><p>这个项目中我们仍然要完成一个小程序——iExpense，可以记录简单的账目。主要是学习如何显示另一个屏幕、如何跨屏幕共享数据、如何保存并加载用户数据。</p>
<p>我们将了解<code>@observable</code>、<code>sheet()</code>、<code>onDelete()</code>等等。</p>
<h2 id="iExpense简介"><a href="#iExpense简介" class="headerlink" title="iExpense简介"></a>iExpense简介</h2><p>接下来的两个项目将开始推动我们的 SwiftUI 技能超越基础知识，因为我们将探索具有多个屏幕、加载和保存用户数据以及具有更复杂用户界面的应用程序。</p>
<p>在这个项目中，我们将构建 iExpense，这是一个费用跟踪器，可将个人成本与业务成本分开。从本质上讲，这是一个带有表单（花了多少钱？）和列表（花费的金额）的应用程序，但为了完成这两件事，我们需要学习如何：</p>
<ul>
<li>显示和关闭第二个数据屏幕。</li>
<li>从列表中删除行</li>
<li>保存和加载用户数据</li>
<li>更多其他内容……</li>
</ul>
<p>有很多事情要做，所以让我们开始吧！</p>
<h2 id="在类中使用-state"><a href="#在类中使用-state" class="headerlink" title="在类中使用@state"></a>在类中使用@state</h2><p>前面我们学习到，<code>@state</code>属性包装器专为当前视图本地的简单数据而设计，但一旦您想要共享数据，您就需要采取一些重要的额外步骤。</p>
<p>先看下面这段代码，这是一个存储用户名字和姓氏的结构，我们现在可以在 SwiftUI 视图中使用它，方法是创建 @State 属性并将内容附加到 <code> $user.firstName</code> 和 <code>$user.lastName </code>。</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">User</span> &#123;</span><br><span class="line">    <span class="keyword">var</span> firstName <span class="operator">=</span> <span class="string">&quot;Bilbo&quot;</span></span><br><span class="line">    <span class="keyword">var</span> lastName <span class="operator">=</span> <span class="string">&quot;Baggins&quot;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">ContentView</span>: <span class="title class_">View</span> &#123;</span><br><span class="line">    <span class="meta">@State</span> <span class="keyword">private</span> <span class="keyword">var</span> user <span class="operator">=</span> <span class="type">User</span>()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> body: <span class="keyword">some</span> <span class="type">View</span> &#123;</span><br><span class="line">        <span class="type">VStack</span> &#123;</span><br><span class="line">            <span class="type">Text</span>(<span class="string">&quot;Your name is <span class="subst">\(user.firstName)</span> <span class="subst">\(user.lastName)</span>.&quot;</span>)</span><br><span class="line"></span><br><span class="line">            <span class="type">TextField</span>(<span class="string">&quot;First name&quot;</span>, text: <span class="variable">$user</span>.firstName)</span><br><span class="line">            <span class="type">TextField</span>(<span class="string">&quot;Last name&quot;</span>, text: <span class="variable">$user</span>.lastName)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这一切都有效：SwiftUI 足够智能，可以理解一个对象包含我们的所有数据，并且当任一值发生变化时都会更新 UI。在幕后，实际发生的情况是，每次结构体中的值更改时，整个结构体都会发生更改 - 就像每次我们键入一个新用户一样名字或姓氏的键。这听起来可能有点浪费，但实际上速度非常快。</p>
<p>之前我们研究了类和结构之间的差异，我提到了两个重要的差异。首先，结构总是有唯一的所有者，而对于类，多个事物可以指向相同的值。其次，该类在更改其属性的方法之前不需要<code>mutating</code>  关键字，因为您可以更改属性常量类。</p>
<p>实际上，这意味着，如果我们有两个 SwiftUI 视图，并且向它们发送相同的结构来使用，它们实际上每个都有该结构的唯一副本；如果一个人改变了它，另一个人将看不到这种变化。另一方面，如果我们创建 <code>class</code> 的实例并将其发送到两个视图，它们将&lt; &#x2F;span&gt; 分享更改。</p>
<p>对于 SwiftUI 开发人员来说，这意味着如果我们想要在多个视图之间共享数据 – 如果我们希望两个或多个视图指向相同的数据，以便当一个视图发生更改时，它们都会得到这些更改 – 我们需要使用类而不是结构。</p>
<p>因此，请将 User 结构更改为类。</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">User</span> &#123;</span><br><span class="line">    <span class="keyword">var</span> firstName <span class="operator">=</span> <span class="string">&quot;Bilbo&quot;</span></span><br><span class="line">    <span class="keyword">var</span> lastName <span class="operator">=</span> <span class="string">&quot;Baggins&quot;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>你会发现程序无法正常运行了。当然，我们可以像以前一样在文本字段中输入内容，但上面的文本视图不会改变。</p>
<p>当我们使用 @State 时，我们要求 SwiftUI 监视属性的更改。因此，如果我们更改字符串、翻转布尔值、添加到数组等，则属性已更改，SwiftUI 将重新调用视图的 body 属性。</p>
<p>当 User 是一个结构体时，每次我们修改该结构体的属性时，Swift 实际上都会创建该结构体的一个新实例。 @State 能够发现该更改，并自动重新加载我们的视图。现在我们有了一个类，这种行为就不再发生：Swift 可以直接修改值。</p>
<p>还记得我们如何使用 mutating 关键字来修改属性的结构体方法吗？这是因为，如果我们将结构体的属性创建为变量，但结构体本身是常量，则我们无法更改属性 - Swift 需要能够在属性更改时销毁并重新创建整个结构体，而这对于 Swift 来说是不可能的常量结构。类不需要mutating关键字，因为即使类实例被标记为常量，Swift仍然可以修改变量属性。</p>
<p>我知道这一切听起来都非常理论化，但这里有一个转折点：现在 User 是一个类，属性本身并没有改变，所以 @State没有注意到任何事情并且无法重新加载视图。是的，类内的值 正在发生变化，但 @State 不会监视这些值，所以实际上发生的情况是我们类中的值正在更改，但视图不会重新加载以反映该更改。</p>
<p>我们可以通过一个小改动来解决这个问题：在类前之前添加一行<code>@Observable</code>。</p>
<p>现在我们的代码将再次工作。要了解原因，让我们探索一下 @Observable 实际上做了什么……</p>
<h2 id="与-Observable-共享-SwiftUI-状态"><a href="#与-Observable-共享-SwiftUI-状态" class="headerlink" title="与 @Observable 共享 SwiftUI 状态"></a>与 @Observable 共享 SwiftUI 状态</h2><p>如果您将 @State 与结构一起使用，则当值更改时，您的 SwiftUI 视图将自动更新，但如果您将 @State 与类一起使用，则必须使用 <code>@Observable </code></p>
<p>我们详细地看一下这个代码</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Observable</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">User</span> &#123;</span><br><span class="line">    <span class="keyword">var</span> firstName <span class="operator">=</span> <span class="string">&quot;Bilbo&quot;</span></span><br><span class="line">    <span class="keyword">var</span> lastName <span class="operator">=</span> <span class="string">&quot;Baggins&quot;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>以 <code>@Observable</code> 开头，这告诉 SwiftUI 监视类中每个单独的属性的更改，并在属性发生更改时重新加载依赖于该属性的任何视图。实际上，Swift在背后为我们做了大量的工作：</p>
<p> <code>@Observable</code> 行是一个 宏，这是 Swift 悄悄重写我们的方法添加额外功能的代码。现在我们已经导入了它所来自的框架，Xcode 可以做一些非常巧妙的事情：如果您右键单击代码中的 <code>@Observable</code>，您可以选择 Expand Macro 来查看到底重写了什么正在发生 – Xcode 将向您显示正在生成的所有隐藏代码。</p>
<p>我不打算在这里写出整个宏扩展，因为它太多了，但我确实想指出三件事：</p>
<ol>
<li>我们的两个属性被标记为<code>@ObservationTracked</code>，这意味着 Swift 和 SwiftUI 正在监视它们的更改。</li>
<li>如果右键单击 <code>@ObservationTracked</code>，您也可以展开该宏 – 是的，它’ ;是宏中的宏。该宏的作用是跟踪任何属性的读取或写入，以便 SwiftUI 只能更新绝对需要刷新的视图。</li>
<li>我们的类符合<code>Observable</code> 协议。这很重要，因为 SwiftUI 的某些部分认为这意味着“可以监视此类的更改。”</li>
</ol>
<p>这三者都很重要，但最重要的是中间的一个：iOS 会跟踪每个从 <code>@Observed</code> 对象读取属性的 SwiftUI 视图，这样当属性更改时，它可以智能地更新依赖于它的所有视图，同时保持其他视图不变。</p>
<p>使用结构时，<code>@State</code> 属性包装器会保持值处于活动状态并监视它的更改。另一方面，当使用 类 时，<code>@State</code> 只是为了保持对象的活动状态 – 所有的变化都在监视更新视图由 <code>@Observable</code> 负责。</p>
<h2 id="显示和隐藏视图"><a href="#显示和隐藏视图" class="headerlink" title="显示和隐藏视图"></a>显示和隐藏视图</h2><p>在 SwiftUI 中显示视图的方式有多种，最基本的一种是工作表：在工作表之上呈现的新视图我们现有的。在 iOS 上，这会自动为我们提供一个类似卡片的演示，其中当前视图稍微滑向远处，新视图以动画方式显示在顶部。</p>
<p>工作表的工作方式与提醒非常相似，因为我们不会直接使用 <code>mySheet.present()</code> 或类似代码来呈现它们。相反，我们定义了应显示工作表的条件，当这些条件为 true 或 false 时，将分别显示或消除工作表。</p>
<p>让我们从一个简单的示例开始，该示例将使用工作表显示另一个视图的一个视图。首先，我们创建要在工作表中显示的视图，如下所示：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">SecondView</span>: <span class="title class_">View</span> &#123;</span><br><span class="line">    <span class="keyword">var</span> body: <span class="keyword">some</span> <span class="type">View</span> &#123;</span><br><span class="line">        <span class="type">Text</span>(<span class="string">&quot;Second View&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>接下来，创建初始视图，并通过一个按钮来调用上面这个视图：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">struct ContentView: View &#123;</span><br><span class="line">    @State private var showingSheet = false</span><br><span class="line"></span><br><span class="line">    var body: some View &#123;</span><br><span class="line">        Button(&quot;Show Sheet&quot;) &#123;</span><br><span class="line">            showingSheet.toggle()</span><br><span class="line">        &#125;</span><br><span class="line">        .sheet(isPresented: $showingSheet) &#123;</span><br><span class="line">            SecondView()</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果你现在运行该程序，你会看到你可以点击按钮让我们的第二个视图从底部向上滑动，然后你可以将其向下拖动以将其关闭。</p>
<p>我们也可以为第二个视图添加一些参数，并在初始视图中传入参数，比如添加一个名字。</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">SecondView</span>: <span class="title class_">View</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> name: <span class="type">String</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> body: <span class="keyword">some</span> <span class="type">View</span> &#123;</span><br><span class="line">        <span class="type">Text</span>(<span class="string">&quot;Hello, <span class="subst">\(name)</span>!&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">ContentView</span>: <span class="title class_">View</span> &#123;</span><br><span class="line">    <span class="meta">@State</span> <span class="keyword">private</span> <span class="keyword">var</span> showingSheet <span class="operator">=</span> <span class="literal">false</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> body: <span class="keyword">some</span> <span class="type">View</span> &#123;</span><br><span class="line">        <span class="type">Button</span>(<span class="string">&quot;Show Sheet&quot;</span>) &#123;</span><br><span class="line">            showingSheet.toggle()</span><br><span class="line">        &#125;</span><br><span class="line">        .sheet(isPresented: <span class="variable">$showingSheet</span>) &#123;</span><br><span class="line">            <span class="type">SecondView</span>(name: <span class="string">&quot;@twostraws&quot;</span>)</span><br><span class="line">        &#125;</span><br><span class="line">        .fullScreenCover(isPresented: <span class="variable">$showingSheet</span>, content: &#123;</span><br><span class="line">            <span class="type">SecondView</span>(name: <span class="string">&quot;Sage&quot;</span>)</span><br><span class="line">        &#125;)  <span class="comment">//如果想要全屏显示这个工作表可以用这个修饰符</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>现在工作表将显示“你好，@twostraws”。</p>
<p>接下来我们学习如何清除这个第二个视图（除了向下滑动关闭，我们可以通过编程来实现）。</p>
<p>我们需要另一个属性包装器<code>@Environment</code>，它允许我们创建存储外部提供给我们的值的属性。用户处于浅色模式还是深色模式？他们是否要求使用更小或更大的字体？他们在哪个时区？所有这些以及更多都是来自外部环境的值。</p>
<p>要尝试关闭第二个视图，请将此属性添加到 <code>SecondView</code>，这会根据环境中的值创建一个名为 <code>dismiss</code> 的属性：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Environment</span>(\.dismiss) <span class="keyword">var</span> dismiss</span><br></pre></td></tr></table></figure>

<p>现在用此按钮替换 SecondView 中的文本视图：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Button</span>(<span class="string">&quot;Dismiss&quot;</span>) &#123;</span><br><span class="line">    dismiss()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>点击该按钮后，您现在应该发现可以通过按下按钮来显示和隐藏工作表。</p>
<h2 id="使用-onDelete-删除项目"><a href="#使用-onDelete-删除项目" class="headerlink" title="使用 onDelete() 删除项目"></a>使用 onDelete() 删除项目</h2><p>SwiftUI 为我们提供了 onDelete() 修饰符，用于控制如何从集合中删除对象。实际上，这几乎专门与 List 和 ForEach 一起使用：我们创建使用 ForEach 显示的行列表，然后将 onDelete() 附加到该 ForEach 以便用户可以删除他们不需要的行。</p>
<p>首先，让我们构建一个可以使用的示例：一个显示数字的列表，每次点击按钮时都会出现一个新数字。</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">ContentView</span>: <span class="title class_">View</span> &#123;</span><br><span class="line">    <span class="meta">@State</span> <span class="keyword">private</span> <span class="keyword">var</span> numbers <span class="operator">=</span> [<span class="type">Int</span>]()</span><br><span class="line">    <span class="meta">@State</span> <span class="keyword">private</span> <span class="keyword">var</span> currentNumber <span class="operator">=</span> <span class="number">1</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> body: <span class="keyword">some</span> <span class="type">View</span> &#123;</span><br><span class="line">        <span class="type">VStack</span> &#123;</span><br><span class="line">            <span class="type">List</span> &#123;</span><br><span class="line">                <span class="type">ForEach</span>(numbers, id: \.<span class="keyword">self</span>) &#123;</span><br><span class="line">                    <span class="type">Text</span>(<span class="string">&quot;Row <span class="subst">\(<span class="variable">$0</span>)</span>&quot;</span>)</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="type">Button</span>(<span class="string">&quot;Add Number&quot;</span>) &#123;</span><br><span class="line">                numbers.append(currentNumber)</span><br><span class="line">                currentNumber <span class="operator">+=</span> <span class="number">1</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>经过前面学习，现在也可以不用<code>ForEach</code>来实现。</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">List</span>(numbers, id: \.<span class="keyword">self</span>) &#123;</span><br><span class="line">    <span class="type">Text</span>(<span class="string">&quot;Row <span class="subst">\(<span class="variable">$0</span>)</span>&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>但是在这一节中，我们要学习的<code>onDelete()</code>修饰符，仅存在于<code>ForEach</code>上，所以我们必须使用<code>ForEach</code>来构建这个列表。</p>
<p>接下来我们要实现一个接收 IndexSet 类型的单个参数的方法。这有点像一组整数，只不过它是经过排序的，并且它只是告诉我们 ForEach 中应删除的所有项目的位置。</p>
<p>因为我们的 ForEach 完全是从单个数组创建的，所以我们实际上可以将该索引集直接传递到我们的 numbers 数组 – 它有一个特殊的remove(atOffsets:) 接受索引集的方法。</p>
<p>最后，我们可以告诉 SwiftUI 在想要从 ForEach 中删除数据时调用该方法</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">ForEach</span>(numbers, id: \.<span class="keyword">self</span>) &#123;</span><br><span class="line">    <span class="type">Text</span>(<span class="string">&quot;Row <span class="subst">\(<span class="variable">$0</span>)</span>&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line">.onDelete(perform: removeRows)</span><br></pre></td></tr></table></figure>
<p>现在继续运行您的应用程序，然后添加一些数字。准备好后，从右向左滑动列表中的任意行，您应该会发现出现一个删除按钮。您可以点击它，也可以使用 iOS 的滑动删除功能，通过进一步滑动来删除。</p>
<p>考虑到这很容易，我认为结果非常好。但 SwiftUI 还有另一个技巧：我们可以在导航栏中添加一个“编辑&#x2F;完成”按钮，让用户更轻松地删除几行。</p>
<p>首先，将 VStack 包裹在 NavigationStack 中，然后将此修饰符添加到 VStack：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">.toolbar &#123;</span><br><span class="line">    <span class="type">EditButton</span>()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这实际上就是所需的一切 - 如果您运行该应用程序，您会看到可以添加一些数字，然后点击“编辑”开始删除这些行。准备好后，点击“完成”退出编辑模式。考虑到只需要很少的代码，还不错！</p>
<h2 id="使用-UserDefaults-存储用户设置"><a href="#使用-UserDefaults-存储用户设置" class="headerlink" title="使用 UserDefaults 存储用户设置"></a>使用 UserDefaults 存储用户设置</h2><p>多数用户几乎期望应用存储他们的数据，以便他们可以创建更多定制的体验，iOS 提供了几种读取和写入用户数据的方法。</p>
<p>存储少量数据的一种常见方法称为<code>UserDefaults</code>，它非常适合简单的用户偏好。 “少量”没有附加具体数字，但您在 <code>UserDefaults</code> 中存储的所有内容都会在您的应用启动时自动加载 - 如果您在其中存储大量内容，您的应用启动速度将会减慢。为了至少给您一个想法，您的目标应该是在其中存储不超过 512KB。</p>
<p><code>UserDefaults</code> 非常适合存储用户上次启动应用程序的时间、他们上次阅读的新闻报道或其他被动收集的信息等信息。更好的是，SwiftUI 通常可以将 <code>UserDefaults</code> 包装在一个名为 @AppStorage 的漂亮而简单的属性包装器中 - 它现在只支持功能的子集，但它确实可以有帮助。</p>
<p>聊够了——让我们看一些代码。这是一个带有按钮的视图，显示点击计数，以及每次点击按钮时计数的增量：</p>
<p>由于这显然是一个非常重要的应用程序，因此我们希望保存用户点击的次数，以便他们将来返回该应用程序时可以从上次中断的地方继续。</p>
<p>为了实现这一点，我们需要在按钮的操作闭包内写入UserDefaults。因此，请在 tapCount +&#x3D; 1 行之后添加以下内容：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">ContentView</span>: <span class="title class_">View</span> &#123;</span><br><span class="line">    <span class="meta">@State</span> <span class="keyword">private</span> <span class="keyword">var</span> tapCount <span class="operator">=</span> <span class="number">0</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> body: <span class="keyword">some</span> <span class="type">View</span> &#123;</span><br><span class="line">        <span class="type">Button</span>(<span class="string">&quot;Tap count: <span class="subst">\(tapCount)</span>&quot;</span>) &#123;</span><br><span class="line">            tapCount <span class="operator">+=</span> <span class="number">1</span></span><br><span class="line">            <span class="type">UserDefaults</span>.standard.set(tapCount, forKey: <span class="string">&quot;Tap&quot;</span>)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>仅在那一行代码中，您就可以看到三件事正在发生：</p>
<ol>
<li>我们需要使用UserDefaults.standard。这是附加到我们的应用程序的 UserDefaults 的内置实例，但在更高级的应用程序中，您可以创建自己的实例。例如，如果您想在多个应用扩展之间共享默认值，您可以创建自己的 UserDefaults 实例。</li>
<li>有一个set()方法可以接受任何类型的数据 - 整数、布尔值、字符串等等。</li>
<li>我们将一个字符串名称附加到该数据上，在我们的例子中它是键“Tap”。这个键区分大小写，就像常规的 Swift 字符串一样，这很重要 – 我们需要使用相同的键从 UserDefaults 中读回数据。</li>
</ol>
<p>说到读回数据，而不是从将 tapCount 设置为 0 开始，我们应该让它从 UserDefaults 读回值，如下所示：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@State</span> <span class="keyword">private</span> <span class="keyword">var</span> tapCount <span class="operator">=</span> <span class="type">UserDefaults</span>.standard.integer(forKey: <span class="string">&quot;Tap&quot;</span>)</span><br></pre></td></tr></table></figure>

<p>请注意它如何使用完全相同的键名称，这确保它读取相同的整数值。</p>
<p>继续尝试该应用程序，看看您的想法 - 您应该能够点击按钮几次，返回 Xcode，再次运行该应用程序，并准确地看到您离开时的数字。</p>
<p>有两件事你在代码中看不到，但都很重要。首先，如果我们没有设置“Tap”键会发生什么？应用程序第一次运行时就会出现这种情况，但正如您刚刚看到的那样，它工作正常 - 如果找不到密钥，它只会发回 0。</p>
<p>有时使用像 0 这样的默认值会很有帮助，但有时可能会令人困惑。例如，对于布尔值，如果 boolean(forKey:) 找不到您要求的密钥，您将返回 false，但该 false 是您自己设置的值，还是意味着根本没有值？</p>
<p>其次，iOS 需要一点时间将数据写入永久存储 - 才能将更改实际保存到设备中。他们不会立即写入更新，因为您可能会连续进行多次更新，因此他们会等待一段时间，然后立即写出所有更改。另一个数字我们不知道需要多长时间，但应该需要几秒钟。</p>
<p>因此，如果您点击按钮然后从 Xcode 快速重新启动应用程序，您会发现最近的点击计数未保存。曾经有一种方法可以强制立即写入更新，但此时它毫无价值 - 即使用户在做出选择后立即开始终止您的应用程序，您的默认数据也会立即写入，因此不会丢失任何内容。</p>
<p>现在，我提到 SwiftUI 提供了一个 <code>@AppStorage</code> 围绕 <code>UserDefaults</code> 的属性包装器，在像这样的简单情况下它确实很有帮助。它的作用是让我们有效地完全忽略 <code>UserDefaults</code>，只使用 <code>@AppStorage</code> 而不是 <code>@State</code>，如下所示：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">ContentView</span>: <span class="title class_">View</span> &#123;</span><br><span class="line">    <span class="meta">@AppStorage</span>(<span class="string">&quot;tapCount&quot;</span>) <span class="keyword">private</span> <span class="keyword">var</span> tapCount <span class="operator">=</span> <span class="number">0</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> body: <span class="keyword">some</span> <span class="type">View</span> &#123;</span><br><span class="line">        <span class="type">Button</span>(<span class="string">&quot;Tap count: <span class="subst">\(tapCount)</span>&quot;</span>) &#123;</span><br><span class="line">            tapCount <span class="operator">+=</span> <span class="number">1</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>再次，我想指出三件事：</p>
<ol>
<li>我们对UserDefaults系统的访问是通过@AppStorage属性包装器进行的。其工作原理类似于 @State：当值更改时，它将重新调用 body 属性，以便我们的 UI 反映新数据。</li>
<li>我们附加一个字符串名称，这是我们要存储数据的 UserDefaults 键。我使用了“tapCount”，但它可以是任何东西 - 它不需要与属性名称匹配。</li>
<li>属性的其余部分被声明为正常，包括提供默认值 0。如果内部没有保存现有值，则将使用该值。UserDefaults。</li>
</ol>
<p>显然使用<code>@AppStorage</code>  比 <code>UserDefaults</code> 更容易：它是一行代码而不是两行，而且这也意味着我们不必重复每次的键名。然而，目前至少 <code>@AppStorage</code> 并不能让存储复杂的对象（例如 Swift 结构）变得容易 - 也许是因为 Apple 希望我们记住，在其中存储大量数据是一个坏主意！</p>
<p>重要提示：当您向 App Store 提交应用时，Apple 会要求您告知他们为何使用 <code>UserDefaults</code>。没什么好担心的，他们只是想确保开发者不会尝试跨应用识别用户。这同样也适用于属性包装器<code>@AppStorage</code>。</p>
<h2 id="使用-Codable-归档-Swift-对象"><a href="#使用-Codable-归档-Swift-对象" class="headerlink" title="使用 Codable 归档 Swift 对象"></a>使用 Codable 归档 Swift 对象</h2><p><code>@AppStorage</code>  非常适合存储整数和布尔值等简单设置，但当涉及复杂数据（例如自定义 Swift 类型）时，我们需要做更多的工作。这是我们需要直接探索 UserDefaults 本身的地方，而不是通过 <code>@AppStorage</code>  属性包装器。</p>
<p>这是一个我们可以使用的简单User数据结构：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">User</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> firstName: <span class="type">String</span></span><br><span class="line">    <span class="keyword">let</span> lastName: <span class="type">String</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>它有两个字符串，但它们并不特殊 - 它们只是文本片段。对于整数（普通的旧数字）、布尔值（true 或 false）和 Double（普通的旧数字，只是其中有一个点）也是如此。即使是这些值的数组和字典也很容易想到：有一个字符串，然后是另一个字符串，然后是第三个字符串，依此类推。</p>
<p>在处理此类数据时，Swift 为我们提供了一个出色的协议，名为 Codable：专门用于归档的协议 和取消归档数据，这是“将对象转换为纯文本并再次转换回来”的一种奇特方式。</p>
<p>我们将在未来的项目中考虑更多Codable，但现在我们将使其尽可能简单：我们想要归档自定义类型因此我们可以将其放入 UserDefaults 中，然后当它从 中返回out 时将其取消存档5&gt;.UserDefaults</p>
<p>当使用仅具有简单属性（字符串、整数、布尔值、字符串数组等）的类型时，我们需要做的唯一一件事就是为支持归档和取消归档添加一致性Codable，像这样：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">User</span>: <span class="title class_">Codable</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> firstName: <span class="type">String</span></span><br><span class="line">    <span class="keyword">let</span> lastName: <span class="type">String</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Swift 会自动为我们生成一些代码，这些代码将根据需要为我们归档和取消归档 User 实例，但我们仍然需要告诉 Swift 何时归档以及如何处理数据。</p>
<p>这部分流程由名为 JSONEncoder 的新类型提供支持。它的工作是获取符合 Codable 的内容并以 JavaScript 对象表示法 (JSON) 发回该对象 - 名称暗示它特定于 JavaScript，但在实践中我们都使用它，因为它太快了而且简单。</p>
<p>Codable 协议不要求我们使用 JSON，事实上其他格式也是可用的，但它是迄今为止最常见的格式。在这种情况下，我们实际上并不关心使用什么类型的数据，因为它只是存储在UserDefaults.</p>
<p>要将 user 数据转换为 JSON 数据，我们需要调用 上的 encode() 方法。这可能会引发错误，因此应该使用 或 调用它以巧妙地处理错误。例如，如果我们有一个属性来存储 实例，如下所示：JSONEncodertrytry?User</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@State</span> <span class="keyword">private</span> <span class="keyword">var</span> user <span class="operator">=</span> <span class="type">User</span>(firstName: <span class="string">&quot;Taylor&quot;</span>, lastName: <span class="string">&quot;Swift&quot;</span>)</span><br></pre></td></tr></table></figure>

<p>然后我们可以创建一个按钮来存档用户并将其保存到UserDefaults，如下所示：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Button</span>(<span class="string">&quot;Save User&quot;</span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> encoder <span class="operator">=</span> <span class="type">JSONEncoder</span>()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">let</span> data <span class="operator">=</span> <span class="keyword">try?</span> encoder.encode(user) &#123;</span><br><span class="line">        <span class="type">UserDefaults</span>.standard.set(data, forKey: <span class="string">&quot;UserData&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>直接访问 UserDefaults 而不是通过<code>@AppStorage</code> ，因为 <code>@AppStorage</code> 属性包装器在这里不起作用.</p>
<p>该data常量是一种新的数据类型，其名称可能会令人困惑，Data。它旨在存储您能想到的任何类型的数据，例如字符串、图像、zip 文件等。不过，在这里，我们所关心的是它是我们可以直接写入UserDefaults的数据类型之一。</p>
<p>当我们以另一种方式返回时 - 当我们有 JSON 数据并且希望将其转换为 Swift Codable 类型时 - 我们应该使用 JSONDecoder 而不是 JSONEncoder()，但过程大致相同。</p>
<p>项目概述到此结束，因此请继续将您的项目重置为初始状态，准备好进行构建。</p>

    </div>

    <footer class="post-footer">
        <div class="post-nav">
            
                <div class="post-nav-prev">
                    <span>上一篇</span>
                    <a href="/article/16673.html">电脑自动重启的尝试解决办法记录</a>
                </div>
            
            
                <div class="post-nav-next">
                    <span>下一篇</span>
                    <a href="/article/57245.html">【Hacking With Swift】project6_Animation</a>
                </div>
            
        </div>
    </footer>

    
        <div class="post-comments">
            <h3 class="comments-title">评论</h3>
            <div id="waline"></div>
        </div>
    
</article>


    <script type="module">
        import { init } from 'https://unpkg.com/@waline/client@v3/dist/waline.js';

        init({
            el: '#waline',
            serverURL: 'https://walinecomments.five2fire.top',
            dark: '',
            lang: 'zh-CN',
            pageview: true,
            comment: true,
            emoji: ["https://cdn.jsdelivr.net/gh/walinejs/emojis@1.0.0/bilibili","https://cdn.jsdelivr.net/gh/walinejs/emojis/weibo"]
        });
    </script>
    <link rel="stylesheet" href="https://unpkg.com/@waline/client@v3/dist/waline.css" />



            </main>
        </div>
        
    </div>
    
<script src="/js/main.js"></script>

    <script defer src="https://cdn.jsdelivr.net/npm/katex@0.16.8/dist/katex.min.js"></script>
    <script defer src="https://cdn.jsdelivr.net/npm/katex@0.16.8/dist/contrib/auto-render.min.js" onload="renderMathInElement(document.body);"></script>
</body>
</html>

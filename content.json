{"meta":{"title":"Sage自留地😎","subtitle":"","description":"","author":"SageZhang","url":"https://blog.five2fire.top","root":"/"},"pages":[{"title":"404 Not Found：该页无法显示","date":"2025-01-02T02:17:10.806Z","updated":"2025-01-02T02:17:10.806Z","comments":false,"path":"/404.html","permalink":"https://blog.five2fire.top/404.html","excerpt":"","text":""},{"title":"关于","date":"2025-01-02T02:17:10.827Z","updated":"2025-01-02T02:17:10.827Z","comments":true,"path":"about/index.html","permalink":"https://blog.five2fire.top/about/index.html","excerpt":"","text":"施工保留地……"},{"title":"分类","date":"2025-01-02T02:17:10.828Z","updated":"2025-01-02T02:17:10.828Z","comments":false,"path":"categories/index.html","permalink":"https://blog.five2fire.top/categories/index.html","excerpt":"","text":""},{"title":"友情链接","date":"2025-01-02T02:17:10.828Z","updated":"2025-01-02T02:17:10.828Z","comments":true,"path":"links/index.html","permalink":"https://blog.five2fire.top/links/index.html","excerpt":"","text":""},{"title":"书单","date":"2025-01-02T02:17:10.827Z","updated":"2025-01-02T02:17:10.827Z","comments":false,"path":"books/index.html","permalink":"https://blog.five2fire.top/books/index.html","excerpt":"","text":"施工保留地222……"},{"title":"","date":"2025-01-02T02:17:10.828Z","updated":"2025-01-02T02:17:10.828Z","comments":true,"path":"githubcalendar/index.js","permalink":"https://blog.five2fire.top/githubcalendar/index.js","excerpt":"","text":"var github_canlendar = (git_user, git_color) => { var git_githubapiurl = \"https://python-github-calendar-api.vercel.app/api?\" + git_user; var git_fixed = 'fixed'; var git_px = 'px'; var git_month = ['一月', '二月', '三月', '四月', '五月', '六月', '七月', '八月', '九月', '十月', '十一月', '十二月']; var git_monthchange = []; var git_oneyearbeforeday = ''; var git_thisday = ''; var git_amonthago = ''; var git_aweekago = ''; var git_weekdatacore = 0; var git_datacore = 0; var git_total = 0; var git_datadate = ''; var git_git_data = []; var git_positionplusdata = []; var git_firstweek = []; var git_lastweek = []; var git_beforeweek = []; var git_thisweekdatacore = 0; var git_mounthbeforeday = 0; var git_mounthfirstindex = 0; var git_crispedges = 'crispedges'; var git_thisdayindex = 0; var git_amonthagoindex = 0; var git_amonthagoweek = []; var git_firstdate = []; var git_first2date = []; var git_montharrbefore = []; var git_monthindex = 0; var retinaCanvas = (canvas, context, ratio) => { if (ratio > 1) { var canvasWidth = canvas.width; var canvasHeight = canvas.height; canvas.width = canvasWidth * ratio; canvas.height = canvasHeight * ratio; canvas.style.width = '100%'; canvas.style.height = canvasHeight + 'px'; context.scale(ratio, ratio); } }; function responsiveChart() { var ratio = window.devicePixelRatio || 1 var git_tooltip_container = document.getElementById('git_tooltip_container'); var git_x = ''; var git_y = ''; var git_span1 = ''; var git_span2 = ''; var c = document.getElementById(\"gitcanvas\"); c.style.width = '100%'; c.style.height = ''; var cmessage = document.getElementById(\"gitmessage\"); var ctx = c.getContext(\"2d\"); width = c.width = document.getElementById(\"gitcalendarcanvasbox\").offsetWidth; height = c.height = 9 * 0.96 * c.width / git_data.length; retinaCanvas(c,ctx, ratio) var linemaxwitdh = height/ 9; var lineminwitdh = 0.8 * linemaxwitdh; var setposition = {x: 0.02 * width, y: 0.025 * width}; for (var week in git_data) { weekdata = git_data[week]; for (var day in weekdata) { var dataitem = {date: \"\", count: \"\", x: 0, y: 0}; git_positionplusdata.push(dataitem); ctx.fillStyle = git_thiscolor(git_color, weekdata[day].count); setposition.y = Math.round(setposition.y * 100) / 100; dataitem.date = weekdata[day].date; dataitem.count = weekdata[day].count; dataitem.x = setposition.x; dataitem.y = setposition.y; ctx.fillRect(setposition.x, setposition.y, lineminwitdh, lineminwitdh); setposition.y = setposition.y + linemaxwitdh } setposition.y = 0.025 * width; setposition.x = setposition.x + linemaxwitdh } if (document.body.clientWidth > 700) { ctx.font = \"600 Arial\"; ctx.fillStyle = '#aaa'; ctx.fillText(\"日\", 0, 1.9 * linemaxwitdh); ctx.fillText(\"二\", 0, 3.9 * linemaxwitdh); ctx.fillText(\"四\", 0, 5.9 * linemaxwitdh); ctx.fillText(\"六\", 0, 7.9 * linemaxwitdh); var monthindexlist = width / 24; for (var index in git_monthchange) { ctx.fillText(git_monthchange[index], monthindexlist, 0.7 * linemaxwitdh); monthindexlist = monthindexlist + width / 12 } } c.onmousemove = function (event) { if (document.querySelector('.gitmessage')) { git_tooltip_container.innerHTML = \"\" } getMousePos(c, event) }; git_tooltip_container.onmousemove = function (event) { if (document.querySelector('.gitmessage')) { git_tooltip_container.innerHTML = \"\" } }; function getMousePos(canvas, event) { var rect = canvas.getBoundingClientRect(); var x = event.clientX - rect.left * (canvas.width / rect.width); var y = event.clientY - rect.top * (canvas.height / rect.height); for (var item of git_positionplusdata) { var lenthx = x - item.x; var lenthy = y - item.y; if (0 < lenthx && lenthx < lineminwitdh) { if (0 < lenthy && lenthy < lineminwitdh) { git_span1 = item.date; git_span2 = item.count; git_x = event.clientX - 100; git_y = event.clientY - 60; html = tooltip_html(git_x, git_y, git_span1, git_span2); append_div_gitcalendar(git_tooltip_container, html) } } } } } function addlastmonth() { if (git_thisdayindex === 0) { thisweekcore(52); thisweekcore(51); thisweekcore(50); thisweekcore(49); thisweekcore(48); git_thisweekdatacore += git_firstdate[6].count; git_amonthago = git_firstdate[6].date } else { thisweekcore(52); thisweekcore(51); thisweekcore(50); thisweekcore(49); thisweek2core(); git_amonthago = git_first2date[git_thisdayindex - 1].date } } function thisweek2core() { for (var i = git_thisdayindex - 1; i < git_first2date.length; i++) { git_thisweekdatacore += git_first2date[i].count } } function thisweekcore(index) { for (var item of git_data[index]) { git_thisweekdatacore += item.count } } function addlastweek() { for (var item of git_lastweek) { git_weekdatacore += item.count } } function addbeforeweek() { for (var i = git_thisdayindex; i < git_beforeweek.length; i++) { git_weekdatacore += git_beforeweek[i].count } } function addweek(data) { if (git_thisdayindex === 6) { git_aweekago = git_lastweek[0].date; addlastweek() } else { lastweek = data.contributions[51]; git_aweekago = lastweek[git_thisdayindex + 1].date; addlastweek(); addbeforeweek() } } fetch(git_githubapiurl).then(data => data.json()).then(data => { git_data = data.contributions; git_total = data.total; git_first2date = git_data[48]; git_firstdate = git_data[47]; git_firstweek = data.contributions[0]; git_lastweek = data.contributions[52]; git_beforeweek = data.contributions[51]; git_thisdayindex = git_lastweek.length - 1; git_thisday = git_lastweek[git_thisdayindex].date; git_oneyearbeforeday = git_firstweek[0].date; git_monthindex = git_thisday.substring(5, 7) * 1; git_montharrbefore = git_month.splice(git_monthindex, 12 - git_monthindex); git_monthchange = git_montharrbefore.concat(git_month); addweek(data); addlastmonth(); var html = github_main_box(git_monthchange, git_data, git_user, git_color, git_total, git_thisweekdatacore, git_weekdatacore, git_oneyearbeforeday, git_thisday, git_aweekago, git_amonthago); append_div_gitcalendar(github_container, html); if(document.getElementById('github_loading')){ document.getElementById('github_loading').remove()}; responsiveChart() }).catch(function (error) { console.log(error) }); window.addEventListener('resize', function () { if (document.getElementById('gitcanvas')) { responsiveChart() } }) window.addEventListener('scroll', function () { if (document.querySelector('.gitmessage')) { git_tooltip_container.innerHTML = \"\" } }) var git_thiscolor = (color, x) => { if (x === 0) { var i = parseInt(x / 2); return color[0] } else if (x < 2) { return color[1] } else if (x < 20) { var i = parseInt(x / 2); return color[i] } else { return color[9] } }; var tooltip_html = (x, y, span1, span2) => { var html = ''; html += '' + span1 + '&nbsp;' + span2 + ' 次上传'; return html }; var github_canvas_box = () => { var html = ' '; return html }; var github_info_box = (user, color) => { var html = ''; html += '数据来源 @' + user + 'Less More '; return html }; var github_main_box = (monthchange, git_data, user, color, total, thisweekdatacore, weekdatacore, oneyearbeforeday, thisday, aweekago, amonthago) => { var html = ''; var canvasbox = github_canvas_box(); var infobox = github_info_box(user, color); var style = github_main_style(); html += '' + canvasbox + '' + infobox + ''; html += '过去一年提交' + total + '' + oneyearbeforeday + '&nbsp;-&nbsp;' + thisday + '最近一月提交' + thisweekdatacore + '' + amonthago + '&nbsp;-&nbsp;' + thisday + '最近一周提交' + weekdatacore + '' + aweekago + '&nbsp;-&nbsp;' + thisday + '' + style; return html }; var github_main_style = () => { style = '#github_container{text-align:center;margin:0 auto;width:100%;display:flex;display:-webkit-flex;justify-content:center;align-items:center;flex-wrap:wrap;}.gitcalendar-graph text.wday,.gitcalendar-graph text.month{font-size:10px;fill:#aaa;}.contrib-legend{text-align:right;padding:0 14px 10px 0;display:inline-block;float:right;}.contrib-legend .legend{display:inline-block;list-style:none;margin:0 5px;position:relative;bottom:-1px;padding:0;}.contrib-legend .legend li{display:inline-block;width:10px;height:10px;}.text-small{font-size:12px;color:#767676;}.gitcalendar-graph{padding:15px 0 0;text-align:center;}.contrib-column{text-align:center;border-left:1px solid #ddd;border-top:1px solid #ddd;font-size:11px;}.contrib-column-first{border-left:0;}.table-column{padding:10px;display:table-cell;flex:1;vertical-align:top;}.contrib-number{font-weight:300;line-height:1.3em;font-size:24px;display:block;}.gitcalendar img.spinner{width:70px;margin-top:50px;min-height:70px;}.monospace{text-align:center;color:#000;font-family:monospace;}.monospace a{color:#1D75AB;text-decoration:none;}.contrib-footer{font-size:11px;padding:0 10px 12px;text-align:left;width:100%;box-sizing:border-box;height:26px;}.left.text-muted{float:left;margin-left:9px;color:#767676;}.left.text-muted a{color:#4078c0;text-decoration:none;}.left.text-muted a:hover,.monospace a:hover{text-decoration:underline;}h2.f4.text-normal.mb-3{display:none;}.float-left.text-gray{float:left;}#user-activity-overview{display:none;}.day-tooltip{white-space:nowrap;position:absolute;z-index:99999;padding:10px;font-size:12px;color:#959da5;text-align:center;background:rgba(0,0,0,.85);border-radius:3px;display:none;pointer-events:none;}.day-tooltip strong{color:#dfe2e5;}.day-tooltip.is-visible{display:block;}.day-tooltip:after{position:absolute;bottom:-10px;left:50%;width:5px;height:5px;box-sizing:border-box;margin:0 0 0 -5px;content:\" \";border:5px solid transparent;border-top-color:rgba(0,0,0,.85)}.position-relative{width:100%;}@media screen and (max-width:650px){.contrib-column{display:none}}.angle-wrapper{z-index:9999;display:inline;width:200px;height:40px;position:relative;padding:5px 0;background:rgba(0,0,0,0.8);border-radius:8px;text-align:center;color:white;}.angle-box{position:fixed;padding:10px}.angle-wrapper span{padding-bottom:1em;}.angle-wrapper:before{content:\"\";width:0;height:0;border:10px solid transparent;border-top-color:rgba(0,0,0,0.8);position:absolute;left:47.5%;top:100%;}'; return style } }; var append_div_gitcalendar = (parent, text) => { if (typeof text === 'string') { var temp = document.createElement('div'); temp.innerHTML = text; var frag = document.createDocumentFragment(); while (temp.firstChild) { frag.appendChild(temp.firstChild) } parent.appendChild(frag) } else { parent.appendChild(text) } }; var loading_git = (color) => { loading = ''; return loading }; (function(){ var git_user = 'sagezhang96'; var github_container = document.getElementById('github_container'); var github_loading = document.getElementById('github_loading'); var git_purple = ['#ebedf0', '#fdcdec', '#fc9bd9', '#fa6ac5', '#f838b2', '#f5089f', '#c4067e', '#92055e', '#540336', '#48022f', '#30021f',]; var git_green = ['#ebedf0', '#f0fff4', '#dcffe4', '#bef5cb', '#85e89d', '#34d058', '#28a745', '#22863a', '#176f2c', '#165c26', '#144620']; var git_blue = ['#ebedf0', '#f1f8ff', '#dbedff', '#c8e1ff', '#79b8ff', '#2188ff', '#0366d6', '#005cc5', '#044289', '#032f62', '#05264c',]; var git_color = git_green; if (github_container) { append_div_gitcalendar(github_container, loading_git(git_color[4])); github_canlendar(git_user, git_color) } else { console.log('nonono'); } })()"},{"title":"Repositories","date":"2025-01-02T02:17:10.829Z","updated":"2025-01-02T02:17:10.829Z","comments":false,"path":"repository/index.html","permalink":"https://blog.five2fire.top/repository/index.html","excerpt":"","text":""},{"title":"标签","date":"2025-01-02T02:17:10.829Z","updated":"2025-01-02T02:17:10.829Z","comments":false,"path":"tags/index.html","permalink":"https://blog.five2fire.top/tags/index.html","excerpt":"","text":""},{"title":"留言板","date":"2025-01-02T02:17:10.829Z","updated":"2025-01-02T02:17:10.829Z","comments":true,"path":"messageboard/index.html","permalink":"https://blog.five2fire.top/messageboard/index.html","excerpt":"","text":"欢迎大家来留言 欢迎大家留言 有朋自远方来，不亦乐乎 留言板 常来的朋友注册一下用户留言，混个熟脸哦~ 还可以联系博主获取指定头衔！ .china-lines-main { padding: 0 20px; } .china-lines-main_title p { font-size: 1.75rem; } .china-lines-main_title, .china-lines-main_content { font-size: 1.25rem; font-family: '华文行楷' }"},{"title":"随感","date":"2025-01-02T06:37:26.171Z","updated":"2025-01-02T06:37:26.171Z","comments":true,"path":"thoughts/index.html","permalink":"https://blog.five2fire.top/thoughts/index.html","excerpt":"","text":"计划每周五更新一次该页面，敬请期待 2025年1月 2025-01-02 14:26:41 评论 今年开始记流水日记，这样知道每一天都是怎么被荒废的，也能看到是否是在一点一点进步。 2025年给自己定下的基调：努力自律，生活积极地向正轨靠拢，将自己的想法一一实现。 2025-01-01 03:25:31 评论 新的一年也要加油哦！ 2024年12月 2024-12-27 14:38:45 评论 脑海里突然蹦出这么个想法…… 就是为什么上班的工资比副业高那么多，副业赚了点就很高兴，上班很闲也不是很爽。当然也有很多其他因素，我就说突然想到的这一点。上班干多干少，都是那么点工资，尤其是老板把你一个人当三个人用的时候，完全体现不出多劳多得。但是副业吧…虽然也不是完全的多劳多得，但是获得感总是伴随收入一点点进来而增加的。综上…可能我当前是一个非常享受及时满足的人吧。 2024-12-18 14:35:59 评论 绝了，github两周多没更新过了，肉眼可见的无限懈怠！ 然而我觉得这两周和之前并没有什么不同。那到底是为什么没有更新呢？难道是生活已经平淡至极了？还是因为工作忙了？工作确实忙了，但是也还是拖着做。一个很大的不更新因素是因为不太好摸鱼了，之前都是肆无忌惮的摸鱼，现在有些畏手畏脚了。不过这也只是一个借口，因为博客也就是写写文，typora打开基本不会被发现摸鱼。最主要的，应该是IOS开发停滞住了，满足于一个demo就止步不前了。刚请了两天年假出去见了很多人，心情也变得不一样了。最近整理一下工作和生活的情绪，要恢复回来。 2024年11月 2024-11-15 01:37:57 评论 最近晚上回来和朋友玩Pico Park 2，下播后立马剪辑投稿。 执行力挺高，继续保持。视频在下面当你有了游戏，又有了朋友当你有了游戏，又有了朋友2 2024-11-12 13:50:54 评论 有时候觉得，一些小想法能够多说一点，但是写个文章又显得没太多必要。whatever，想写就写吧。 2024-11-08 09:47:25 评论 今天更新博客的时候，发现留言板迎来了第一个不认识的网友的留言！让我们热烈欢迎他！（当然也热烈欢迎认识的人） 2024-11-06 15:11:38 评论 这么好的天气却要上班，真是太可惜了呀。 2024-11-05 11:54:25 评论 看到了一个比较喜欢的简约Hexo主题，但是又缺少一些想要的功能。而且发现自己做一个Hexo主题没有想象中的简单，即使有AI的帮助，也还是很难。 Vivia 2024年10月 2024-10-28 16:18:06 评论 现在会后悔当初没有怎么怎么样？那未来会后悔现在没怎么样？ 没抢到2000往返日本的机票有感！ 2024-10-24 12:14:09 评论 有了目标之后，也确实少了很多迷茫、踌躇和焦虑。 2024-10-24 11:10:09 评论 上午完成了监督模式的开发，可以说基本能够按照我原本设想的交互，实现90%的功能了。 目前制定了一个简单的开发计划，希望能够赶在年底之前完成具有相对完整功能的APP，并完成上架。 不要感叹路途遥远，不要想着做好准备就能万无一失，放下完美主义，踏上西行之路。 2024-10-23 17:55:41 评论 今天使用cursor，利用下午4个小时时间，完成了一个习惯打卡APP的MVP版本的开发，全部代码都由AI生成。 新Claude3.5模型在编程方面确实很强，也很高兴，cursor能够在发布的第一时间就对接上新模型接口 与其感慨路难行，不如马上出发。午间休息的时候冒出了这个用AI做一个简单APP的想法，晚上就做好了MVP版本，略有成就感的同时也惊叹于技术的发展，未来基础程序员的工作完全可以由AI替代了。 以后AI继续发展，能力越来越强，人的价值将体现在何处呢？ 2024-10-21 09:23:51 评论 又开启新一周的打工了，昨晚发现之前副业搞的那个渠道又通了，很不错，但是接下来要思考一下副业的工作节奏问题。 昨天因为面基也没睡午觉，晚上特别特别困，但是和老婆聊了一下宇宙之后，突然脑子里接二连三冒出来一堆想法，搞得既困又睡不着。😪 2024-10-20 15:40:36 评论 和five群的小伙伴又面基了一次，昨天玩桌游今天KTV，现充现已充能完毕！😄😄 2024-10-18 10:34:37 评论 失望！ 2024-10-17 23:04:36 评论 从下班倒回来倒腾到现在，终于刷完openwrt也能走路由器代理了，然而这个代理不稳定，并且！！！SPM还是不行！！！😠😠😠太傻逼了吧！！！“万里长征”未出发就要倒下了！ 2024-10-16 15:31:41 评论 这GFW是真的烦啊，Xcode想用SPM装个三方库都得玄学看天。实在不行就得考虑从路由器端走代理了。 2024-10-15 14:09:35 评论 和朋友聊天，发现“内心想躺平但现实逼迫无法躺平”的情况让生活变得很累😩，感觉应该改变一下心态（因为无力改变现实😫）。 2024-10-15 11:47:48 评论 下单了新的SE，去线下取了货，结果发现和老款确实没啥区别！而且表带买成长的了不合适，只能退货了（居然不支持单独换表带😅）。 另外希望旧SE快点复活。🙏 2024-10-14 2024-10-15 20:13:30 评论 这两天没带Watch，除了偶尔会习惯性抬腕看时间外，倒是没什么不方便的。 日常使用的功能主要包括：震动闹铃，睡眠监测，中午吃饭微信支付，时刻关注时间（早上上班怕迟到），运动（主要是游泳，今年半年没游了，去年倒是游了一夏天）。 今天到家突然发现能接收到充满电的提示了，然后尝试自己把屏幕取下来的过程中突然发现屏幕有震动，原来是已经开机了但是屏幕不亮了。之前是完全开不了机，但是屏幕能亮。现在只能祈祷过几天水渍完全干了屏幕也能亮。🙏🙏🙏 2024-10-12 23:39:19 评论 😶无语了，晚上和老婆去游泳复健，结果Apple Watch进水了。现在也开不了机，无限白苹果了……怎么才两年防水性能就退化得这么厉害啊。 在考虑要不要买新的，不过新款的SE也并没有什么新功能。 2024-10-11 14:30:13 评论 近期在准备《拖延心理学》的读书笔记时发现了一些问题： 由于拖延，读书战线拉得很长，导致后面再读的时候已经忘了前面看的内容了。 只做高亮标记，不当时作笔记，事后再看会忘记当时的感受。 全部看完再做笔记，会让工作量看起来比较大，就《拖延心理学》这本书里给出的工具来说，也应该分解这项任务，改为每一章一个小总结比较好。 所以后面做笔记的时候，尽量把当下的思考也记录下来，并规定一个周期进行整理。决定看了某本书之后，就按照计划一口气看完。 2024-10-10 14:37:10 评论 我的玻璃心犯了，我觉得反正也没人看我的博客，我为什么要折腾还要写随感呢？😶 2024-10-09 17:05:11 评论 发现苹果是可以批量导出的，就是稍微有些麻烦，但已经满足需求了！ 2024-10-09 14:26:30 评论 苹果的图书APP支持epub且能同步笔记，但是不支持批量导出，真是让人头痛！Calibre能够同步笔记高亮并且能够批量导出，但是必须是在内容服务器才可以，然而内容服务器的阅读体验并不佳。而且本地的高亮笔记居然无法在内容服务器上显示，也很让人费解。 22024-10-09 08:28:34 评论 终于在深圳的早上感受到一丝丝的秋意了，出门吹来的是清凉的风。 2024-10-08 17:20:57 评论 一上班就浑身难受，一想到还要上那么久的班就感到绝望…… 2024-10-06 19:15:29 评论 回家跟朋友约玩等于给我来一次体外除颤，短效用处大，但回去之后还得自闭！ 2024-10-02 21:29:11 评论 不是，怎么一下子两天就过去了啊。果然应该多现充，才能感受不到时间的流逝。 2024年9月 2024-09-29 17:18:43 评论 也弄懂为啥改了一下文章名评论就消失了，原来是和原文链接绑定的。现在把老评论迁移到新页面了。 2024-09-29 16:20:17 评论 已经搞到单独页面了，并且更新了主页文章列表的卡片形式。 现在发现，想要实现一个东西并不需要所有都从头开始，在已有的轮子上修改能够更快地实现。 2024-09-28 13:10:30 评论 在思考一个问题，静态部署的话，多久部署一次呢？感觉现在博客没什么人看，可以先一周更新一次。 2024年9月26日 16:46:21 评论 后续计划把这个功能弄到单独的页面去，应该不难，之前就已经搞成功过另一个页面了。 由于是静态部署，所以可能也要加一个定时发布的功能，这就是后话了。总之现在已经实现了说说本地留档了！古德古德古德！ 2024年9月26日 16:28:33 评论 今天正式试用了cursor，并且用它实现了我好久之前就想实现的功能，那就是在博客中插入微博内容，并且可以快捷引用。（这段文字也是使用cursor自动补齐功能编辑的）。 从最开始的实现微博卡片，到集成已有的gallery模块，再到最终加入评论快捷引用，整个过程还是蛮顺利的，就是过程中遇到了一些问题，不过最终都解决了。（这也是生成的，原来在cursor看来还挺顺利？其实不是很顺利，一共大约花了两个半小时，可惜cursor这里查看不到第一条记录的询问时间。）撒花！"}],"posts":[{"title":"粤语学习笔记","slug":"粤语学习笔记","date":"2025-01-02T02:17:10.826Z","updated":"2025-01-02T02:17:10.826Z","comments":true,"path":"article/16060.html","permalink":"https://blog.five2fire.top/article/16060.html","excerpt":"","text":"粤语学习Duolingo学习笔记第一章在喝早茶时点餐和询问价格 # 粤语字 发音 普通话 1 豉汁排骨 si6zap1paai4gwat1 豉汁排骨 2 ~ haa1gaau2 虾饺 3 ~ coeng2fan2 肠粉 4 ~ siu1mak6 烧麦 5 ~ pou2nei2 普洱 6 ~ tit3gun3jam1 铁观音 7 平 peng4 便宜 8 乜嘢&#x2F;咩 mat1je5、me1 什么 9 呢個 ni1go3 这个 10 嗰個 go2go3 那个 11 边個 bin1go3 哪个&#x2F;谁 12 呢度 ni1dou6 这边&#x2F;这里 13 嗰度 go2dou6 那边&#x2F;那里 14 边度 bin1dou6 哪里&#x2F;哪边 15 行 hang4 走 16 搵 wan3 找 17 转右 zyun2jau6 右转 18 几 gei2 多少 19 唔该 m4goi1 不好意思、谢谢 20 弊 bai6 糟糕 21 廿 jaa6 二十 22 卅 saa1 三十 23 係 hai6 是 24 蚊 man1 元 25 点 dim2 怎么 26 得闲 dak1haan4 有空 27 电话 din6waa2 电话 28 冧巴（number） lam1baa2 号码 29 点称呼 dim2cing1fu1 怎么称呼 30 都 dou1 也 31 嘅 ge3 的 32 紧（放在动词后） gan2 正在 33 喺度（放在动词前，可与“紧”结合使用） hai2dou6 正在 34 你我佢 nei5ngo5keoi 你我他 35 老细 lou5sai3 老板 36 哋 dei6 们 37 定係 ding6hai6 还是 38 仲 zung6 还 39 微信群 mei4seon3kwan4 微信群 40 二维码 ji6wai4maa5 二维码 41 啱 ngaam1 刚刚 42 去 heoi3 去 43 几耐 gei2noi6 多久 44 地铁 dei6tit3 地铁 45 今日 gam3jat6 今天 46 行街 haang4gaai1 逛街 47 唔使客气 m4sai2haak3hei3 不用客气 48 由 jau4 从 49 咗 zo2 了 50 落车 lok6ce1 下车 51 点算 dim2syun3 怎么办 52 隔离 gaak3lei4 旁边 53 得閒 dakhaan 有空 Duolingo导出 粤语字 发音 普通话 你哋 [‘nei5’, None] 你们, 您们 定係 [‘ding6’, ‘hai6’] 还是 唔係 [None, ‘hai6’] 不是 叫 [‘giu3’] 叫, 点, 叫上 啱嚟 [None, None] 刚来 嘅 [None] 的 點稱呼 [‘dim2’, ‘cang3’, ‘fu1’] 怎么称呼 識 [‘sik1’] 认识, 结识 都 [‘dou1’] 也, 也是 蚊 [‘man1’] 元, [元&#x2F;块&#x2F;块钱], 蚊子 平 [‘ping4’] 便宜, 廉价, 低廉 廿 [‘nim6’] 二十, 20 幾錢 [‘gei1’, ‘cin4’] 多少钱, 什么价, 价格是多少, 几钱, 几多钱 十 [‘sap6’] 十 貴 [‘gwai3’] 贵 卅 [‘saa1’] 三十, 30 早晨 [‘zou2’, ‘san4’] 早上好, 早晨好, 上午好, 早安, 早 唔該 [None, ‘goi1’] 谢谢, 感谢, 多谢, 麻烦, 拜托, 劳驾 咩 [None] 什么, 啥, 哪一种, 哪种 鐵觀音 [‘tit3’, ‘gun1’, ‘jam1’] 铁观音 飲 [‘jam2’] 喝, 饮用 乜嘢 [None, None] 什么, 啥 蝦餃 [‘haa1’, ‘gaau2’] 虾饺 燒賣 [‘siu1’, ‘maai6’] 烧卖 腸粉 [‘coeng4’, ‘fan2’] 肠粉, 抽屉式肠粉 係 [‘hai6’] 是 呢個 [‘nei4’, ‘go3’] 这个 咪 [‘mei1’] 不要 過咗 [‘gwo3’, None] 过了 點算 [‘dim2’, ‘syun3’] 怎么办 落車 [‘laai6’, ‘ce1’] 下车 有排 [‘jau5’, ‘paai4’] 要很久 仲 [‘zung6’] 还 弊 [‘bai6’] 糟糕 到咗 [‘dou3’, None] 到了 唔使 [None, ‘si3’] 不用 幾遠 [‘gei1’, ‘jyun6’] 多远 直行 [‘zik6’, ‘hong4’] 直走 差唔多 [‘caa1’, None, ‘do1’] 差不多 喇 [‘laa3’] 啦 晒 [‘saai3’] 十分 搭的士 [‘daap3’, ‘dik1’, ‘si6’] 坐出租车 踹單車 [‘caai2’, ‘sim4’, ‘ce1’] 骑自行车 今日 [‘gam1’, ‘jat6’] 今天 行 [‘hong4’] 走 零 [‘ling4’] 多 幾耐 [‘gei1’, ‘noi6’] 多久 行街 [‘hong4’, ‘gaai1’] 逛街 地鐵站 [‘dei6’, ‘tit3’, ‘zaam6’] 地铁站 唔知 [None, ‘zi1’] 不知道 點行 [‘dim2’, ‘hong4’] 怎么走 唔喺 [None, None] 不在 唔好意思 [None, ‘hou3’, ‘ji3’, ‘si1’] 不好意思, 抱歉, 对不起, 请见谅 售票處 [‘sau6’, ‘piu3’, ‘cyu5’] 售票处 巴士站 [‘baa1’, ‘si6’, ‘zaam6’] 公交车站 餐廳 [‘caan1’, ‘teng1’] 餐厅 充電寶 [‘cung1’, ‘din6’, ‘bou2’] 充电宝 呢度 [‘nei4’, ‘dok6’] 这里, 这儿, 这边 服務台 [‘fuk6’, ‘mou6’, ‘toi4’] 服务台 銀行 [‘ngan4’, ‘hong4’] 银行 冇 [None] 没有 邊度 [‘bin1’, ‘dok6’] 哪里, 哪儿 喺 [None] 在 廁所 [‘ci3’, ‘so2’] 厕所 嗰度 [None, ‘dok6’] 那里, 那儿, 那边 電梯 [‘din6’, ‘tai1’] 扶梯 學緊 [‘hok6’, ‘gan2’] 正在学 傾緊電話 [‘king1’, ‘gan2’, ‘din6’, ‘waa2’] 正在打电话 老細 [‘lou5’, ‘sai3’] 老板, 上司, 领导 佢 [None] 他, 她, 它 嗰位 [None, ‘wai6’] 那位 邊位 [‘bin1’, ‘wai6’] 哪位, 谁 呢位 [‘nei4’, ‘wai6’] 这位 冧把 [None, ‘baa2’] 号码, 号 得閒 [‘dak1’, ‘haan4’] 有空, 有时间 掃 [‘sou3’] 扫 我哋 [‘ngo5’, None] 我们, 咱们 抵 [‘dai2’] 划算 咁 [None] 这么 濕濕碎 [‘sap1’, ‘sap1’, ‘seoi3’] 小意思 啫 [None] 而已 有米 [‘jau5’, ‘mai5’] 有钱 麻麻哋 [‘maa4’, ‘maa4’, None] 一般般 犀利 [‘sai1’, ‘lei6’] 厉害 叻 [None] 聪明 靚 [‘leng3’] 美 講得 [‘gong2’, ‘dak1’] 说得 㗎 [None] 的呀 幾大 [‘gei2’, ‘daai6’] 多大 白話 [‘baak6’, ‘waa6’] 粤语 因為 [‘jan1’, ‘wai6’] 因为 嚟 [None] 来 食 [‘sik6’] 吃 凍 [‘dung3’] 冷 啲 [None] 这些, 把这些, 些, 那些, 点, 更, 一些 點解 [‘dim2’, ‘gaai2’] 为什么 拍拖 [‘paak3’, ‘to1’] 谈恋爱 掟煲 [None, None] 分手 嘈交 [‘cou4’, ‘gaau1’] 吵架 掟咗煲 [None, None, None] 分手了 細妹 [‘sai3’, ‘mui6’] 妹妹 阿哥 [‘o1’, ‘go1’] 哥哥 細佬 [‘sai3’, ‘lou2’] 弟弟 家姐 [‘gaa1’, ‘ze2’] 姐姐 邊個 [‘bin1’, ‘go3’] 谁 讀書 [‘duk6’, ‘syu1’] 上学 細路 [‘sai3’, ‘lou6’] 小孩 阿嫲 [‘o1’, None] 奶奶 阿婆 [‘o1’, ‘po4’] 外婆 阿爺 [‘o1’, ‘je4’] 爷爷 阿公 [‘o1’, ‘gung1’] 外公 同 [‘tung4’] 和 做嘢 [‘zou6’, None] 工作 而家 [‘ji4’, ‘gaa1’] 现在 相 [‘soeng3’] 照片 睇起嚟 [None, ‘hei2’, None] 看起来 呢 [‘nei4’] 这 後生 [‘hau6’, ‘sang1’] 年轻 阿爸 [‘o1’, ‘baa1’] 爸爸 阿媽 [‘o1’, ‘maa1’] 妈妈 嗰陣時 [None, ‘zan6’, ‘si4’] 那时候 喐 [None] 动 入面 [‘jap6’, ‘min6’] 里面 對面 [‘deoi3’, ‘min6’] 对面 搵唔到 [‘wan3’, None, ‘dou3’] 找不到 隔籬 [‘gaak3’, ‘lei4’] 旁边 企 [‘kei5’] 站","categories":[{"name":"学习","slug":"学习","permalink":"https://blog.five2fire.top/categories/%E5%AD%A6%E4%B9%A0/"}],"tags":[{"name":"粤语","slug":"粤语","permalink":"https://blog.five2fire.top/tags/%E7%B2%A4%E8%AF%AD/"}]},{"title":"2024年终总结","slug":"2024年终总结","date":"2024-12-23T09:26:36.000Z","updated":"2025-01-02T02:17:10.807Z","comments":true,"path":"article/9333.html","permalink":"https://blog.five2fire.top/article/9333.html","excerpt":"2024过去得好快，而我却还没长大。","text":"2024年终总结计划完成情况以下是年初制定的一些计划，整体情况如下表： 完成情况 目标 备注 ✖ 减肥10斤（目标130） 现在是136斤，根本没有行动 ✖ 完成一款IOSAPP的开发并上架 “律持”，Demo出后没动了 ✖ 10本书籍或课程5门 粗略估计读了4-5本书+积极心理学的课 ✖ 工资涨到***&#x2F;月 跳槽太难了，还变相扣工资了 ✖ 完成至少50篇博文 37篇，其中13篇是Swift文章翻译 ✖ 年底选出10涨自己满意的摄影作品 基本是随手拍，我也不选了 ✔ 粤语词汇量100 多邻国粤语快学完了 ✔ 领结婚证+人才房摇号 领证了🎉，房价下跌，基本不考虑人才房 ✔ 赚到第一笔工作之外的收入 Duolingo会员拼车赚了点小钱 ✔ 完成博客基本框架搭建 小改了点Bamboo主题，未来继续优化 下面具体针对每项说一说最终结果，明年的计划之后再制定。 减肥：3月份游泳把胳膊搞伤了之后就没怎么运动过，中间零星运动了几次，基本可以忽略。受伤是客观因素，也是主观借口。 不过第四季度开始已经有意识地控制饭量了，每顿饭饱腹感控制在70%-80%左右，多吃菜少吃饭，米饭摄入量减少至之前的一半。 IOS开发：上半年还执着于去年那个待办事项APP的想法，以及Swift的基础学习，后来了解到Cursor这个工具，发现编程效率大大提高，甚至不需要我去学习Swift基础知识了。 于是搞出了一个Markdown编辑器Demo，然后借助Duolingo打卡的灵感，迅速开发了一个习惯打卡APP，完成度上来说已经可以使用，但由于个人拖延原因，并没有上架。 读书和学习课程：今年开始恢复读书了，不过主要范围在工具书这类，期望是通过读书更好地掌控自己的生活。 目前来看效果不大，因为读完就忘了，但也在优化读书和做笔记的工作流。依旧是在PT上下载了很多自我提升的课程，但是基本都没看。 涨工资：这个说起来就比较操蛋了。毕业三年工资丝毫没涨，现在想跳槽但奈何又是年底，外加大环境极差，所以之前的预期也有所下降。公司还通过绩效制度变相降薪了，总之很难顶。 50篇博文目标：持续输出太难了，不过下半年才开始输出，以这个量和速度的话，当初制定的这个目标还是比较切实可行的。确实是自己太懒了，一周一篇的速度都完成不了。 摄影作品挑选：在上面3里提到下载了很多自我提升的课程，其中就有手机摄影。因为没有学习，所以拍摄技巧与之前没有大变化，但确实是有几张比较满意的照片，就不在这里献丑了。 粤语学习：Duolingo的课程还是太简单了，只适合入门。不过现在听粤语对话，具体场景下也能听懂20%—30%左右，说明学习还是有用的，再接再厉！ 领证+人才房摇号：感谢老婆的配合，让我完成了前者。人才房现在已经不太具有竞争力，除了景贤阁的学位，其余基本可以不考虑。 房价下跌致使我们能够买到00年上下的3房了，且朋友们都反映2房住几年必想置换，因此之后大概率只考虑3房。 工作之外收入：走向F.I.R.E的第一步，手动狗头[doge]。 博客搭建：其实只是借助AI完成了自己几个小想法，在已有的轮子上雕些花。 这一点上我的感触是：不要重复造轮子，弄清主次，不要流于形式忽视内容。 财务总结（截止12月20日）先说一下记账，目前主要记录的都是支出，上半年记录了很多收入，下半年由于设立了公共账户，收入记录停止，但由于有副业收入了，虽然不多，但也值得记录。明年需要更细致地记账。 今年的支出，不完全统计为12.6W，由于下半年租房计入公共账户了，因此这个支出不太具有代表性，扣除上半年统计的住房支出的话，一共支出8.5W。各款项如下： 饮食消费近2W，也就是月均1.8K的水平。 交通消费近2W，这一点我是没想到会这么多的，主要是来回机票，还有旅游的机票。 日常购物消费1.6W，数码3C消费1W，日用品5K左右，主要消费在618和双十一。 其他杂项消费在6K左右，没想到杂七杂八的能有这么多钱。 娱乐消费，除了蝴蝶刀6K，其余只有2K，我觉得是非常少了，得益于我玩的是免费游戏，所以这方面消费不多但也挺快乐。 服饰消费一共才2K+，算是比较少了吧，我很多衣服还是研究生时候的。 医疗花费1K，不知道是否计算了两次拍核磁的钱。 副业成本1K，销售额在4K上下，因此一共赚了3K多。 11月的时候结合公共账户调整了记账结构，因此上面的分析并不是很准确，也只有大类分析，明年将按照新记账结构继续记账，请期待明年的年末财务总结。（钱迹的自动记账赶快出吧！求求了，不然老有忘记记录的。） 工作生活总结上面两项是可量化的数据，生活工作学习中还有很多没有量化的（之所以这么说，是这些方面有的可以量化，但我还没有做），接下来总结一下。 如果说让我找出三个关键词来总结我的2024年，我觉得是顽固、上进、拧巴。 顽固俗话说得好，江山易改本性难移。 我在写这个年终总结的时候，无意中看到了23年的年终总结和24年的年中小结。结果发现，去年就有的坏习惯依然存在，一个计划拖了一年也没有完成，工作内容也一成不变。 养成一个好习惯都比较困难，想要样样都好更是难上加难。 这一点也可以总结为，呆在舒适区里没有走出来，整体处于一个躺平的心态。 上进虽然我是比较躺平的心态，但是还是想要做点什么来改变现状。 一方面可能确实上班太闲，不做点什么感觉时间全部白白浪费了。另一方面也确实心底还有一份冲劲，嘴上说着经历社会毒打认清现实承认自己的平凡，但谁说平凡就不可以上进了？ 还有就是觉得收入无法满足自己的欲望，所以要想办法开源，多赚些钱。 虽然不想上班，除了上班之外的收入也寥寥无几，但我坚信上班绝不是唯一的收入来源，只是大多数人的一个选择。所以我选择折腾，看能不能折腾出一条路子来。 拧巴把上面两个关键词结合起来，就是贯穿我一年的拧巴状态。 又想躺平，又想上进。 所以在犹犹豫豫中，又度过了一年，我还是那个拖延的我，没什么变化。 但又是那么不甘，不甘心就这么平平淡淡。而且现在的就业环境也不允许这么安逸，安逸的背后是随时失业得风险。 我确确实实意识到了自己处在这么个状态中，并且深恶痛绝。来年的主要目标就是摆脱这个关键词！ 游戏方面总结游戏占据了下班之后的大部分时间，所以我觉得今年有必要也总结一下。 年初一月底的时候，天梯出分万古，然后摆烂打着打着就到传奇一二了。绝大多数还是和朋友开黑玩加速，断断续续玩天梯也被ELO拿捏。 年底看到了一个利用ELO机制的视频，学习了一下之后发现果然有效，单排15把只输了3把。现在从传奇一飞速上升到了传奇四了。 这种明白规则再利用规则的想法对我很有启发，之前只觉得，天梯上不去分就是纯粹的不够强，且不谈ELO机制到底是不是合理，现在觉得，有些事情并不是努力就管用的。不过也可能打carry位和辅助位玩法确实不一样，如果玩carry位也用利用ELO机制，该如何打呢？这是个值得思考的问题。 CS就不单独总结了，说一说现在我对游戏的看法。 很多时候，游戏肯定就只是娱乐的一种方式，但是不管是DOTA还是CS，有的时候会又开摆的情况，对胜负无所谓，我觉得是一种不好的心态。没有了对胜负的追求，一局游戏也失去了很多乐趣，像是为了完成任务一样，浪费了时间又没有任何收获。 另外今年支持了一下国产3A，《黑神话悟空》是真好玩，是我买的第一个超100的游戏（甚至是超50的），也是努力打通关和白金的第一款游戏，甚至现在玩到了四周目了。 这种优质游戏带来的沉浸式游戏体验，我认为是“高质量娱乐”，就是积极向上的。而前面说的，不追求胜负，摆烂式玩游戏就是“低质量娱乐”，没有让自己放松，还失去了提高自己的时间。 展望2025没什么太多好说的，这篇年终总结写得也比2023年的认真。只希望明年写年终总结的时候，再看到这篇总结，不会有写这篇总结时候对自己的些许失望。 2025，思危、思退、思变。","categories":[{"name":"生活","slug":"生活","permalink":"https://blog.five2fire.top/categories/%E7%94%9F%E6%B4%BB/"}],"tags":[{"name":"反思","slug":"反思","permalink":"https://blog.five2fire.top/tags/%E5%8F%8D%E6%80%9D/"}]},{"title":"利用CloudFlare自建无服务器导航站","slug":"利用CloudFlare自建无服务器导航站","date":"2024-11-15T03:10:20.000Z","updated":"2025-01-02T02:17:10.824Z","comments":true,"path":"article/40210.html","permalink":"https://blog.five2fire.top/article/40210.html","excerpt":"","text":"利用CloudFlare自建无服务器导航站看到这两篇文章记录了利用CloudFlare自建无服务器导航站的过程，但是CloudFlare更新比较快，现在有些操作可能和教程中不太一样，所以这里我简单记录一下。 利用Cloudflare Worker是可以零成本部署个人导航的！ 如何利用Cloudflare Workers构建一个免费无服务器导航页 总的来说，现在更简单无脑了。 登录CloudFlare感谢CloudFlare，属实赛博菩萨！ 在Workers&amp;Pages创建Worker在CloudFlare的个人主页下，点击左侧导航栏中的Workers和Pages，然后选择概述。 然后直接点击创建Worker。 在新的页面内填入你想要的Worker名（这一步如果你有自己的域名，可以随便填，反正后面要设置自定义域名） 配置Worker在新的页面内点击编辑代码，使用下方代码替换 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219/** * 自定义网站配置 */const config = &#123; title: &quot;自定义导航&quot;, //write your website title subtitle: &quot;Cloudflare Workers Dir&quot;, //write your website subtitle logo_icon: &quot;sitemap&quot;, //select your logo by semantic-ui icon (you can get more msg in:https://semantic-ui.com/elements/icon.html) hitokoto: true, //use hitokoto or not search:true, //enable search function search_engine:[ //choose search engine which you use &#123; name:&quot;百 度&quot;, template:&quot;https://www.baidu.com/s?wd=$s&quot; &#125;, &#123; name:&quot;谷 歌&quot;, template:&quot;https://www.google.com/search?q=$s&quot; &#125;, &#123; name:&quot;必 应&quot;, template:&quot;https://www.bing.com/search?q=$s&quot; &#125;, &#123; name:&quot;搜 狗&quot;, template:&quot;https://www.sogou.com/web?query=$s&quot; &#125; ], selling_ads: true, //Selling your domain or not.(turning on may be helpful for selling this domain by showing some ads.) sell_info:&#123; domain:&quot;example.com&quot;, price:500, //domain price mon_unit:&quot;yen sign&quot;, //monetary unit contact:[ //how to contact you &#123; type:&quot;envelope&quot;, //contact type (&quot;weixin&quot;,&quot;qq&quot;,&quot;telegram plane&quot;,&quot;envelope&quot; or &quot;phone&quot;) content:&quot;info@example.com&quot; &#125; ] &#125;, lists: [ //Url list &#123; name:&quot;技术&quot;, icon:&quot;code&quot;, list:[ &#123; url:&quot;https://blog.fuyiran.link/&quot;, name:&quot;傅说&quot;, desc:&quot;领略世界的全新角度&quot; &#125;, &#123; url:&quot;https://nodeseek.com&quot;, name:&quot;Nodeseek&quot;, desc:&quot;高品质的主机爱好者社区&quot; &#125;, &#123; url:&quot;https://v2ex.com/&quot;, name:&quot;V2ex&quot;, desc:&quot;程序员集散地&quot; &#125;, &#123; url:&quot;https://github.com/&quot;, name:&quot;Github&quot;, desc:&quot;最大的同性交友平台&quot; &#125;, ] &#125;, &#123; name:&quot;学习&quot;, icon:&quot;graduation cap&quot;, list:[ &#123; url:&quot;https://w3school.com.cn/&quot;, name:&quot;W3school在线教程&quot;, desc:&quot;程序员集散地&quot; &#125;, &#123; url:&quot;https://runoob.com/&quot;, name:&quot;菜鸟教程&quot;, desc:&quot;程序员集散地&quot; &#125;, &#123; url:&quot;https://segmentfault.com/&quot;, name:&quot;思否社区&quot;, desc:&quot;程序员集散地&quot; &#125;, &#123; url:&quot;https://jianshu.com/&quot;, name:&quot;简书&quot;, desc:&quot;程序员集散地&quot; &#125;, ] &#125; ]&#125;const el = (tag, attrs, content) =&gt; `&lt;$&#123;tag&#125; $&#123;attrs.join(&quot; &quot;)&#125;&gt;$&#123;content&#125;&lt;/$&#123;tag&#125;&gt;`;async function handleRequest(request) &#123; const init = &#123; headers: &#123; &#x27;content-type&#x27;: &#x27;text/html;charset=UTF-8&#x27;, &#125;, &#125; return new Response(renderHTML(renderIndex(),config.selling_ads? renderSeller() :null), init);&#125;addEventListener(&#x27;fetch&#x27;, event =&gt; &#123; return event.respondWith(handleRequest(event.request))&#125;)/*通过分析链接 实时获取favicon* @url 需要分析的Url地址*/function getFavicon(url)&#123; if(url.match(/https&#123;0,1&#125;:\\/\\//))&#123; return &quot;https://ui-avatars.com/api/?bold=true&amp;size=36&amp;background=0D8ABC&amp;color=fff&amp;rounded=true&amp;name=&quot; + url.split(&#x27;//&#x27;)[1]; //return &quot;https://www.google.cn/s2/favicons?sz=64&amp;domain_url=&quot; + url; &#125;else&#123; return &quot;https://ui-avatars.com/api/?bold=true&amp;size=36&amp;background=0D8ABC&amp;color=fff&amp;rounded=true&amp;name=&quot; + url; //return &quot;https://www.google.cn/s2/favicons?sz=64&amp;domain_url=http://&quot; + url; &#125; &#125;/** Render Functions * 渲染模块函数 */function renderIndex()&#123; const footer = el(&#x27;footer&#x27;,[],el(&#x27;div&#x27;,[&#x27;class=&quot;footer&quot;&#x27;],&#x27;Powered by&#x27; + el(&#x27;a&#x27;,[&#x27;class=&quot;ui label&quot;&#x27;,&#x27;href=&quot;https://github.com/sleepwood/cf-worker-dir&quot;&#x27;,&#x27;target=&quot;_blank&quot;&#x27;],el(&#x27;i&#x27;,[&#x27;class=&quot;github icon&quot;&#x27;],&quot;&quot;) + &#x27;Cf-Worker-Dir&#x27;) + &#x27; &amp;copy; Base on &#x27; + el(&#x27;a&#x27;,[&#x27;class=&quot;ui label&quot;&#x27;],el(&#x27;i&#x27;,[&#x27;class=&quot;balance scale icon&quot;&#x27;],&quot;&quot;) + &#x27;MIT License&#x27;))); return renderHeader() + renderMain() + footer;&#125;function renderHeader()&#123; const item = (template,name) =&gt; el(&#x27;a&#x27;,[&#x27;class=&quot;item&quot;&#x27;,`data-url=&quot;$&#123;template&#125;&quot;`],name); var nav = el(&#x27;div&#x27;,[&#x27;class=&quot;ui large secondary inverted menu&quot;&#x27;],el(&#x27;div&#x27;,[&#x27;class=&quot;item&quot;&#x27;],el(&#x27;p&#x27;,[&#x27;id=&quot;hitokoto&quot;&#x27;],&#x27;条条大路通罗马&#x27;))) var title = el(&#x27;h1&#x27;,[&#x27;class=&quot;ui inverted header&quot;&#x27;],el(&#x27;i&#x27;,[`class=&quot;$&#123;config.logo_icon&#125; icon&quot;`],&quot;&quot;) + el(&#x27;div&#x27;,[&#x27;class=&quot;content&quot;&#x27;],config.title + el(&#x27;div&#x27;,[&#x27;class=&quot;sub header&quot;&#x27;],config.subtitle))); var menu = el(&#x27;div&#x27;,[&#x27;id=&quot;sengine&quot;&#x27;,&#x27;class=&quot;ui bottom attached tabular inverted secondary menu&quot;&#x27;],el(&#x27;div&#x27;,[&#x27;class=&quot;header item&quot;&#x27;],&#x27; &#x27;) + config.search_engine.map((link,key) =&gt;&#123; if(key == 0)&#123; return el(&#x27;a&#x27;,[&#x27;class=&quot;active item&quot;&#x27;,`data-url=&quot;$&#123;link.template&#125;&quot;`],link.name); &#125;else&#123; return item(link.template,link.name); &#125; &#125;).join(&quot;&quot;)) var input = el(&#x27;div&#x27;,[&#x27;class=&quot;ui left corner labeled right icon fluid large input&quot;&#x27;],el(&#x27;div&#x27;,[&#x27;class=&quot;ui left corner label&quot;&#x27;],el(&#x27;img&#x27;,[&#x27;id=&quot;search-fav&quot;&#x27;,&#x27;class=&quot;left floated avatar ui image&quot;&#x27;,&#x27;src=&quot;https://www.baidu.com/favicon.ico&quot;&#x27;],&quot;&quot;)) + el(&#x27;input&#x27;,[&#x27;id=&quot;searchinput&quot;&#x27;,&#x27;type=&quot;search&quot;&#x27;,&#x27;placeholder=&quot;搜索你想要知道的……&quot;&#x27;,&#x27;autocomplete=&quot;off&quot;&#x27;],&quot;&quot;) + el(&#x27;i&#x27;,[&#x27;class=&quot;inverted circular search link icon&quot;&#x27;],&quot;&quot;)); return el(&#x27;header&#x27;,[],el(&#x27;div&#x27;,[&#x27;id=&quot;head&quot;&#x27;,&#x27;class=&quot;ui inverted vertical masthead center aligned segment&quot;&#x27;],(config.hitokoto ? el(&#x27;div&#x27;,[&#x27;id=&quot;nav&quot;&#x27;,&#x27;class=&quot;ui container&quot;&#x27;],nav) : &quot;&quot;) + el(&#x27;div&#x27;,[&#x27;id=&quot;title&quot;&#x27;,&#x27;class=&quot;ui text container&quot;&#x27;],title + (config.search ? input + menu :&quot;&quot;) + `$&#123;config.selling_ads ? &#x27;&lt;div&gt;&lt;a id=&quot;menubtn&quot; class=&quot;red ui icon inverted button&quot;&gt;&lt;i class=&quot;heart icon&quot;&gt;&lt;/i&gt; 喜欢此域名 &lt;/a&gt;&lt;/div&gt;&#x27; : &#x27;&#x27;&#125;`)))&#125;function renderMain() &#123; var main = config.lists.map((item) =&gt; &#123; const card = (url,name,desc)=&gt; el(&#x27;a&#x27;,[&#x27;class=&quot;card&quot;&#x27;,`href=$&#123;url&#125;`,&#x27;target=&quot;_blank&quot;&#x27;],el(&#x27;div&#x27;,[&#x27;class=&quot;content&quot;&#x27;],el(&#x27;img&#x27;,[&#x27;class=&quot;left floated avatar ui image&quot;&#x27;,`src=$&#123;getFavicon(url)&#125;`],&quot;&quot;) + el(&#x27;div&#x27;,[&#x27;class=&quot;header&quot;&#x27;],name) + el(&#x27;div&#x27;,[&#x27;class=&quot;meta&quot;&#x27;],desc))); const divider = el(&#x27;h4&#x27;,[&#x27;class=&quot;ui horizontal divider header&quot;&#x27;],el(&#x27;i&#x27;,[`class=&quot;$&#123;item.icon&#125; icon&quot;`],&quot;&quot;)+item.name); var content = el(&#x27;div&#x27;,[&#x27;class=&quot;ui four stackable cards&quot;&#x27;],item.list.map((link) =&gt;&#123; return card(link.url,link.name,link.desc); &#125;).join(&quot;&quot;)); return el(&#x27;div&#x27;,[&#x27;class=&quot;ui basic segment&quot;&#x27;],divider + content); &#125;).join(&quot;&quot;); return el(&#x27;main&#x27;,[],el(&#x27;div&#x27;,[&#x27;class=&quot;ui container&quot;&#x27;],main));&#125;function renderSeller() &#123; const item = (type,content) =&gt; el(&#x27;div&#x27;,[&#x27;class=&quot;item&quot;&#x27;],el(&#x27;i&#x27;,[`class=&quot;$&#123;type&#125; icon&quot;`],&quot;&quot;) + el(&#x27;div&#x27;,[&#x27;class=&quot;content&quot;&#x27;],content)); var title = el(&#x27;h1&#x27;,[&#x27;class=&quot;ui yellow dividing header&quot;&#x27;],el(&#x27;i&#x27;,[&#x27;class=&quot;gem outline icon&quot;&#x27;],&quot;&quot;) + el(&#x27;div&#x27;,[&#x27;class=&quot;content&quot;&#x27;],config.sell_info.domain + &#x27; 正在出售&#x27;)); var action = el(&#x27;div&#x27;,[&#x27;class=&quot;actions&quot;&#x27;],el(&#x27;div&#x27;,[&#x27;class=&quot;ui basic cancel inverted button&quot;&#x27;],el(&#x27;i&#x27;,[&#x27;class=&quot;reply icon&quot;&#x27;],&quot;&quot;) + &#x27;返回&#x27;)); var contact = config.sell_info.contact.map((list) =&gt; &#123; return item(list.type,list.content); &#125;).join(&quot;&quot;); var column = el(&#x27;div&#x27;,[&#x27;class=&quot;column&quot;&#x27;],el(&#x27;h3&#x27;,[&#x27;class=&quot;ui center aligned icon inverted header&quot;&#x27;],el(&#x27;i&#x27;,[&#x27;class=&quot;circular envelope open outline grey inverted icon&quot;&#x27;],&quot;&quot;) + &#x27;联系我&#x27;) + el(&#x27;div&#x27;,[&#x27;class=&quot;ui relaxed celled large list&quot;&#x27;],contact)); var price = el(&#x27;div&#x27;,[&#x27;class=&quot;column&quot;&#x27;],el(&#x27;div&#x27;,[&#x27;class=&quot;ui large yellow statistic&quot;&#x27;],el(&#x27;div&#x27;,[&#x27;class=&quot;value&quot;&#x27;],el(&#x27;i&#x27;,[`class=&quot;$&#123;config.sell_info.mon_unit&#125; icon&quot;`],&quot;&quot;) + config.sell_info.price))); var content = el(&#x27;div&#x27;,[&#x27;class=&quot;content&quot;&#x27;],el(&#x27;div&#x27;,[&#x27;class=&quot;ui basic segment&quot;&#x27;],el(&#x27;div&#x27;,[&#x27;class=&quot;ui two column stackable center aligned grid&quot;&#x27;],el(&#x27;div&#x27;,[&#x27;class=&quot;ui inverted vertical divider&quot;&#x27;],&#x27;感兴趣？&#x27;) + el(&#x27;div&#x27;,[&#x27;class=&quot;middle aligned row&quot;&#x27;],price + column)))); return el(&#x27;div&#x27;,[&#x27;id=&quot;seller&quot;&#x27;,&#x27;class=&quot;ui basic modal&quot;&#x27;],title + content + action);&#125;function renderHTML(index,seller) &#123; return `&lt;!DOCTYPE html&gt; &lt;html lang=&quot;en&quot;&gt; &lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt; &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;ie=edge&quot;&gt; &lt;title&gt;$&#123;config.title&#125; - $&#123;config.subtitle&#125;&lt;/title&gt; &lt;link href=&quot;https://cdn.jsdelivr.net/npm/semantic-ui-css@2.4.1/semantic.min.css&quot; rel=&quot;stylesheet&quot;&gt; &lt;link href=&quot;https://cdn.jsdelivr.net/gh/sleepwood/cf-worker-dir@0.1.1/style.css&quot; rel=&quot;stylesheet&quot;&gt; &lt;script src=&quot;https://cdn.jsdelivr.net/npm/jquery@3.4.1/dist/jquery.min.js&quot;&gt;&lt;/script&gt; &lt;script src=&quot;https://cdn.jsdelivr.net/npm/semantic-ui-css@2.4.1/semantic.min.js&quot;&gt;&lt;/script&gt; &lt;/head&gt; &lt;body&gt; $&#123;index&#125; $&#123;config.selling_ads ? seller : &#x27;&#x27;&#125; &lt;script src=&quot;https://v1.hitokoto.cn/?encode=js&amp;select=%23hitokoto&quot; defer&gt;&lt;/script&gt; &lt;script&gt; $(&#x27;#sengine a&#x27;).on(&#x27;click&#x27;, function (e) &#123; $(&#x27;#sengine a.active&#x27;).toggleClass(&#x27;active&#x27;); $(e.target).toggleClass(&#x27;active&#x27;); $(&#x27;#search-fav&#x27;).attr(&#x27;src&#x27;,$(e.target).data(&#x27;url&#x27;).match(`+/https&#123;0,1&#125;:\\/\\/\\S+\\//+`)[0] + &#x27;/favicon.ico&#x27;) ; &#125;); $(&#x27;.search&#x27;).on(&#x27;click&#x27;, function (e) &#123; var url = $(&#x27;#sengine a.active&#x27;).data(&#x27;url&#x27;); url = url.replace(`+/\\$s/+`,$(&#x27;#searchinput&#x27;).val()); window.open(url); &#125;); /* 鼠标聚焦时，回车事件 */ $(&quot;#searchinput&quot;).bind(&quot;keypress&quot;, function()&#123; if (event.keyCode == 13)&#123; // 触发需要调用的方法 $(&quot;.search&quot;).click(); &#125; &#125;); $(&#x27;#menubtn&#x27;).on(&#x27;click&#x27;, function (e) &#123; $(&#x27;#seller&#x27;).modal(&#x27;show&#x27;); &#125;); &lt;/script&gt; &lt;/body&gt; &lt;/html&gt;`&#125; 可以刷新一下在右侧看到预览效果，根据需要修改网站配置，点击部署即可。 配置自定义域名回到这个Worker的管理界面后按以下步骤设置即可，无需到DNS中添加规则 点击设置 在域和路由模块内点击添加 在弹框中选择自定义域 填入你的自定义域即可。（例如我的是links.five2fire.top） 点击添加域 访问现在你可以通过自定义域或worker默认域名访问该导航站了。","categories":[{"name":"技术","slug":"技术","permalink":"https://blog.five2fire.top/categories/%E6%8A%80%E6%9C%AF/"}],"tags":[{"name":"CloudFlare","slug":"CloudFlare","permalink":"https://blog.five2fire.top/tags/CloudFlare/"}]},{"title":"不要掉入完美主义的陷阱","slug":"不要掉入完美主义的陷阱","date":"2024-11-12T03:48:13.000Z","updated":"2025-01-02T02:17:10.823Z","comments":true,"path":"article/12599.html","permalink":"https://blog.five2fire.top/article/12599.html","excerpt":"你的完美主义，太彻底~","text":"不要掉入完美主义的陷阱最近在很多地方都遇到了完美主义这个词，之前还觉得，完美主义是一种比较积极的态度，现在发现完美主义实际上是一个陷阱。 什么是完美主义以下是来自Wiki百科的定义 完美主义（英语：perfectionism）在心理学中指一种不断追求快而准或基本准确的主义，追求完美的性格或主义，其往往伴随着自我否定和对他人评价的关注。 在我自己身上的一些典型性表现有： 做事之前喜欢先列一个十分详尽的计划表。 这个从我小学时候就有的习惯了。 每到寒假或者暑假，我就会制作一张《作息时间表》，上面列出了从早上起床到晚上睡觉的精确到分的时间。比如7：30起床，7：40洗漱，7：50吃早饭…… 想必你也已经猜到了，这些计划无一例外都没有被完全执行。你可以说是我缺乏执行力，但是，我们只回到制定详细计划这件事本身，里面就有完美主义在作祟。 制定计划的时候，你会在大脑中设想可能的情况，但“计划赶不上变化”，哪怕只有一点点变化，随之而来的连锁反应就能破坏整个计划。 更何况这里的“变化”往往就是因为计划本身导致心理上抗拒执行，由此形成恶性循环。 不论事情结果如何，事后往往会觉得还可以更好 追求好的结果当然是一件正确的事情，但我的心态常常陷入后悔或懊恼。 一个例子是当初自主招生的时候，差5分就能够过自招线，自招考试考的是数学和物理，而我只参加了数学竞赛而没有参加物理竞赛的学习。当时就想，但凡稍微学一点物理，都能过自招线了吧！ 还有一个例子是打DOTA2的时候，团战打完，哪怕是赢下了团战，也会想刚才哪里没有做好。 这其实涉及到的是复盘总结，但复盘总结是为了下一次更好，我有的似乎只是“意识到能做得更好”。 对身边的事物不满意，不安于现状 似乎“不安于现状”是个好词，具体表现在如经常对自己的服装或是居室布置感到不满意。 我就很喜欢尝试不断调整家具摆放，明明已经习惯现在的布置，但会因为一些细微的不方便，就想要折腾个大的。到最后发现还是原来的布置最合理，浪费了时间精力，却没有改变任何事情。 不放心别人做的事，而觉得必须亲力亲为才可以把一件事情做得让自己满意 这个例子就太多了，本身我也是一个喜欢DIY的工科男。但实际上术业有专攻，有的时候即使你不放心，也没有办法。 我也有在不满意之后，去尝试学习，自己来做。有时候会满意，有时候会发现确实自己能力有限。 不过我确实挺享受这种折腾的感觉。 如果你也有类似的经历或能够体现自己有完美主义倾向的案例，也欢迎在评论区分享。 完美主义的负面影响拖延（影响效率）让我意识到完美主义负面影响的，是《拖延心理学》这本书。里面讲到完美主义是拖延的一大因素。 拖延者常常害怕失败,担心自己的表现无法达到预期或他人的标准。这种恐惧导致他们不断推迟行动,以避免面对可能的失败和随之而来的自我否定。 完美主义是一个主要的拖延诱因。完美主义者往往设定不切实际的高标准,害怕无法达到这些标准而选择拖延。 具体可以见《拖延心理学》读书笔记。 焦虑（影响情绪）完美主义容易让人在做事前后陷入焦虑。还没有开始就觉得自己可能做不好，或是在计划执行过程中因为一点变化就担心影响最终结果，亦或是最终终于做成了一件事，又特别在意别人对这件事、对你的评价。 这会让人感到疲倦，因为毫无获得感，也就是正向反馈，久而久之就会落入负面情绪的循环之中。 人际关系（影响周围人）完美主义者如果是严于律己，宽以待人，那倒还好。但往往在不经意间，完美主义者会将自己的想法施加在周围人身上。 更严重的如星座学中的处女座（没错就是我），对别人要求严格，但允许自己犯错，简直不可理喻！ 当然我是不相信星座的。 而且如上面所说，完美主义会影响做事效率，这在协作工作中也会影响整体进度，破坏和他人的合作体验。 完美主义的正面影响看看我这篇文章的名字是啥，是不要掉入完美主义的陷阱！所以正面肯定就不说了。 但是正面影响肯定也有，不信你看完美主义的正面影响 哈哈~ 完美主义者也不要因此就放弃了追求完美，追求卓越的品质。 结语写这篇文章是因为看到了这个帖子。 我用Cursor1小时开发的App，上了AppStore排行榜Top20 里面提到的【先完成再完美】也是我最近同样在用Cursor开发APP的一点小感想。 我在一点一点地转变心态，也希望大家也能正确认识完美主义，不要掉入完美主义的陷阱。","categories":[{"name":"生活","slug":"生活","permalink":"https://blog.five2fire.top/categories/%E7%94%9F%E6%B4%BB/"}],"tags":[{"name":"心理学","slug":"心理学","permalink":"https://blog.five2fire.top/tags/%E5%BF%83%E7%90%86%E5%AD%A6/"}]},{"title":"《姥姥的外孙》影评","slug":"《姥姥的外孙》影评","date":"2024-11-07T09:58:21.000Z","updated":"2025-01-02T02:17:10.822Z","comments":true,"path":"article/4248.html","permalink":"https://blog.five2fire.top/article/4248.html","excerpt":"省流：我给的评分⭐⭐⭐6.8/10分","text":"《姥姥的外孙》影评❗❗❗前排提醒：本文涉及剧透，未观影者不可放心品尝！ 周末在家闲来无事，Mac里又提前下好了好多电影没有观看，就想看看电影。老婆提议看《姥姥的外孙》，是说口碑不错豆瓣评分也高，因此临时下载下来，把Mac又搬回客厅，在大电视上看。 电影内容（此部分为实打实的剧透）前期铺垫开头是一家人在行山祭祖，姥姥看到别的坟墓很大很阔气，说我要是死后也能住这样的“房子”就好了，闺女说，除非你也能有一百万。 到这里，结合影片的英文名《How to Make Millions Before Grandma Dies》，我还以为是一个外孙努力挣钱给姥姥买墓地的故事。 继续看下去。 外孙坐在坟上打电玩，撒花也漫不经心，姥姥批评他并且自己撒花，结果撒花的时候摔倒了，进医院一检查，查到了肠道癌晚期。 外孙阿安（我看的译文叫他M…那之后就叫他M好了）是个在家啃老的无业游民，整天打游戏还拿做直播诓他的妈妈。到这里我甚至还以为他会奋起图强赚钱给姥姥买墓地。 之后M去看望疾病在床的爷爷，看到堂妹无微不至地照顾爷爷，并在爷爷病逝后得到了他的遗产，于是M灵感大爆发，也想要通过照顾姥姥来获得她的房子。 这里要提一下，在堂妹初次出场时，电影给了一个M从背后偷看堂妹腰臀（堂妹穿着短裤和露脐装）的镜头。之后去堂妹家时，得知她也在Onlyfans（一家主要靠成人内容付费订阅制而闻名的平台）做兼职，堂妹还表示你要不要也关注我一下。 搬去和姥姥住前面说到M灵感大爆发，想要通过照顾姥姥来获得她的遗产。于是他先是破天荒地去看望姥姥，刚到那就拍了房子和周围的照片并挂到网上出售（之后才揭晓）。 年轻人和老人的观念和生活习惯都不同，M短暂的探望处处让姥姥不满意，一段时间后他向堂妹讨教，堂妹告诉他，什么时候你闻不到屋内的“老人味”了，才说明你真的融入了她的生活。 于是他决定搬去和姥姥同住。 陪姥姥去存钱，一起卖豆浆，和姥姥一起玩牌解闷儿……同时他也看到了姥姥在病痛折磨下，半夜大哭让她的爸爸妈妈“把我带走吧”。姥姥逐渐接纳外孙，并且确实感受到了快乐。 姥姥的家庭情况大儿子炒股赚了很多钱，家境优渥、二儿子在外欠了很多债、女儿在医院辛苦工作，又被儿子M啃老，生活很是艰难。得知姥姥得了癌症之后，大家第一反应不是关心姥姥，而是在互相推卸责任。 大儿子之后要把姥姥接去自己那住，为的也只是那一张房契。二儿子借探望之名，偷走姥姥多年的积蓄。女儿把工作调整成夜班，下了夜班之后带姥姥去泳池活动身子。 可以看出女儿在儿女里相对是最孝顺的。而外孙M，对妈妈没什么感情，照顾外婆也只是为了遗产。 姥姥的遗产分配姥姥提前安排好了自己的后事，把房子留给了二儿子，得知是弟弟最终得到了房子，曾经满脸真诚说着想尽孝、家境优渥的大儿子改口说这辈子不会再见她一眼。而女儿，是她执行了母亲的遗嘱，把大儿子支开，拿了房契给二儿子，好像这遗产从来和她无关。 姥姥还要花钱买墓地，她和外孙一起去自己的哥哥那里，先是温情怀旧，谈到钱后哥哥翻脸说你已经不是我们家的人了，并把她轰走，然而她们的父母癌症去世后，也是姥姥多加照顾。 这里其实和女儿的话照应上了——儿子继承家产，女儿继承癌症。 外孙M知道了姥姥把房子留给二舅之后也很气愤，责问姥姥为什么不是自己，之后就搬回妈妈那里，回归本性。 结局最后姥姥走了，M发现姥姥竟然还存了一百万留给他，因为小时候外婆就说，要为外孙存钱，那时候小外孙说要用存的钱给外婆买大房子。M回忆起这件事后，用这个钱给姥姥买了块大墓地，既是兑现了小时候的“承诺”，也实现了开头姥姥的愿望。 至此，电影结束。 个人评价评分：⭐⭐⭐6.8&#x2F;10分 本来是想给7.5分的，但这种电影每到结局，都会被我提前预判到，或狗血或励志或“正常的”反转，而这一部电影就是意料之中的反转。 说几个扣分的点： 偷看堂妹肉体的特写，Onlyfans兼职的侧写，给人偏离主线的感觉。首先你们是亲戚诶，虽然小时候在一起亲亲抱抱，但成年了还有非分之想可是乱伦啊！ 男主M表演得就像他真的和姥姥有很深的感情一样，明明他只是贪图姥姥的遗产。又或者是导演的安排？把一个祖孙关系搞得好像小年轻谈恋爱一样，总之观感很差，完全代入不了。（PS:听说男主演员是泰国一个卖腐组合里的1） 结尾尤其不能接受，也是扣分的最主要原因。我刚说完“要是姥姥给外孙留了一百万我就打6分”，他就真的来了 ！！！全片近90%的内容都是展现外孙想获得遗产，并不是出去对姥姥的爱来照顾。结尾就因为姥姥给他留了，就突然回忆起小时候，就强行呼应开头给姥姥买墓地了。我勒个去！！！最初看到姥姥说想住“大房子”我为什么想到的是外孙挣钱给他买啊！（虽然这也很俗套） 有几点能共情到的： 姥姥得知自己得了癌症时的反应并不像儿女们的反应那么大，然后还和自己的闺蜜一起交流病情。老人和青年人和刚成年不久的小孩，心态是不一样的。这里处理得比较细腻。 还有一个细腻的点是，姥姥晚上疼得受不了，大哭让爸爸妈妈给她带走。这个结合亲身经历，确实狠狠共情住了。老人对自己父母的思念，还有对老人的临终关怀，都是容易被忽略的点。 最后说一下片子里的女性主义： 堂妹的线也许是为了和M对比，女性自力更生，男的在家啃老。 女性更有同理心，能体贴入微照顾老人，男的只会图钱。 M妈妈那句“儿子继承家产，女儿继承癌症”，也是对男权社会的一个无声的反抗。 姥姥的哥哥说，你已经不姓X（忘记是什么姓了）了，意思就是你已经嫁出去了，已经是两家人了，也是一种认为女性要依附男性的思想。 总评珍惜身边人，用真心对待他们。","categories":[{"name":"书影音","slug":"书影音","permalink":"https://blog.five2fire.top/categories/%E4%B9%A6%E5%BD%B1%E9%9F%B3/"}],"tags":[{"name":"影评","slug":"影评","permalink":"https://blog.five2fire.top/tags/%E5%BD%B1%E8%AF%84/"}]},{"title":"近一年个人支出及家庭财务支出小结","slug":"支出总结(202304_202410)","date":"2024-11-01T09:08:52.000Z","updated":"2025-01-02T02:17:10.825Z","comments":true,"path":"article/24289.html","permalink":"https://blog.five2fire.top/article/24289.html","excerpt":"","text":"个人支出总结23年4月—24年6月这部分是单独个人记账，房租也计算在内了，为公共账户建立之前的所有个人款项，共15个月。总支出情况 住+行+食已经占比70%了，不过这里面的“行”包含了日本旅游的费用，这部分之后应该记录在公账里，人情来往里算上了钻戒。电器数码大头在运动相机+显卡+抽湿机，还有很多没有详细记录买了什么的。相机买回来之后并怎么用过，这提醒以后消费还是应该更理性一些，从自己的需求出发。 娱乐和购物方面占比比较少了，这样获得感比较少，不过个人还是比较低欲望的。但我现在的观念有些改变，消费确实一定程度上能够愉悦心情。 消费分类还是有不合理的地方，比如“食”项中细分了早餐中餐晚餐，应当统一记为一日三餐，另外有外出吃饭的“非通勤餐饮”也应该分别记录出来（这部分的一部分之后有公账记录，个人应酬部分应该算在个人账中。） 2024年7月—2024年10月惊不惊喜，意不意外？玩的支出了30%！其实是买了一个蝴蝶刀，5900元。这个其实算作是一个投资，因为CS饰品市场一直都是上涨的，去年4月份买了一个2300的蝴蝶刀，2400卖了，现在那把刀已经4000多了。截止此文总结的时刻，5900的蝴蝶刀也上涨到了6250元，这部分的支出和收入之后要考虑如何记账才能更清楚。 去掉房租之后可以看到，行+食+日常占比下降到了40%左右，而日常包括了双11购物，去掉蝴蝶刀的钱，整体算下来，生活必要开支还是在35%左右。占比虽小，并没有觉得生活质量有多好，娱乐活动还是比较少。 家庭公共账户支出总结各月支出情况 简单分析家庭固定支出： 房租：4300元 电费：250—350元波动（夏季开空调较多） 水费物业费：165元 这部分占家庭支出主要部分，在55%—65%之间。 食品消费7、8月较多，主要是外出改善伙食比较多，也可能是第一个月刚开始计算公账支出，所以共同点外卖的支出也算在里面，而9、10月份在家做饭较少，所以饮食支出都计算在个人账户中了，因此该项支出在这4个月内波动较大，不具有代表性，也无法做平均。 出行方面，主要包含一同打车出门的交通费以及国庆往返的机票高铁票，具有明显的季节性，7、8月较少，9、10月较多（与假期分布有关）。 除了这三大项消费之外，娱乐和其他类消费基本没有。9月其他类中包含了给老人的过节费和买东西的钱。而且并没有严格记账，所以这个分析也不是很准确。 总结之后，我现在觉得家庭公共支出的分类可以再细化一些，同时应该和个人支出的分类结合起来，这样有助于之后买房的时候，计算每个月的月供是否在家庭承受范围之内，来评估买房对生活质量的影响。 总结这是第一次对支出做了一次总结，之后应该定期做这样的总结，这样有助于了解自己的消费习惯，同时也能对家庭财务状况有一个更清晰的认识。尤其是计划在一年内买房，在这之前，要充分结合消费情况来评估买房带来的压力。 总结得很潦草，我觉得主要原因是因为记账还是记得比较乱。 记账这一年多的过程，有一些想法如下： 容易忘记记账，再回去翻记录不免会有遗漏 记账分类比较笼统，而且生活中支出确实很繁杂，没办法用简单几个分类全部概括出来 记账软件没有用好，没有充分利用软件的记账功能。之后如果推出自动记账可能会改善 记账软件只是辅助，要弄清记账的目的，但我现在还没有感受到记账带来的好处 只是单纯记账，没有设定预算，没有定期分析然后调整消费计划 接下来计划调整一下记账的分类策略，尝试把理财支出和收益加入进来，还有信用卡支付和还款情、副业的收入。并且要定期分析，设定预算，这样对自己的财务情况能够一个更准确的把握。","categories":[{"name":"生活","slug":"生活","permalink":"https://blog.five2fire.top/categories/%E7%94%9F%E6%B4%BB/"}],"tags":[{"name":"财务","slug":"财务","permalink":"https://blog.five2fire.top/tags/%E8%B4%A2%E5%8A%A1/"}]},{"title":"《拖延心理学》读书笔记","slug":"《拖延心理学》读书笔记","date":"2024-10-11T06:29:04.000Z","updated":"2025-01-02T02:17:10.823Z","comments":true,"path":"article/32835.html","permalink":"https://blog.five2fire.top/article/32835.html","excerpt":"本文为AI根据读书时做的摘要总结，非个人理解，仅供参考。","text":"《拖延心理学》-向与生俱来的行为顽症宣战前言本文为AI根据读书时做的摘要总结，非个人理解，仅供参考。之后有时间我会自己在做总结，敬请期待和关注。 1. 拖延的本质拖延并非简单的时间管理问题或道德缺陷,而是一个复杂的心理问题。它深深根植于我们的自尊和对自我的认知中。作者指出,拖延反映了一个人如何与自己相处,以及如何看待自己的能力和价值。拖延者常常害怕失败,担心自己的表现无法达到预期或他人的标准。这种恐惧导致他们不断推迟行动,以避免面对可能的失败和随之而来的自我否定。 我认为,理解拖延的心理根源是克服拖延的第一步。当我们意识到拖延不仅仅是懒惰或缺乏纪律,而是一种自我保护机制时,我们就能以更加同理心和建设性的方式来应对它。这种认识让我们能够更深入地探讨自己的恐惧和不安全感,从而找到更健康的方式来维护自尊和应对挑战。 2. 拖延的类型和原因书中详细探讨了几种常见的拖延类型及其背后的原因。完美主义是一个主要的拖延诱因。完美主义者往往设定不切实际的高标准,害怕无法达到这些标准而选择拖延。另一种类型是源于对控制感的需求,有些人通过拖延来维护自己的独立性和自主权。还有一些人可能因为害怕成功而拖延,因为成功可能带来更多的责任和期望。 我发现,识别自己属于哪种类型的拖延者非常有帮助。例如,作为一个倾向完美主义的人,我经常因为担心结果不够完美而推迟开始一项任务。认识到这一点后,我开始学习如何设定更现实的目标,并接受”足够好”的结果。这种自我认知不仅帮助我减少了拖延,还降低了日常生活中的压力和焦虑。 3. 认识自己的拖延模式作者建议我们仔细观察自己的拖延行为,包括触发因素、具体表现以及后果。通过分析我们不拖延的领域,我们可以发现自己的优势和有效策略。同时,识别我们常用的拖延借口和理由也很重要,这有助于我们在未来更好地应对这些想法。 在实践中,我发现保持一个”拖延日志”非常有效。每当我发现自己在拖延时,我会记录下当时的情况、我的想法和感受。经过一段时间,我开始看到一些模式,比如我常常在面对大型、复杂的项目时感到overwhelmed而拖延。认识到这一点后,我学会了将大项目分解成小任务,这大大减少了我的拖延行为。 4. 设定可操作的目标书中强调了设定具体、可衡量、可实现的小目标的重要性。将大目标分解为小步骤不仅让任务看起来不那么令人生畏,还能提供更多的成功体验,增强我们的信心和动力。作者建议从最小的可行目标开始,逐步提高难度。 我发现这个建议特别有用。以前我常常设定宏大但模糊的目标,结果往往是无从下手而拖延。现在我学会了设定”微小目标”,比如”写作10分钟”或”读一页书”。这些小目标很容易达成,给了我立即的成就感,often激发我继续工作的动力。同时,定期回顾和调整目标也很重要,这让我能够根据实际进展调整计划,保持目标的挑战性和可行性的平衡。 5. 时间管理技巧作者介绍了几种实用的时间管理技巧,其中”非计划”表格特别引起了我的注意。这种方法不仅帮助我们记录时间使用,还能让我们更清楚地看到可用于重要任务的时间。学会准确估计任务所需时间也是一个重要技能,这可以通过不断练习和记录来提高。 我尝试使用”非计划”表格一段时间后,惊讶地发现自己实际上比想象中有更多的可用时间。这个发现让我重新审视了自己的时间分配,开始更有意识地利用那些原本被忽视的时间段。同时,我也学会了更好地利用零碎时间,比如在等待时阅读几页书或处理一些小任务。找出自己的最佳工作时间并在这些时段安排重要任务,也显著提高了我的工作效率。 6. 克服拖延的策略书中提供了多种实用策略来克服拖延。预防和应对意外干扰是其中之一,这需要我们提前做好计划,并培养灵活应对变化的能力。学会委派任务不仅能减轻我们的负担,还能让我们专注于最重要的事情。对不重要的事情说”不”也是一个关键技能,这需要我们明确自己的优先事项。 我发现,建立良好的工作习惯和使用执行提示点特别有效。例如,我开始在办公桌上放置视觉提醒,如待办事项清单或项目时间表。这些提示不断提醒我保持专注和行动。同时,我也尝试养成即时处理小事的习惯,这不仅让我的工作空间更整洁,也减少了未完成任务积累带来的心理压力。 7. 寻求帮助和支持作者强调了社交支持在克服拖延中的重要性。找到能够理解和支持我们的人,公开承诺我们的目标,甚至找一个工作伙伴,都能增加我们坚持的动力。与他人一起制定计划也能带来新的视角和想法。 我个人发现,加入一个学习小组或找一个accountability partner极大地提高了我完成任务的概率。知道有人在关注我的进展,让我更有动力去行动。同时,我也学会了如何更好地寻求帮助,不再将其视为软弱的表现,而是看作提高效率和学习新技能的机会。 8. 调整生活方式书中提到,克服拖延不仅需要改变工作习惯,还需要全面调整生活方式。增加运动、练习正念、减少电子产品使用等都能帮助我们保持良好的精神状态,从而更好地应对拖延。培养新的兴趣爱好和与积极的人相处也能增加生活的乐趣和动力。 我开始每天进行短暂的冥想练习,这帮助我更好地管理压力和焦虑,也提高了我的注意力集中能力。同时,我也尝试限制社交媒体的使用时间,将这些时间用于更有意义的活动。这些改变虽然看似与拖延无关,但实际上对提高我的整体生活质量和工作效率产生了积极影响。 9. 应对他人的拖延最后,书中还讨论了如何应对他人的拖延,这对于管理者或与拖延者共事的人特别有用。关键是不要代替拖延者完成任务,而是帮助他们设定小目标,提供适度的鼓励。在必要时,我们也需要学会采取单方面行动来保护自己的利益。 这部分内容让我反思了自己作为团队成员或朋友时如何更好地支持他人。我学会了如何在不接管他人责任的前提下提供有效的帮助和支持。同时,我也认识到设定明确的界限的重要性,以确保他人的拖延不会对自己造成过大影响。 结语通过阅读《拖延心理学》,我深刻认识到克服拖延是一个长期的过程,需要我们从根本上改变思维模式和行为习惯。书中提供的各种策略和技巧为我们提供了实用的工具,但真正的改变还是需要我们持续的努力和实践。 我认为,克服拖延的关键在于自我认知和接纳。当我们能够以同理心和理解的态度看待自己的拖延行为时,我们就能更有效地应对它。同时,培养积极的心态,专注于进步而不是完美,也是克服拖延的重要一步。 最后,我想强调的是,改变是渐进的过程。我们不应期望一夜之间彻底改变自己的行为模式。相反,我们应该庆祝每一个小进步,保持耐心和毅力,相信通过持续的努力,我们终能建立更高效、更充实的生活方式。 《拖延心理学》高亮笔记部分先做摘录，再做整理。 人们通过拖延来安慰自己，让自己相信他们的能力要大于其表现，他们甚至还维护着这样一种信念：他们的潜在能力是出色的、不可限量的。通过拖延，你永远不会逼着自己去面对自己的能力限制在哪里。 拖延从根本上来说并不是一个时间管理方面的问题，也不是一个道德问题，而是一个复杂的心理问题。根本而言，拖延的问题是一个人跟自身如何相处的问题，它反映的是一个人在自尊上的问题。 阅读应对拖延的技巧或许是很有趣的一件事，但是阅读不能代替行动。 对自己可以用多少时间将事情做完没有一个概念 人们之所以产生拖延的不良习性，是因为他们害怕。他们害怕如果他们行动了，他们的行为会让他们陷入麻烦。他们担心如果展示了自己真实的一面，会有危险的结果等着他们。 他们的担忧反映了一种恐惧失败的心理。我们相信拖延可能是应付这种恐惧的一个心理策略。 成为一个伟大的律师就是我最大的追求。但是似乎我的时间都花在了担心自己能不能成就伟大上，而没有实实在在地去做事 不管能力是如何被定义的，当它成了一个人自我价值感的单一决定因素时，问题就产生了。这个人表现如何成了唯一的衡量；其他方面都被忽略了。一个出色的表现意味着一个出色的人；一个平庸的表现意味着一个平庸的人。这成了一个定论。 有些人宁愿承受拖延所带来的痛苦后果，也不愿意承受努力之后却没有如愿以偿所带来的羞辱。 然而，一个适应不良的完美主义者对自己要求也很高，但是却对自己不抱希望。在适应不良型的完美主义中，你对自己的要求跟你对自己表现的期待之间存在着一种矛盾，所以你更容易去自责，也更容易感到消沉，你的自尊因而也处于较低的水平。 一切都自己来。完美主义者常常觉得一切事情都应该自己来做，他们相信任何求助都是软弱的标志 即便求助于人会让事情做得更有效率，他们也毅然决然地在隔绝孤单中做事和受折磨，他们甚至以此为自豪。 完美主义者害怕一旦做出错误的决定，他们就会小看自己，而无法忍受到时候后悔自责的痛苦。 这些“选择失败”的人喜欢拖延，以至于他们可以让失败万无一失，同时他们还是可以幻想：要是我尝试，我一定能赢 很多完美主义者憎恨在竞争中失败，所以他们尽量避免参与到跟别人直接竞争的活动中。 “自残”是一种间接保护你的自我和自尊的方式：我失败了，但是这是我自愿的。 这种“要么全部要么没有”的观念会影响到一个人如何制定目标，会让他想要一下子做到所有事情，因为如果不这样的话，似乎总觉得不够 成长心态。这种心态的核心信念是：能力是可以发展的；通过努力工作，你可以随着时间推移而变得更聪明、更优秀。在成长心态看来，努力可以让你更聪明或者更擅长于某件事情；努力可以激发你的能力并成就自己。在这样的心态看来，你没有必要立刻擅长某件事情。事实上，做一些你不擅长的事情反而更为有趣，因为通过做这样的事情，你可以拓展你自己，并从中学习。有成长心态的人不仅仅追求挑战，他们还以此充实和提升自己。失败可能会让你伤心和失望，但是成败并不决定一个人本身的好坏。实际上，失败是一个让你加倍努力的理由，而不是一个让你退缩、放弃和拖延的理由。 下一次当你发现自己陷进完美主义者的心理瘫痪时，想想在那种情况下最糟糕的处境究竟是什么。你可以提醒自己：虽然这些幻想的处境是你所恐惧的，但是它们几乎无一例外地被夸大了。同时，如果你更进一步，将自己的固定心态转化为成长心态，那么，你或许会以全新的眼光来看待不完美——它是你提升自己、学习新知识的一个推动力，而并非致命打击。 成功需要太多付出：这令我望而却步 有些人担心成功需要付出太多，远远超出了他们所能承受的程度。因为致力于成功需要付出很多时间、努力和专注，有些人认为他们达不到那样的要求，还是站在原地会比较安全。 虽然对我们每个人来说，对自己的生活具有一定的掌控感是十分重要的一件事，但是同样重要的是，我们也必须学会去遵守那些不是我们自己所制定的规则，并顺应别人的需要。然而，那些对掌控感十分敏感的人或许不喜欢任何规则，他们会抗拒任何他人对自己的要求；对他们中的有些人而言，拖延成了他们获取掌控感的一种方式。 拖延成了这场争夺战的一个策略——它成了争夺控制权以及赢得尊敬和独立自主的一场争夺战。 你的拖延对你周围的人有什么影响。你的拖延是否给别人带来不便？当你落在后面的时候，你有没有请求别人重新安排日程？由于你没有及时完成自己的那一部分工作，你是否影响到别人的工作进度和工作计划？因为你没有完成自己的任务，你是否让别人承担了更多的工作？ 再想一想人们对你的拖延是怎么反应的。他们是否由于你的耽搁而感到烦躁不安？是否对你的种种借口感到泄气？是否由于你没有做到自己的承诺而对你大感愤怒？他们是否最终放弃了对你施加压力，只能让你按照自己的方式做事？如果你没有意识到这些问题，你可能会一直利用拖延来维护自己的独立感。你可能比自己设想的更加好斗，拖延就是你争夺控制权的一种方式。 许多拖延者故意无视他们在当前的拖延会在将来造成什么样可能的后果，但是总有一个时刻，那时拖沓的此时变成了过去，而不去料想的将来变成了此时。 第一个阶段是“无意识无行动力或前改变”（unconscious incompetence or prechange）阶段 第二个阶段是“有意识无行动或醒悟”（conscious incompetence or waking up）阶段 第三个阶段是“有意识有行动或者决心改变”（conscious competence or choosing change）阶段 第四个阶段是“无意识有行动”（unconscious competence）阶段 我们建议你为自己设立一个比较现实的、能够达成的、同时又容易衡量的目标。然后你把这个目标细分成可以容易操作的几个小单元，每个小单元你都可以在一个较短的时间内完成它，这样你就可以顺风顺水、一顺百顺了。 某件事情令你不舒服是因为你将它跟你的内心恐惧或焦虑联系在了一起，正是这样的不快使你对一件事情产生反感，并想要躲避它。 盘点你的内心挣扎 外在的与内在的后果 现在你已经回顾了你的拖延行为及其后果，注意一下你的感受是什么。悲伤？愤怒？宽慰？清醒？如果此刻你因为自己的愚蠢、道德软弱或者缺乏品味而陷入对自己的指责，请你退后一步，平息这种自责。启动你内心的辩护律师，寻找那一个对你友善的声音，试着想想从这些经历中你可以学到什么。 没有一个拖延者是毫无希望的，即便你的拖延已经蔓延到很多领域，但是总有一些方面你是不拖延的。 仔细思量一下，在你推迟的事情和你能够准时做到的事情之间，最关键的区分在哪里？ 想一想有没有什么时候你本来可以开始做一件事情而你又把它推迟了呢？ 你在拖延的时候会做什么？尽量多地观察你的种种表现，从最典型的行为模式，到最不显眼的拖延策略，你都要加以注意。 拖延者在目标设定上也存在着困难，这一点或许并不明显，因为表面上看来拖延者一直在忙着设定和重新设定目标，但是，他们所设定的目标几乎总是模棱两可的 分成几个小的步骤。不管一个目标是大还是小，达成任何目标的唯一办法就是一步一步来，就像有一句谚语讲的：“脚踏实地一步一步来，生活就会一帆风顺。 我们将自己的目标看得太过宏观，以至于阻碍了我们的进展。 就在你为自己的拖延找到一个理由之前，看看你能否发现究竟发生了什么事才会刺激你的拖延动机。在找到拖延理由之前，你在想什么？你有什么样的感受？或者，你在做什么？周围的环境又是怎样的？是什么触动了你？ 可操作目标 一个具有可操作性的目标可以被分解成几个小的、明确的步骤，就像最终的目标一样，每一个小的步骤都应该是可观察的和具体的。 请拖延者设想一个最小的目标。你可以设立一个什么样的目标，它既非常小，又可以给你带来进步感和成就感？ 你们中有些人可能不太情愿低头看脚下的路。那是完美主义在背后作祟！你对任何低于你理想的事情都看不上眼。虽然选择一个最小目标对你的骄傲是一种打击，但是从小事着手最终会让你尝到甜头。你可以通过一小步一小步地实现你的目标而最终成就你自己，而不是相反：光有空中楼阁，而没有实际行动。 你愿意以学习的心态看待成功和失败，愿意张开双臂迎接挑战，明白努力并非软弱的标志，而是进步的必需，在你接近或回避目标的过程中去了解自己的拖延问题。注意去观察你是怎样设立目标、怎样处理问题，你什么时候取得了进步，什么时候又变得拖延。 然而，世界上有些事情天生就是让人不快的或者单调乏味的 在最初，当时间期限到了的时候，你绝对有必要停下来。这个时候，你会想：“我做得很好，我应该充分利用这股冲劲，继续做下去。”这是一个很有诱惑力的想法，但是如果你在第一次不知不觉就做了两个小时，在超出的时间内你也做得很好，那么在下一次你就会觉得自己应该可以再干两个小时。这是一个陷阱，最终会将你引入失望和逃避。 记住，借口的出现意味着你处于选择的路口：你可以选择拖延，你可以选择行动。 拖延者的危险不在于暂时从难题中撤离，而在于完全地放弃。 确保你的奖赏要与成就的大小相匹配。 奖赏是一种正面的激励，它加大了一种行为重复的可能性。你的大脑也有助于你重复成功的行为。当你达成了一个目标，大脑就会释放一种多巴胺，它是一种让人感觉良好的神经传递素。你的某些行为模式可以引导你获得成就，而多巴胺就将这些构成行为模式的神经元网络联系在了一起，这会让你在将来重复这种行为的可能性大大增加。这就是所谓的“成功吸引成功”。 当你在迈向目标的过程中，你可能会发现你最初所做的现实性检查还是不那么切合实际。 在某些情况下，你可能有必要改变你的目标。 修正目标并不一定意味着失败。事实上，它意味着你足够灵活，而不是顽固不化，一个稳健而又成熟的人做事方能变通。 无需完美。如果你是一个完美主义者，你可能会陷入一场要将所有事情都做得绝对圆满的挣扎之中，即便实际情况中没有必要坚持这样的高标准。 如果你能在每一个环节都放下对于完美的执著，长远来看你一定能够做成更多的事情。当你在等待完美的时机、盼望完美结果的时候，你可以这样提醒自己：“万事无需完美，只要做到就行。” 评估你的进步（也包括不足） 观察你的感受。 回想你的选择关口。 当时你处于一个什么样的环境？什么样的念头、感受或者想象让你觉得很难继续前进？ 你学到了什么？回想一下，你是怎样处理实现目标的那一系列过程的？从让目标具有可操作性，到起步开始，再到跟进，在这个过程中，你想在下次有所改进的是什么事？ 我们希望在这一周里你对自己也有了不少新的认识。关于你自己，什么事情是你原先不了解而你现在了解的？不管你学到了什么，它们都应该可以帮助你为下一轮的拖延之战做好准备。所以，不要低估你的一周试验，因为不管你做了什么，或者没有做什么，你都可以从中学习。 我们不认为委派是失败的表现，委派是一种技巧。真正的失败是生活中每件事你都要固执地亲力亲为，这样做只会有一个结果，那就是你只能完成其中的一半。 “我是能够最好做这件事的唯一人选。”这是又一个完美主义的陷阱。虽然可能有些事情确实只有你才能做好，但是难道在你没有完成的事务清单上的每件事都是如此吗？即便其他人不会按照你那种方式来做事，能够以另一个方式将事情做完总比拖着不做要好多了 。我们不是建议你放弃你的自发性而成为一个准时的机器人，也不鼓励你花太多时间在计划上面，这有可能成为拖延的另一种方式，因为在某个时间点，你必须从计划中抽出身来，投入到实施中，但是我们建议你还是要花一点时间去想一想时间这个问题。 由。计划并不意味着要让自己被每一天的每一个小时所占据，你必须预料到意外发生的事情，同时你也需要让自己有时间享有自发性活动的乐趣，并享受让自己焕然一新的放松体验。 他们逼迫自己想有效利用每一分钟，结果却发现他们对自己的要求太高了，这不是一个计划的问题，而是一个压力的问题。 计划是将未来带入到当下，这样你马上就可以做一些事情来创造未来。 他知道很多制订日程表的人从来没能真正去实行，所以他们会变得失望，并最终放弃了这种做法。费雷博士发明了一种方法，用于追踪那些不属于必做事情的时间轨迹，他创造了“非计划”这个概念。我们发现“非计划”对我们的客户和拖延工作坊的参与者都很有帮助。 非计划”是一个每周日程表，它列出所有你必须做的事情。它可以帮助你在两天内实现你的目标。首先，在提前了解你有多少时间已经安排给了必须做的事情之后，对还剩下多少时间可以用于实现你的目标，你就心中有数了。其次，它可以帮助你在每周结束的时候做一个回顾，看看你的时间实际上用在了哪些地方，这也有利于你进行自我监测。 如果你确切地知道什么时候你会做什么事情，把它记在相应的空格内 如果你不能确切地预料到做事的时间，那就估计一下它所占用的时间长度，然后在你可能会做这件事的那一天上标示出来 。除此之外，还要将日常活动也标出来 将你生活中的所有事项都考虑进去 如果你经常观看晚间新闻、周一晚间足球赛或者其他喜欢的电视节目，也把它们记下来。 只是要求你确认在即将到来的一周里已经安排好了哪些时间。 当你眼看着自己接下来七天的安排，你有什么感受？ 在你观想自己如何度过这一周的时候，观察一下自己的感受，并思考这份日程表中有什么因素导致你产生那样的感受？ 从这张表格中，你可以了解自己有多少时间可以用于完成你的目标。这张“非计划”表格为你显示了你可以利用的最大时间，其中的空格反映的是你没有被安排掉的时间。当然，没有人会把所有这些未被安排掉的时间用于完成目标，但是“未列入”表格为你显示了你一共有多少时间是可以利用的。 当你在实现你的可操作目标或任何其他项目的时候，使用“非计划”来记录你的进步。当你在达成目标的方向上工作了半个小时，就在“非计划”表格上涂掉相应的半格。如果你工作了一个小时，涂掉整个格子。 将那个星期你花在完成目标上的时间加起来 你涂掉的格子可能会出现在你原本安排做其他事情的时段里 你记录下自己的进步，你就会把注意力放在你已经完成的事情上， 而当你将你实际做的事情记录下来的时候，它更可能会给你一种成功的经验。以这种方式监测你的进步，使你能够看到事情积极的一面， 当你一个星期只花一个小时在完成目标上，你就无法欺骗自己，认为自己已经做成了很多事情。而当你一周花四个小时在这上面，你也无法假装说你一事无成。 可以让你认识到，即便是半个小时的努力也是有价值的 你可以做10个小时的事而没有一点成就感。但是如果你将这些小时数记录下来，至少在你面前有一个有形的证据可以用来说服你失望的情绪。你可以用这种客观的方法对自己怎样运用时间的主观认识加以纠正。 有一个办法可以克服时间的主观观念，提高你对时间的判断能力，那就是将你对完成时间的预测与实际使用时间做对比。 练习判断时间。你能够精确地预测一件事需要花费多少时间完成吗？ 你的目标需要10个小时来完成并不意味着你要等到一整块时间的出现才能开始做事。 学会利用零碎时间。 任何一个步骤都比你回避的行为要更为有效，至少你又往前迈进了一步。 时间限制也让一项任务显得更容易接受。 另一方面，如果你利用上一小段时间，无意中你就有一个时间上的限制。为自己设定一个时间限制是针对拖延者的一个很好的练习，它有助于你去克服一些不切实际的想法，认为一旦自己有很多时间之后，就可以集中自己所有的精力去完成它 如果你的拖延是因为你不喜欢被控制和挤压，拖延就成了你的一个声明：“你无法让我做这件事情。”如果你做了这件事情，你的自由感和独立感就会受到威胁 非此即彼”的观念对拖延者而言始终是一个不断出现的障碍。如果你让自己认识到“小有所成”也有其价值，那么利用零碎时间会让你事半功倍。 预防意外干扰 为什么你没有为可能出错的事情做好准备呢？为什么认定你的个人努力是唯一要考虑的因素呢？一旦你最终克服自己的抗拒心理，准备好去做事，你或许就期待着一切都会顺顺利利。不幸的是，这个世界并不是围绕着你的设想运转的。 如果你提前知道任何事情都会有意外情况发生，你就站在了一个有利位置，随时准备跨越障碍，而不会被困其中，手足无措，也不会埋怨运气不好，或者责备你自己。 委派任务 你最好将事情委派给那些有能力帮助你的人，那些对你不怀恶意的人，以及那些不是拖延者和完美主义者的人 是将事情分出轻重缓急，然后把你的时间用于最重要的事情上。不那么重要的事情可以委派给其他人做（甚至先放在一边） 但是如果你认定只有一种正确的委派方式，那么你就会从很多角度考虑这件事，寻找一个完美的解决方案，这都无助于你做出最后的决定。无论是平庸的事情还是重要的事情，一旦交付出去，你的负担就减轻了。 过于忙碌本身是否就是拖延呢？如果像易生那样，你利用忙碌来逃避更为重要的事情，那么你可能就是在拖延。当你要做很多事情的时候，你不仅培植了一片使得拖延滋生的土壤，而且还为自己准备好了拖延的借口：“我并没有在拖延，我只是太忙了，无法及时干完每一件事。” 不要太分散精力。 我们每个人都有一个自然的生物节奏，想一想一天当中什么时候你的脑力最旺盛，什么时候你的体力最充沛，什么时候你最适合社交，还有什么时候你的精神最差。 找出你的最佳时间 找出你的最佳时间意味着承认有些时间不是最佳的 学会在过去、现在和未来之间取得认知上的平衡。不要黏滞在时间中，这一点很重要。如果你黏滞在过去，你就无法享受现在，也不能为未来做打算；如果你黏滞在现在，你就处于当下时刻的控制之中，而失去了跟过去和未来的联系，你也无法从自己的经验中受益；如果你黏滞在未来，你就被锁定在一个幻想的世界，无论这个幻想是正面的还是负面的，你所能做的就只有计划或者担忧 享受你的“自由”时间 很多时候你也无法尽情享受，因为你知道自己是在利用娱乐来逃避某些事情 对杂乱无序说不 “扔掉50件东西。 学会拒绝那些没有意义的追求 对浪费时间和让你退步的人和事说不 当我们不能直接拒绝的时候，我们可能会通过拖延来间接地拒绝。拖延还表示我们将窃取的时间用于我们不能公然接受的事情上 学会接受有益于你的人和事 与依靠拖延相反，我们觉得我们应该有意识地接受那些提高我们生活品质的事情，而拒绝那些对此无益的事情，并且应该直接地表达出来，而不应该通过拖延的方式来拒绝。 你需要找到那些友善、能鼓舞人且不妄加判断的人，他们还必须务实，能够专注于你的任务。选择那些站在你一边的人，他们能够从你的角度看问题 寻找帮助是利用你跟其他人的关系来帮助自己采取行动，并推动自己向前迈进。 你可以跟一个支持你的人讨论你的拖延问题或者你的可操作目标。在聆听对方的想法和建议的时候，尽量放开心胸，不要处处为自己辩解 做一个公开承诺。告诉人们你在做什么以及什么时候会完成 一起制订计划。你可以通过跟另一个人交谈来制订行动计划 与一个跟你优势互补的人交谈对你尤其有帮助。如果你擅长预见最后的结果，却不清楚怎么一步步达成目标，那就跟一个善于将事情落到实处的人聊一聊。如果你擅长把握细节，却缺乏宏观的视野，那就跟一个具有大视野的人聊一聊。 你也会听到别人在面对你所面临的问题时是怎样设法解决的，这都会带给你有益的启示。 从他对目标的清晰把握里，我们发现了应该如何去改变我们的原有观念。 记住，当你在寻求帮助的时候，你没有必要一定采用它。还有，当别人很有洞察力，看到了一些你看不到的事情，你不必自卑 拖延者对别人的目标总是能够保持非常清醒和务实的头脑，但是对他们自己的目标却一片糊涂，过于理想化。在你帮助别人理清达成目标的思路时，你或许会意外地发现自己对组织管理和时间管理有了很多新的想法 在你被困住的时候寻求帮助。当你的大脑就像被锁住一样无法起作用的时候，你应该寻求外界的帮助 共同工作。 如果两个人共同为一个目标而奋斗，每一个人都会有更大的冲劲去实现目标。如果你不好好做，不仅自己的生活受到损害，而且另一个人的生活也将受到影响。 有一个工作伙伴也有助于制订中间每一个阶段的最后期限，这样，离最后阶段越近，你采取行动的压力就越大。 你也可以特意安排一个伙伴作为对你个人进展的检查者 平行式做事法。 同样地，你也可以安排自己跟一个独自做事的人一起做事 社交奖赏。有时候进步本身就是一种奖赏，但是更多时候社交可以是一个更好的奖赏 在通向目标的每一个阶段，你都可以运用社交奖赏 跟你所爱的人相处。拖延经常会影响到跟你所珍重的人无忧无虑地相处。 尝试新的挑战 做更多你所热爱的事情 什么是你想在生活减少或者消除的事情，什么又是你想要加入到生活中来的事情，这些都非常重要，值得你好好想一想 更为重要的是，要决定什么是应该包括进来、什么应该排除出去本身就很困难，当你对自己的判断缺乏信任的时候，事情尤为如此。 对空洞性事务说不 如果你所做的事情无法让你向着自己的方向前进，那么你就不要去做它 空洞性事务是指相对你当前的目标和价值观而言最微不足道的那些事情 在时间管理中经常被引用的一个法则就是二八法则：你20%的事务非常重要，并会产生最大的影响，你80%的事务不太重要，做不做对你并没有多大影响。这被称为“关键的事情不会多，微不足道的事情却很多”。学会对许多微不足道的事务说不，将你80%的时间用来完成那些少数几个重要的事务。 能够识别空洞性事务表明你知道什么重要什么不重要 对不必要的事情说不 有时候我们之所以答应去做事情，是因为我们想要取悦别人，或者我们担心如果拒绝就会冒犯他们。但是为了一个错误的理由而答应去做事情最终还是会让人不舒服，也可能会导致厌烦和拖延。对这些事情，你只需说不。 对不适合你的人说不。随着你长大，你的父母或许曾经忠告你“明智地选择朋友”。很重要的一点是，要将时间花在那些能够对你坦诚相待、一起欢笑、相互信任、在困难的时候可以依靠的朋友 你没有义务为每一个挤占你时间的人腾出时间。 可能对有些对你产生负面影响的人，你根本没办法跟他们说不，尤其是当他们是你的同事或者家族成员的时候。你也许可以限制跟他们待在一起的时间，或者培养出一个内心的隔离带，这样他们的负面言行就无法影响到你 当你对50件东西说不的时候，为你扔掉的东西做一张清单。以后当你回头看的时候，你会为所有被你丢弃的东西而感到自豪。 对电子上瘾说不 坚持信息减肥。 通过运动启动你的状态 将运动作为你调整拖延的一种方法，在这个方向上采取一定的行动。就像我们所有所建议的技巧一样，只要你付诸行动，运动一定会对你有好处。如果你发现你自己像拖延其他事情一样拖延运动，尽管你知道它的好处，那么你可以回顾一下我们在第一部分中对于恐惧的阐述。害怕失败和成功、害怕被控制会妨碍你将运动整合进自己的生活。 从小事做起。 做一会儿运动。当你发现自己做事时踟蹰不前的时候，或者，当你想要开始做事但是毫无头绪的时候，你可以做一个小小的休息。 神圣停顿法。 正念（mindfulness）指的是“在当下时刻对周遭环境不带判断地保持有意识的觉察”。 它的要点在于：在从事一项活动或进入下一个阶段之前，刻意地、有意识地停顿片刻 在我们学习一个新的行为模式和技巧的时候，典型的过程都是从很多外在支持开始的，随着我们将那个行为内化，外界的支持才渐渐消退，最后我们可以在没有外界指导或没有环境框架的情况下独立完成 有策略地去减少干扰的数量 执行提示点 光有一个计划可能还不足以帮助你坚持到底。你需要自身之外的某些东西来提醒你在什么时候什么地方准备采取行动 习惯性的架构和线路 设定一个例行时间 写一个清单 利用一分钟时间。在非常短的一小段时间内为你的目标做一点点事。 保持行动，在你走动的时候做清理，在下一桌端上来之前，将脏碗碟清理干净。这是利用你快速运转的大脑的一种方法，它有助于你不被那些堆积起来的事情弄得晕头转向。当事情出现，马上处理掉，然后转到下一件事，不要让待办事项堆积起来 不要想在你的弱项上表现优异，而要在你的强项中更上一层楼。” 如果你的大脑极为容易分散注意力，而自我约束对你是一场无边的挣扎 拖延者对他们所做的或所没有做的事情经常含含糊糊，让你以为事情进展比真实情况要好得多。这是一件令人气馁的事情，拖延者要么不想告诉你实情，要么不敢。这让你感到受骗上当或者被人出卖，这就使得你们的关系陷入紧张与冲突之中 不幸的是，拖延者往往并不将你的鼓励看做是一种支持，相反，当你试图控制局面的时候，鼓励可能会被当做是一种对他的压力或者干扰 除了某些少有的情况，你决不能自己上阵代替一个拖延者去做事 1.帮助你的孩子设定小目标。 但是在你自己成为一个拯救者的同时，你只会让问题变得更加复杂，因为这强化了拖延者的期待，他们会更加指望在最后时分有人来拯救他们 光是认清拖延的根源还是不够的，你还必须做一些事情以防止它主导你的生活 在这样的处境下，你必须考虑怎样照顾好你自己。如果你做过了所有的尝试，你的拖延者的行为还是将你逼到危险的境地，那么，你可能必须采取单方面的行动——你要么自己去做那份工作，或雇用其他人去做；要么，在某些极端的情况下，结束你们之间的关系 在工作场所，当人们感觉他们的工作缺乏足够的自主性，看不到自己所做事情的意义，不能取得工作上的相应反馈，或者对一项工作感到挫败、厌恶或者无聊的时候，人们就会拖延 附录二 拖延处理技巧汇编","categories":[{"name":"书影音","slug":"书影音","permalink":"https://blog.five2fire.top/categories/%E4%B9%A6%E5%BD%B1%E9%9F%B3/"}],"tags":[{"name":"自律","slug":"自律","permalink":"https://blog.five2fire.top/tags/%E8%87%AA%E5%BE%8B/"},{"name":"读书笔记","slug":"读书笔记","permalink":"https://blog.five2fire.top/tags/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"},{"name":"心理学","slug":"心理学","permalink":"https://blog.five2fire.top/tags/%E5%BF%83%E7%90%86%E5%AD%A6/"}]},{"title":"短暂的两个月副业总结","slug":"短暂的两个月副业总结","date":"2024-09-27T07:59:16.000Z","updated":"2025-01-02T02:17:10.826Z","comments":true,"path":"article/3999.html","permalink":"https://blog.five2fire.top/article/3999.html","excerpt":"","text":"前言这篇文章，从我刚开始做这个副业，就已经决定要写，到9.15号停止接单，再到今天开始写，拖了快一个月了。 其实到上个月底，业务就已经“趋于稳定”了，那个时候应该是写这篇文章的最佳时刻，被我硬生生拖了一个月。 为什么现在行动了呢，说出来可能会让人觉得毫无关联——因为国家救市政策出来，股市大涨。 大家全都在讨论赚钱，讨论解套，变成了导致情绪崩溃的最后一根稻草，可能是我给自己的压力比较大，并且只有压力没有相应的行动去缓解压力。 所以现在写这个，也算是缓解压力的一个手段吧。 让我们开始。 关于副业副业的内容关于这次两个月副业的内容，简单来说，就是发现了某网站会员的支付“漏洞”，能够以极低的价格开通会员。 这个漏洞也是早有先例了，之前的Steam阿区，包括现在youtube，spotify土区，都存在这个价格差。原理其实就是会员在不同国家&#x2F;地区的价格不一样，经过汇率换算之后存在一定的获利空间。 简单总结 项目 数据 备注 平均客单价 ￥13.6 获客数 188 粗略估算，图个吉利 成交数 125 总成本 $292.5+￥28 主要是会员钱，汇率波动不算在内 总收入 ￥3750 每人30 总利润 1668.65 以写文时的实时汇率计算 一些数据 公众号关注数据 文章阅读量趋势 豆瓣咨询量58人，小红书咨询量22人，闲鱼咨询量5人。 公众号截止2024年9月27日，总关注数111人，其中70人付费。 从咨询-付费的转化来看，豆瓣转化率最高（由于有人看了帖子直接自助支付，并没有关注公众号，粗略估计有78%，即45人咨询后上车），小红书咨询后付费人数为3，转化率很低，为14%。其余部分为全流程自助（包括豆瓣帖子、微信搜一搜、闲鱼自动回复转公众号），无法详细分析。 总的付费数125，实际上就是所有成功交易的订单量。有部分是一人多单的情况。 详细总结 第一次赚到工作之外的钱，或者称之为副业收入，所以刚开始很激动，但其实客单价很低，而且由于会员是年费，这个客单价是以年计算的，导致后期热情不足。 豆瓣用户转化率比小红书高，可能的原因分析如下 豆瓣社区比较老，用户粘性强；小红书社区比较新。 豆瓣发帖的账号注册比较久，也偶有互动，比较像真人。小红书基本上算是新号，且发帖较为随意，并没有获得多少官方给的流量。 小红书内部自带电商交易系统、且平台已有相关会员卖，且成交量很高。用户可能觉得我这个价格很低会是骗子。 我的小红书账号性别为男，外加私信引流至公众号，综合考虑可能不容易让人信服。 豆瓣帖子更新很勤，小红书基本没有管过，一共发了四次帖子，前两次的帖子很随意，有很多关注。后面两个帖子精心编排了，反倒没人看了。 付费用户性别，女性比男性多，详细统计会很麻烦（但能得到确切数据），粗略估计为6.5：3.5.年龄构成主要以25-35的青年为主，画像主要是刚毕业工作的职场人以及家里有小孩的父母。 我设计的全自助流程实际上是很便捷且证明非常高效的，这也让我的帖子在短短两个月内回复数就赶上了另一个竞争对手（他已经做了快一年了），并且也确实让我省了不少时间。 不过这个流程设计前后更新了两次，新方案固然比旧方案高效，但是折腾的时间也确实不少。 流程设计没有从一开始就考虑操作的便捷性，不过从可行性上都值得肯定。 过程中遇到特殊情况后，总结了FAQ进行了推送，效果不错。但是这个FAQ实际上也拖了很久，如果早点推出，会更省事。 遇到三四个比较难缠的客户，一个是想拖着两周后付费，一个是年龄比较大的“电子产品盲”，一个是咨询了很多有的没的就是不提要不要，还有几个的是账号本身有问题需要持续跟进解决，统一算成一个难缠的客户。5%的概率遇到这样的客户，我觉得不算低了。 实际消耗的精力换算成工时，用总利润除以总时间，￥9.6&#x2F;H。跟工作比起来天差地别。由于占用的时间比较零碎，且本人注意力容易分散，所以算作共计180个工时。 忘记说成本了，线上业务，成本就是开会员的钱以及少量网络费用，我觉得副业的人工成本是自己给自己打工，应该不算在内。 由于客单价太低，想拓展至海外渠道赚刀乐，有一点点行动但是不多，最终也没有搞到一单，还浪费了很多时间在这上面。 中途也有尝试过免费试用的引流手段，综合下来做了一周放弃。一是可能导致账号问题，二是免费的可能反而让用户产生怀疑，所以后来不做了。 之后想到还有什么总结的再补充吧。之前应该有想到一些，但因为拖延也没有记录下来，可能有遗漏。 整件事情中有关产品的一点点切身感悟获客渠道俗话说，酒香不怕巷子深。实际上，先不谈酒究竟香不香，“巷子深”这一点就已经让产品减少了曝光，这在现在流量为王的时代一定是大忌，好的产品必须要配上好的营销策略和推广方案。从另一个角度看，自来水也是一种推广手段，是用产品力去征服用户，才会让他们自愿为产品做宣传。 与用户建立信任我自己作为用户，在购买的时候也会问自己“我真的需要吗”、“这个卖家靠谱吗”、“这个产品的质量好吗”、“被骗了怎么办”，在和客户沟通的过程中，也确实遇到很多有这样疑问的客户。有的人比较搞笑，直接问我“你不会是骗子吧？”，还有让我说“中国人不骗中国人的”，哈哈哈。所以其实从用户角度来看，我觉得信任是需要用户自己先去建立的，因为商家为了卖东西，一定是花言巧语先把你哄进来。在这一点上，一些平台的评价系统实际上是能够让消费者在一定程度上去判断一个商家是否靠谱的，但是现在刷评行为泛滥，所以5星也并不一定代表就是好。这其实是现在“种草”、“拔草”比较流行的其中一个原因，因为好评不再被信任，更信任来自真人的反馈。不过拔草种草现在也已经被商家玩通了，可以花钱找KOL去宣传，可能一切到最后都是一场轮回吧。从商家端来看，在宣传的时候加入真实用户反馈，具体解释自己服务的特点，详细回答每一个消费者可能关心的问题，是打消消费者疑心的第一步。下一步要做的，就是给予消费者切实的保障，比如让平台介入，保证有问题可以退货，也不失为一种获取信任的方法。大众点评的前身叫做“口碑”，商家的口碑是很重要的，自来水行为要把握住，配合打出相应的营销策略也许效果会事半功倍。 定价这次副业中断的原因，最根本的是官方封堵了相关入口（还是有其他办法的），还有一个主要原因是因为客单价太多，让我觉得这份副业的“性价比”不高。定价30是因为有同行竞争，甚至还有定价25宣传“公益”的（不过确实没有赚多少，实在是薄利多销）。这让我反思了一下定价问题，也是产品一开始推向市场时就要想好的策略。同样一款包包，LV的就可以卖很贵，SG的就可以白送（这是品牌，也是定价）。有的时候揣摩一下消费者的心思，会发现有的消费者反而会觉得便宜没好货。还有一点，产品本身有成本，售前售后的服务实际上也有成本，如果把我的服务也考虑进去，30的定价还是有些低了。不过这次副业涉及的产品不太有代表性，具体来说 只要开了，实际上不愁没人买，只是售出的速度快慢问题。（产品力） 几乎没有成本，人人可做，主打的一个售卖信息差。（竞争力） 市场上劣币较多，让用户很难信任商家。（大环境）不同产品要具体去分析，还是在一开始就想好商业画布的几个关键点最好，后期再去慢慢调整。 用户体验我卖的产品，个人觉得用户体验还是很好的，主要是体现在服务上。2个月内更新了两次自助的流程，并且配有详细的FAQ说明，以及产品说明，大大打消一些年轻群体的顾虑，只需要针对不熟悉互联网的少部分客户做解释即可。操作的便捷性会影响用户对产品的印象，所以那句“把用户当成傻子一样看待”还是有一定道理的。在做产品设计的时候，要注意产品的易用性，太复杂了会劝退用户。我试用过一些极简APP，画面确实是简了，但是操作却复杂了，反正是让我接受不了，需要重复地去操作才能培养该APP的使用习惯，也不太行。 售后服务其实前面也已经提到了，一个是走平台让消费有保障，不会随便跑路，还有一个就是售前售后给予用户充分的解释，而不是敷衍，让他看到商家的态度，这能够极大地建立信任。有好几位客户主动反馈了特别积极的评价，也让我有了继续做下去的动力。 生命周期此次副业的生命周期实际上随着官方封堵也几近结束了，剩下的方式比较折腾，所以我也就不想做了。产品比较特殊，生命周期不受自己控制。好的产品应该在一开始就规划好后面的路，这样应对各种状况才不会手忙脚乱。","categories":[{"name":"产品","slug":"产品","permalink":"https://blog.five2fire.top/categories/%E4%BA%A7%E5%93%81/"}],"tags":[{"name":"副业","slug":"副业","permalink":"https://blog.five2fire.top/tags/%E5%89%AF%E4%B8%9A/"},{"name":"产品","slug":"产品","permalink":"https://blog.five2fire.top/tags/%E4%BA%A7%E5%93%81/"},{"name":"效率","slug":"效率","permalink":"https://blog.five2fire.top/tags/%E6%95%88%E7%8E%87/"}]},{"title":"【Hacking With Swift】Project13_Instafilter","slug":"Project13_Instafilter","date":"2024-07-07T03:58:25.000Z","updated":"2025-01-02T02:17:10.813Z","comments":true,"path":"article/11062.html","permalink":"https://blog.five2fire.top/article/11062.html","excerpt":"","text":"英文原博博主是 Paul Hudson @twostraws 本文是学习Swift过程中翻译该网站的内容: https://www.hackingwithswift.com/ 介绍在这个项目中，我们将构建一个应用程序，允许用户从他们的库中导入照片，然后使用各种图像效果对其进行修改。我们将涵盖许多新技术，但在所有这些技术的中心是一个有用的应用程序开发技能 - 使用苹果的核心图像框架 - 以及一个重要的 SwiftUI 技能 - 与 UIKit 集成。还有其他事情，但这两个是最重要的收获。 核心图像是苹果用于操作图像的高性能框架，非常强大。苹果为我们设计了数十种示例图像滤镜，提供模糊、颜色偏移、像素化等功能，所有这些都经过优化，充分利用了 iOS 设备上的图形处理单元（GPU）。 提示：虽然您可以在模拟器中运行 Core Image 应用程序，但如果大多数事情运行得很慢，不要感到惊讶 - 只有在物理设备上运行时才能获得出色的性能。 关于与 UIKit 集成，您可能会想为什么需要这样做 - 毕竟，SwiftUI 旨在取代 UIKit，对吧？嗯，有点。在 SwiftUI 推出之前，几乎每个 iOS 应用都是使用 UIKit 构建的，这意味着可能有数十亿行 UIKit 代码存在。因此，如果您想将 SwiftUI 集成到现有项目中，您需要学习如何使这两者良好地协同工作。 但还有另一个原因，我希望这不会永远是一个原因：Apple 的框架的许多部分尚未有 SwiftUI 包装器，这意味着如果您想集成 MapKit、Safari 或其他重要的 API，您需要知道如何包装它们的代码以供 SwiftUI 使用。坦率地说，使这项工作正常运转所需的代码并不美观，但在您的 SwiftUI 职业生涯中，您已经做好了准备。 一如既往，我们在开始项目之前有一些技术要讲解，请使用应用模板创建一个名为“Instafilter”的新 iOS 应用。 属性包装器如何变成结构体您已经看到了 SwiftUI 如何通过使用 @State 属性包装器在视图结构中存储变化的数据，我们如何可以将该状态绑定到 UI 控件的值使用 $ ，以及如何更改该状态会自动导致 SwiftUI 重新调用我们视图的 body 属性。 所有这些结合在一起，让我们能够编写这样的代码： struct ContentView: View { @State private var blurAmount &#x3D; 0.0 var body: some View &#123; VStack &#123; Text(&quot;Hello, World!&quot;) .blur(radius: blurAmount) Slider(value: $blurAmount, in: 0...20) Button(&quot;Random Blur&quot;) &#123; blurAmount = Double.random(in: 0...20) &#125; &#125; &#125; }如果您运行该程序，您会发现拖动滑块左右会调整文本标签的模糊程度，就像您期望的那样，点击按钮会立即跳转到随机的模糊程度。 现在，假设我们希望该绑定不仅仅处理模糊效果的半径。也许我们想要运行一个方法，或者只是为了调试目的打印出该值。您可以尝试像这样更新属性： @State private var blurAmount &#x3D; 0.0 { didSet { print(“New value is (blurAmount)”) }}如果你运行那段代码，你会感到失望：当你拖动滑块时，你会看到模糊程度发生变化，但你不会看到我们的 print() 语句被触发 - 实际上，根本不会有任何输出。但如果你尝试按下按钮，你会看到打印出的消息。 为了理解这里发生的事情，我希望你能稍微探索一下 @State 的功能，以及属性包装器实际上为我们做了什么。 属性包装器之所以被称为这个名字，是因为它们将我们的属性包裹在另一个结构体内部。这意味着当我们使用 @State 来包装一个字符串时，我们最终得到的属性类型是 State 。同样，当我们使用 @Environment 等等时，我们最终得到的是一个包含其他值的 Environment 类型的结构体。 之前我解释过，我们无法在视图中修改属性，因为它们是结构体，因此是固定的。然而，现在你知道 @State 本身产生一个结构体，所以我们面临一个难题：这个结构体怎么能被修改呢？ Xcode 有一个非常有用的命令叫做“快速打开”（使用 Cmd+Shift+O 访问），它可以让您在项目中或任何导入的框架中找到任何文件或类型。现在激活它，然后输入“State” - 希望第一个结果下面显示 SwiftUI，如果不是，请找到并选择它。 您将被带到一个为 SwiftUI 生成的界面，这实质上是 SwiftUI 向我们公开的所有部分。里面没有实现代码，只有大量协议、结构体、修饰符等的定义。 我们要求查看 State ，因此您应该已被带到此行： @propertyWrapper public struct State : DynamicProperty {那个 @propertyWrapper 属性是我们使用这个 @State 的关键。 现在往下看几行，您应该会看到这个： public var wrappedValue: Value { get nonmutating set }封装的值是我们试图存储的实际值，比如一个字符串。生成的接口告诉我们的是，该属性可以被读取（ get ），并且可以被写入（ set ），但是当我们设置值时，它实际上不会改变结构体本身。在幕后，它将该值发送到 SwiftUI 进行存储，可以在那里自由修改，因此结构体本身永远不会改变。 现在你知道了所有这些，让我们回到我们有问题的代码： @State private var blurAmount &#x3D; 0.0 { didSet { print(“New value is (blurAmount)”) }}表面上，这表示“当 blurAmount 更改时，打印出其新值。”然而，因为 @State 实际上包装了其内容，它实际上是在说当包装 blurAmount 的 State 结构更改时，打印出新的模糊量。 还跟得上吗？现在让我们再深入一步：您刚刚看到了 State 如何使用非变异设置器包装其值，这意味着 blurAmount 或 State 包装它的结构体都没有发生变化 - 我们的绑定直接改变了内部存储的值，这意味着属性观察器从未被触发。 因此，通过按钮直接更改属性是有效的，因为它经过非突变的设置器并触发 didSet 观察者，但使用绑定则不行，因为它绕过设置器并直接调整值。 那么我们如何解决这个问题 - 如何确保无论发生何种更改，都会运行一些代码？嗯，有一个专门用于此目的的修饰符.. 使用 onChange()响应状态更改由于 SwiftUI 将绑定更新发送给属性包装器的方式，与属性包装器一起使用的属性观察器通常不会按照您的预期工作，这意味着即使模糊半径发生变化，这种代码也不会打印任何内容： struct ContentView: View { @State private var blurAmount &#x3D; 0.0 { didSet { print(“New value is (blurAmount)”) } } var body: some View &#123; VStack &#123; Text(&quot;Hello, World!&quot;) .blur(radius: blurAmount) Slider(value: $blurAmount, in: 0...20) &#125; &#125; }要修复这个问题，我们需要使用 onChange() 修饰符，它告诉 SwiftUI 在特定值更改时运行我们选择的函数。SwiftUI 会自动将旧值和新值传递给您附加的任何函数，因此我们会像这样使用它： struct ContentView: View { @State private var blurAmount &#x3D; 0.0 var body: some View &#123; VStack &#123; Text(&quot;Hello, World!&quot;) .blur(radius: blurAmount) Slider(value: $blurAmount, in: 0...20) .onChange(of: blurAmount) &#123; oldValue, newValue in print(&quot;New value is \\(newValue)&quot;) &#125; &#125; &#125; }现在，由于 onChange() 正在监视它，该代码将在滑块更改时正确打印出值。请注意，大多数其他内容都保持不变：我们仍然使用 @State private var 来声明 blurAmount 属性，并且我们仍然使用 blur(radius: blurAmount) 作为文本视图的修饰符。 提示：您可以将 onChange() 附加到视图层次结构中的任何位置，但我更喜欢将其放在实际发生变化的地方附近。 所有这些意味着你可以在 onChange() 函数内做任何你想做的事情：你可以调用方法，运行算法来确定如何应用更改，或者其他任何你可能需要的操作。 onChange() 修饰符有另外两种常见变体： 一个完全不接受任何参数的函数，用于当您只想在值更改时运行函数，但实际上并不关心新值是什么时。只接受新值，而不传入旧值的函数。这在 iOS 17 中已被弃用，这是苹果的说法，意思是“除非需要支持 iOS 16 及更早版本，请不要使用此功能”。 使用 confirmationDialog()显示多个选项SwiftUI 为我们提供了 alert() 来呈现重要选择，以及 sheet() 来在当前视图之上呈现整个视图，但它还为我们提供了 confirmationDialog() ：一种替代 alert() 的方法，让我们添加许多按钮。 视觉警报和确认对话框非常不同：在 iPhone 上，警报出现在屏幕中央，必须通过选择按钮积极地解除，而确认对话框从底部滑出，可以包含许多按钮，并且可以通过点击“取消”或点击选项之外的地方来解除。 虽然它们看起来非常不同，但确认对话框和警报几乎是以相同的方式创建的： 两者都是通过将修饰符附加到我们的视图层次结构上创建的 - 用于警报的 alert() 和用于确认对话框的 confirmationDialog() 。当条件为真时，SwiftUI 会自动显示两者。两者都可以填充按钮以执行各种操作。两者都可以附加第二个封闭以提供额外的消息。为了演示确认对话框的使用，我们首先需要一个基本按钮，用于切换某种条件： struct ContentView: View { @State private var showingConfirmation &#x3D; false @State private var backgroundColor &#x3D; Color.white var body: some View &#123; Button(&quot;Hello, World!&quot;) &#123; showingConfirmation = true &#125; .frame(width: 300, height: 300) .background(backgroundColor) &#125; }现在是重要的部分：我们需要向按钮添加另一个修饰符，在我们准备好时创建并显示确认对话框。 就像 alert() 一样，我们有一个 confirmationDialog() 修饰符，它接受三个参数：一个标题，一个决定对话框当前是否显示的绑定，以及一个提供应显示的按钮的闭包 - 通常作为尾随闭包提供。 我们为确认对话框提供标题，可选地也提供消息，然后是一个按钮数组。这些按钮按垂直顺序堆叠在屏幕上，通常最好在最后包括一个取消按钮 - 是的，您可以通过在屏幕其他地方轻击来取消，但最好给用户明确的选项。 因此，请将此修改器添加到您的文本视图中： .confirmationDialog(“Change background”, isPresented: $showingConfirmation) { Button(“Red”) { backgroundColor &#x3D; .red } Button(“Green”) { backgroundColor &#x3D; .green } Button(“Blue”) { backgroundColor &#x3D; .blue } Button(“Cancel”, role: .cancel) { }} message: { Text(“Select a new color”)}当您运行应用程序时，您应该发现点击文本会导致确认对话框滑过来，并且点击其选项应该会导致文本的背景颜色发生变化。 将 Core Image 与 SwiftUI 集成核心图像是苹果用于操作图像的框架。这不是绘图，或者至少在大多数情况下不是绘图，而是改变现有图像：应用锐化、模糊、晕影、像素化等效果。如果您曾经使用过苹果的照片展台应用程序中提供的各种照片效果，那么您应该对核心图像的用途有一个很好的了解！ 然而，Core Image 与 SwiftUI 集成并不是很好。事实上，我甚至不会说它与苹果较旧的 UIKit 框架集成得很好 - 他们做了一些工作来提供帮助，但仍需要相当多的思考。不过，请跟着我走：一旦你理解了它的工作原理，结果会非常出色，你会发现它为你的应用程序未来开启了一整套功能。 首先，我们将放入一些代码，以便为我们提供一个基本图像。我将以稍微奇怪的方式构建这个结构，但一旦我们混入核心图像，这将会变得合理：我们将创建 Image 视图作为一个可选的 @State 属性，让它调整大小以与屏幕大小相同，然后添加一个 onAppear() 修饰符来实际加载图像。 将示例图像添加到您的资源目录，然后将您的 ContentView 结构修改为这样： struct ContentView: View { @State private var image: Image? var body: some View &#123; VStack &#123; image? .resizable() .scaledToFit() &#125; .onAppear(perform: loadImage) &#125; func loadImage() &#123; image = Image(.example) &#125; }首先，注意 SwiftUI 如何流畅地处理可选视图 - 它只是有效果！但是，请注意我如何将 onAppear() 修饰符附加到图像周围的 VStack ，因为如果可选图像是 nil ，那么它不会触发 onAppear() 函数。 无论如何，当该代码运行时，应该显示您添加的示例图像，经过整齐缩放以适应屏幕。 现在是复杂的部分： Image 到底是什么？正如您所知，它是一个视图，这意味着它是我们可以在 SwiftUI 视图层次结构中定位和调整大小的东西。它还负责从我们的资源目录和 SF Symbols 加载图像，并且还能够从其他几个来源加载。然而，最终它是一个被显示的东西 - 我们无法将其内容写入磁盘或以其他方式转换它们，只能应用一些简单的 SwiftUI 滤镜。 如果我们想要使用核心图像，SwiftUI 的 Image 视图是一个很好的终点，但在其他地方使用并不实用。也就是说，如果我们想要动态创建图像，应用核心图像滤镜等等，那么 SwiftUI 的图像就不够用了。 苹果为我们提供了另外三种图像类型供我们使用，巧妙地，如果我们想要使用 Core Image，我们需要同时使用这三种类型。它们听起来可能相似，但它们之间有一些微妙的区别，如果你想从 Core Image 中获得有意义的结果，那么正确地使用它们是非常重要的。 除了 SwiftUI 的 Image 视图外，另外三种图像类型是： UIImage ，来自于 UIKit。这是一种非常强大的图像类型，能够处理各种图像类型，包括位图（如 PNG）、矢量图（如 SVG）甚至形成动画的序列。 UIImage 是 UIKit 的标准图像类型，而在这三种类型中，它与 SwiftUI 的 Image 类型最接近。CGImage ，来自核心图形。这是一种更简单的图像类型，实际上只是一个像素的二维数组。CIImage ，来自核心图像。这存储了生成图像所需的所有信息，但除非被要求，否则不会将其转换为像素。苹果将 CIImage 称为“图像配方”，而不是实际图像。各种图像类型之间存在一定的互操作性： 我们可以从 CGImage 创建 UIImage ，并从 UIImage 创建 CGImage 。我们可以从 UIImage 和 CGImage 创建 CIImage ，也可以从 CIImage 创建 CGImage 。我们可以从 UIImage 和 CGImage 创建一个 SwiftUI Image 。I know, I know: it’s confusing, but hopefully once you see the code you’ll feel better. What matters is that these image types are pure data – we can’t place them into a SwiftUI view hierarchy, but we can manipulate them freely then present the results in a SwiftUI Image. 我们将更改 loadImage() ，使其从我们的示例图像中创建一个 UIImage ，然后使用核心图像进行操作。更具体地说，我们将从两个任务开始： 我们需要将示例图像加载到一个 UIImage 中，该 UIImage 具有一个名为 UIImage(resource:) 的初始化程序，用于从我们的资源目录加载图像。我们将把它转换为 CIImage ，这是 Core Image 想要处理的内容。所以，首先用这个替换您当前的 loadImage() 实现： func loadImage() { let inputImage &#x3D; UIImage(resource: .example) let beginImage &#x3D; CIImage(image: inputImage) // more code to come }下一步将是创建一个核心图像上下文和一个核心图像滤镜。滤镜是实际执行转换图像数据工作的东西，比如模糊、锐化、调整颜色等，而上下文处理将处理后的数据转换为我们可以使用的 CGImage 。 这两种数据类型都来自核心图像，因此您需要添加两个导入才能使它们对我们可用。因此，请从在 ContentView.swift 顶部附近添加这些开始： import CoreImageimport CoreImage.CIFilterBuiltins接下来我们将创建上下文和滤镜。在这个示例中，我们将使用一个棕褐色调滤镜，它会应用一种棕色调，使照片看起来像是很久以前拍摄的。 所以，请用这个替换 &#x2F;&#x2F; more code to come 注释： let context &#x3D; CIContext()let currentFilter &#x3D; CIFilter.sepiaTone()我们现在可以自定义我们的滤镜以改变其工作方式。棕褐色是一个简单的滤镜，因此它只有两个有趣的属性： inputImage 是我们想要更改的图像， intensity 是应用棕褐色效果的强度，指定在范围 0（原始图像）和 1（完全棕褐色）之间。 因此，在前两行代码下面添加这两行代码： currentFilter.inputImage &#x3D; beginImagecurrentFilter.intensity &#x3D; 1这些都不是特别困难，但在这里发生变化：我们需要将来自过滤器的输出转换为我们可以在视图中显示的 SwiftUI Image 。这就是我们需要同时依赖所有四种图像类型的地方，因为最容易做的事情是： 从我们的过滤器中读取输出图像，这将是一个 CIImage 。这可能会失败，因此它返回一个可选项。要求我们的上下文从该输出图像中创建一个 CGImage 。这也可能失败，因此再次返回一个可选项。将 CGImage 转换为 UIImage 。将 UIImage 转换为 SwiftUI Image 。您可以直接从 CGImage 转换为 SwiftUI Image ，但需要额外的参数，这只会增加更多的复杂性！ 这是 loadImage() 的最终代码： &#x2F;&#x2F; get a CIImage from our filter or exit if that failsguard let outputImage &#x3D; currentFilter.outputImage else { return } &#x2F;&#x2F; attempt to get a CGImage from our CIImageguard let cgImage &#x3D; context.createCGImage(outputImage, from: outputImage.extent) else { return } &#x2F;&#x2F; convert that to a UIImagelet uiImage &#x3D; UIImage(cgImage: cgImage) &#x2F;&#x2F; and convert that to a SwiftUI imageimage &#x3D; Image(uiImage: uiImage)如果再次运行应用程序，您应该会看到您的示例图像现在应用了一个棕褐色效果，这都归功于核心图像。 现在，您可能会认为这是一项相当繁重的工作，只是为了获得一个相当简单的结果，但是现在您已经掌握了所有核心图像的基础知识，切换到不同的滤镜相对容易。 话虽如此，Core Image 有点…… 嗯…… 可以说是“创造性”的。它早在 iOS 5.0 中就被引入了，而那时 Swift 已经在苹果内部开发了，但你真的不会知道 - 在很长一段时间里，它的 API 是你能想象到的最不符合 Swift 风格的东西，尽管苹果已经慢慢地清理了它的混乱，但有时你别无选择，只能深入挖掘它的底层。 首先，让我们看一下现代 API - 我们可以用像这样的像素化滤镜来替换我们的棕褐色调： let currentFilter &#x3D; CIFilter.pixellate()currentFilter.inputImage &#x3D; beginImagecurrentFilter.scale &#x3D; 100当运行时，您会看到我们的图像呈像素化。100 的比例应该意味着像素横跨 100 个点，但由于我的图像太大，像素相对较小。 现在让我们尝试一下这样的水晶效果： let currentFilter &#x3D; CIFilter.crystallize()currentFilter.inputImage &#x3D; beginImagecurrentFilter.radius &#x3D; 200或者我们可以添加一个类似这样的旋转扭曲滤镜： let currentFilter &#x3D; CIFilter.twirlDistortion()currentFilter.inputImage &#x3D; beginImagecurrentFilter.radius &#x3D; 1000currentFilter.center &#x3D; CGPoint(x: inputImage.size.width &#x2F; 2, y: inputImage.size.height &#x2F; 2)因此，我们可以仅使用现代 API 来完成很多工作。但是对于这个项目，我们将使用旧的 API 来设置诸如 radius 和 scale 这样的值，因为它允许我们动态设置值 - 我们可以直接询问当前过滤器支持哪些值，然后将它们发送过去。 这是它的外观： let currentFilter &#x3D; CIFilter.twirlDistortion()currentFilter.inputImage &#x3D; beginImage let amount &#x3D; 1.0 let inputKeys &#x3D; currentFilter.inputKeys if inputKeys.contains(kCIInputIntensityKey) { currentFilter.setValue(amount, forKey: kCIInputIntensityKey) }if inputKeys.contains(kCIInputRadiusKey) { currentFilter.setValue(amount * 200, forKey: kCIInputRadiusKey) }if inputKeys.contains(kCIInputScaleKey) { currentFilter.setValue(amount * 10, forKey: kCIInputScaleKey) }有了这个设置，您现在可以将旋转失真更改为任何其他滤镜，代码将继续工作 - 只有在支持的情况下才会发送每个调整值。 请注意，这取决于为键设置值，这可能会让你想起 UserDefaults 的工作方式。实际上，所有这些 kCIInput 键都是作为字符串在后台实现的，所以它甚至比你意识到的更相似！ 如果您正在实施精确的 Core Image 调整，您应该绝对使用使用确切属性名称和类型的新 API，但在这个项目中，旧 API 也很有用，因为它允许我们发送调整，而不管实际使用的滤镜是什么。 使用 ContentUnavailableView 显示空状态SwiftUI 的 ContentUnavailableView 显示了一个标准的用户界面，用于当您的应用程序没有任何内容可显示时。我知道，这听起来有些多余，对吧？毕竟，如果没有内容可显示，那就是没有内容可显示！ 但是 ContentUnavailableView 非常适合在您的应用程序依赖尚未提供的用户信息的情况下使用，例如当用户尚未创建任何数据，或者当他们正在搜索某些内容但没有结果时。 例如，如果您正在开发一个应用程序，让用户记录他们想要记住的 Swift 代码片段，它可能默认不包含任何代码片段。因此，您可以像这样使用 ContentUnavailableView ： ContentUnavailableView(“No snippets”, systemImage: “swift”)这将显示一个来自 SF Symbols 的大 Swift 图标，下方的标题文本显示为“无片段”。 您还可以添加一行额外的描述文本，指定为 Text 视图，以便您可以添加额外的样式，如自定义字体或自定义颜色： ContentUnavailableView(“No snippets”, systemImage: “swift”, description: Text(“You don’t have any saved snippets yet.”))如果您想要完全控制，您可以为标题和描述提供单独的视图，以及一些按钮来显示，以帮助用户开始使用： ContentUnavailableView { Label(“No snippets”, systemImage: “swift”)} description: { Text(“You don’t have any saved snippets yet.”)} actions: { Button(“Create Snippet”) { &#x2F;&#x2F; create a snippet } .buttonStyle(.borderedProminent)}这是一个非常简单易用的视图，比起用户第一次打开应用时只显示空白屏幕要好得多！ 从用户的照片库加载照片SwiftUI 的 PhotosPicker 视图为我们提供了一种简单的方式从用户的相册中导入一张或多张照片。为了避免造成任何性能问题,数据以一种称为 PhotosPickerItem 的特殊类型提供给我们,我们可以异步加载它,将数据转换为 SwiftUI 图像。 这总共需要五个步骤,首先是添加一个 PhotosUI 的 import,与你的常规 SwiftUI import 一起,像这样: import PhotosUIimport SwiftUI其次，我们需要创建两个属性：一个用于存储被选择的项目，另一个用于将该选择的项目存储为 SwiftUI 图像。这种区别很重要,因为选择的项目只是用户照片库中照片的引用,直到我们实际要求将其加载。 加这两个现在: @State private var pickerItem: PhotosPickerItem?@State private var selectedImage: Image?第三步是在你的 SwiftUI 视图层次结构中添加一个 PhotosPicker 视图。这必须创建一个标题来向用户显示, 一个绑定来存储所选的图像, 以及要显示的数据类型 - 最后一部分允许我们使用 PhotosPicker 来加载视频、实时照片和更多内容。 将当前视图的 body 属性替换为以下内容: VStack { PhotosPicker(“Select a picture”, selection: $pickerItem, matching: .images)}提示:这是有意在 VStack 中的 - 我们稍后会详细讨论这一点。 第四步是监视 pickerItem 的变化,因为当它发生变化时意味着用户已选择一张图片让我们加载。完成这一步后,我们就可以在拾取器项目上调用 loadTransferable(type:) ,这是一种告诉 SwiftUI 我们希望从拾取器项目中加载实际的基础数据到 SwiftUI 图像的方法。如果成功,我们就可以将得到的值赋给 selectedImage 属性。 将此修饰符添加到 VStack 中: .onChange(of: pickerItem) { Task { selectedImage &#x3D; try await pickerItem?.loadTransferable(type: Image.self) }}提示：调用 loadTransferable(type:) 可能需要数秒钟才能完成，尤其是对于大型图片如全景图。 现在第五步是将加载的 SwiftUI 图像显示在某个位置。将其添加到 VStack 中,可以放在 PhotosPicker 之前或之后: selectedImage? .resizable() .scaledToFit()现在尝试一下吧!模拟器带有几个内置图像,您可以用它们进行测试。如果选择其中一个,您应该会在 Image 视图中看到它被加载并显示在屏幕上。 有许多其他方式 PhotosPicker 可以使用,这取决于您的需求。例如,您可以将它传递给一个拾取器项目数组的绑定,并让用户选择多个。这意味着创建一个作为属性的拾取器项目数组: @State private var pickerItems &#x3D; PhotosPickerItem然后像以前一样传递该数组: PhotosPicker(“Select images”, selection: $pickerItems, matching: .images)更困难的部分是处理这些图像,然后以某种方式显示它们,因为我们不能再观看单个照片选择器项目。 相反,您应该创建一个数组来存储加载的图像,像这样: @State private var selectedImages &#x3D; Image然后使用 ForEach 或类似的方式显示它们,像这样: ScrollView { ForEach(0..&lt;selectedImages.count, id: .self) { i in selectedImages[i] .resizable() .scaledToFit() }}最后更新您的 onChange() ，以便在选择新项目时清除该数组，然后单独加载新的集合 .onChange(of: pickerItems) { Task { selectedImages.removeAll() for item in pickerItems &#123; if let loadedImage = try await item.loadTransferable(type: Image.self) &#123; selectedImages.append(loadedImage) &#125; &#125; &#125; }如果您允许用户选择多张照片,我建议您通过添加 maxSelectionCount 参数来限制一次最多可选择的照片数量,如下所示: PhotosPicker(“Select images”, selection: $pickerItems, maxSelectionCount: 3, matching: .images)有两种最后的方式可以自定义照片导入,首先是标签。与许多 SwiftUI 视图一样,如果您愿意,您可以提供完全自定义的标签,这可能是一个 Label 视图或完全自定义的内容。 PhotosPicker(selection: $pickerItems, maxSelectionCount: 3, matching: .images) { Label(“Select a picture”, systemImage: “photo”)}最后一种方式是限制可以导入的图片类型。我们在这里全部使用 .images ，这意味着我们将获得常规照片、屏幕截图、全景图等。您可以使用 .any() 、 .all() 和 .not() 应用更高级的过滤器，并传递一个数组。例如，这将匹配除屏幕截图之外的所有图像： PhotosPicker(selection: $pickerItems, maxSelectionCount: 3, matching: .any(of: [.images, .not(.screenshots)])) { Label(“Select a picture”, systemImage: “photo”)} 如何让用户使用分享链接分享内容SwiftUI 的 ShareLink 视图允许用户从我们的应用中导出内容以进行分享，例如将图片保存到他们的照片库，使用信息应用程序将链接发送给朋友等等。 我们提供我们想要分享的内容，iOS 会显示所有可以处理我们发送的数据的应用。例如，我们可以分享以下 URL： ## Additional Notes: * The source text is already concise, and the translated version is also direct and to the point. * The meaning of the text is accurately conveyed in the translation. ShareLink(item: URL(string: “https://www.hackingwithswift.com“)!)这将创建一个带有“分享”图标的按钮，点击它将打开 iOS 分享面板。如果您使用的是模拟器，您将只看到一些示例内容，其中一些甚至可能无法正常工作，但如果您使用的是真机，您将看到您可以正常分享该 URL。 如果您希望对数据有更多控制，您可以选择以下几种方式。 首先，您可以像这样将主题和消息附加到共享数据： ShareLink(item: URL(string: “https://www.hackingwithswift.com“)!, subject: Text(“Learn Swift here”), message: Text(“Check out the 100 Days of SwiftUI!”))这些信息如何使用取决于应用程序的用户分享给谁——URL 将始终附加，因为它是最重要的。但是，有些应用程序将使用主题，有些将使用消息，还有一些将同时使用两者。 其次，您可以通过提供您想要的任何标签来自定义按钮本身： ShareLink(item: URL(string: “https://www.hackingwithswift.com“)!) { Label(“Spread the word about Swift”, systemImage: “swift”)}您可以提供一个预览附件，这对于分享更复杂内容非常重要，因为您可以在此处分享完全自定义的数据，因此预览可以帮助收件人了解内容。 令人讨厌的是，即使对于作为其自身预览的数据（例如图像）也需要这样做。为了避免使您的代码重复，我建议将图像分配给一个局部常量，然后使用它： let example &#x3D; Image(.example) ShareLink(item: example, preview: SharePreview(“Singapore Airport”, image: example)) { Label(“Click to share”, systemImage: “airplane”)}让用户分享来自您应用的数据非常重要，因为没有它，您的数据就会与他们的其他生活隔绝！ 如何要求用户留下 App Store 评论SwiftUI 提供了一个名为 .requestReview 的特殊环境键，让我们可以要求用户在 App Store 上为我们的应用程序留下评论。苹果负责显示整个用户界面，确保如果用户已经留下评论，则不会显示，并且还限制请求显示的频率 - 我们只需要在准备好时发出请求。 这个过程分为三个步骤，从为 StoreKit 导入新内容开始： import StoreKit第二步，您需要添加一个属性来从 SwiftUI 的环境中读取审阅请求者： @Environment(.requestReview) var requestReview第三，当您准备好时，需要请求审查。当您刚开始时，您可能会认为将审查附加到按钮按下是一个好主意，就像这样： Button(“Leave a review”) { requestReview()}然而，这远非理想，至少因为我们只是请求显示一个审查提示 - 用户可能已在整个系统中禁用了这些警报，或者他们可能已经达到了允许的审查请求的最大数量，在这种情况下，您的按钮将无效。 相反，最好在您认为是正确时机时自动调用 requestReview() 。一个很好的起点是当用户已经完成了一些重要任务的次数，因为这样可以清楚地表明他们已经意识到您的应用程序的好处。 开始构建构建我们的基本用户界面我们项目的第一步是构建基本用户界面，对于这个应用程序来说将是： 一个 NavigationStack ，这样我们就可以在顶部显示我们应用程序的名称。一个提示用户选择照片的框，我们将在其上放置他们导入的图片。一个“强度”滑块，将影响我们应用核心图像滤镜的强度，存储为从 0.0 到 1.0 的值。一个分享按钮，用于从应用程序中导出处理过的图像。我们不会一开始就把所有这些位放在一起；只放足够的部分让您看到事物是如何组合在一起的。 最初用户尚未选择图像，因此我们将使用 @State 可选图像属性来表示。 首先将这两个属性添加到 ContentView ： @State private var processedImage: Image?@State private var filterIntensity &#x3D; 0.5现在将其 body 属性的内容修改为这样： NavigationStack { VStack { Spacer() // image area Spacer() HStack &#123; Text(&quot;Intensity&quot;) Slider(value: $filterIntensity) &#125; .padding(.vertical) HStack &#123; Button(&quot;Change Filter&quot;) &#123; // change filter &#125; Spacer() // share the picture &#125; &#125; .padding([.horizontal, .bottom]) .navigationTitle(&quot;Instafilter&quot;) }使用两个间距，以便我们始终在图像区域上方和下方获得空间，这也确保滤镜控件始终固定在屏幕底部。 关于应该放在 &#x2F;&#x2F; image area 注释位置的内容，将是以下两种情况之一：如果我们已经选择了一张图片，那么我们应该展示它，否则我们将显示一个简单的 ContentUnavailableView ，以便用户知道这个空间不是无意间留空的 if let processedImage { processedImage .resizable() .scaledToFit()} else { ContentUnavailableView(“No Picture”, systemImage: “photo.badge.plus”, description: Text(“Tap to import a photo”))}我喜欢能够将可选视图放置在 SwiftUI 布局中，并且我认为它与 ContentUnavailableView 特别配合得很好，因为一次只有一个是可见的。是的，点击视图目前不会有任何作用，但我们很快会解决这个问题。 现在，由于我们的代码在这里相当简单，我想简要探讨一下清理一下我们的 body 属性是什么样子的 - 我们在那里有很多布局代码，但里面也有一个按钮操作。 是的，更改过滤器按钮内部不会有很多复杂功能，但这是将按钮操作拆分的良好实践。 现在这意味着向 ContentView 添加一个空方法，就像这样： func changeFilter() {}然后从“更改过滤器”按钮中调用它，就像这样： Button(“Change Filter”, action: changeFilter)当你在学习时，直接在视图中编写按钮操作和类似内容是非常常见的，但一旦你开始进行真实项目，花额外时间保持代码整洁是个好主意 - 这会让你的生活在长期内变得更轻松，相信我！ 我将会继续添加类似这样的小清理技巧，以便在您接近课程结束时，您会越来越有信心，您的代码质量良好。 使用 PhotosPicker 将图像导入 SwiftUI为了让这个项目变为现实，我们需要让用户从他们的库中选择一张照片，然后在 ContentView 中显示它。这需要一点思考，主要是因为 Core Image 的工作方式与 SwiftUI 相比有些绕。 首先，我们需要在 ContentView 的顶部添加一个 PhotosUI 导入，然后给它添加一个额外的 @State 属性来跟踪用户选择的任何图片： @State private var selectedItem: PhotosPickerItem?其次，我们需要在想要触发图像选择的位置放置一个 PhotosPicker 视图。在这个应用中，我们实际上可以在整个 if let processedImage 检查周围放置一个视图 - 我们可以使用所选图像或 ContentUnavailableView 作为 PhotosPicker 的标签。 这是它的外观： PhotosPicker(selection: $selectedItem) { if let processedImage { processedImage .resizable() .scaledToFit() } else { ContentUnavailableView(“No Picture”, systemImage: “photo.badge.plus”, description: Text(“Import a photo to get started”)) }}提示：这会向 ContentUnavailableView 添加蓝色着色，以表示它是可交互的，但如果您喜欢，您可以通过向 PhotosPicker 添加 .buttonStyle(.plain) 来禁用该功能。 第三，我们需要一个在选择了图像后将被调用的方法。 之前我向您展示了如何从 PhotosPicker 选择加载数据，另外我也向您展示了如何将 UIImage 馈送到核心图像进行过滤。在这里，我们需要将这两件事情结合起来：我们无法加载一个简单的 SwiftUI 图像，因为它们无法被馈送到核心图像，所以我们加载一个纯 Data 对象，然后将其转换为 UIImage 。 现在将此方法添加到 ContentView 中： func loadImage() { Task { guard let imageData &#x3D; try await selectedItem?.loadTransferable(type: Data.self) else { return } guard let inputImage &#x3D; UIImage(data: imageData) else { return } // more code to come &#125; }我们可以在 ContentView 的某个地方附加一个 onChange() 修饰符，这样每当我们的 selectedItem 属性发生变化时，就可以调用它 - 实际上，附加到 PhotosPicker 似乎是明智的。 .onChange(of: selectedItem, loadImage)请继续运行该应用程序 - 尽管它实际上不会对您的选择做太多事情，但您至少可以打开照片选择界面并浏览选项。 使用核心图像进行基本图像过滤现在我们的项目已经有了用户选择的图像，下一步是让用户对其应用不同的核心图像滤镜。首先，我们将只使用一个滤镜，但很快我们将使用确认对话框来扩展功能。 如果我们想在我们的应用程序中使用核心图像，我们首先需要在 ContentView.swift 的顶部添加两个导入： import CoreImageimport CoreImage.CIFilterBuiltins接下来，我们需要一个上下文和一个滤镜。Core Image 上下文是一个负责将 CIImage 渲染为 CGImage 的对象，或者更实际的说法是将图像的配方转换为我们可以处理的实际像素系列的对象。 上下文的创建成本很高，因此，如果您打算渲染许多图像，最好是创建一个上下文并保持其活动状态。至于过滤器，我们将使用 CIFilter.sepiaTone() 作为默认值，但由于稍后我们将使其更灵活，所以我们将使过滤器使用 @State ，以便进行更改。 因此，请将这两个属性添加到 ContentView ： @State private var currentFilter &#x3D; CIFilter.sepiaTone()let context &#x3D; CIContext()有了这两个设置，我们现在可以编写一个方法来处理导入的任何图像 - 这意味着它将根据 filterIntensity 中的值设置我们的深褐色滤镜的强度，从滤镜中读取输出图像，要求我们的 CIContext 来渲染它，然后将结果放入我们的 processedImage 属性中，以便在屏幕上显示。 func applyProcessing() { currentFilter.intensity &#x3D; Float(filterIntensity) guard let outputImage = currentFilter.outputImage else &#123; return &#125; guard let cgImage = context.createCGImage(outputImage, from: outputImage.extent) else &#123; return &#125; let uiImage = UIImage(cgImage: cgImage) processedImage = Image(uiImage: uiImage) }提示：遗憾的是，古铜色调滤镜背后的核心图像希望值为 Float 而不是 Double 。这让核心图像感觉更老了，我知道，但不要担心 - 我们很快就会让它消失！ 下一个任务是改变 loadImage() 的工作方式。现在它以 &#x2F;&#x2F; more code to come 注释结束，但实际上它应该将选择的任何图像发送到棕褐色调滤镜中，然后调用 applyProcessing() 来实现魔法。 核心图像滤镜有一个专用的 inputImage 属性，让我们发送一个 CIImage 给滤镜使用，但通常这会彻底破坏并导致应用程序崩溃 - 使用滤镜的 setValue() 方法与关键 kCIInputImageKey 更安全。 所以，请用这个替换 &#x2F;&#x2F; more code to come 注释： let beginImage &#x3D; CIImage(image: inputImage)currentFilter.setValue(beginImage, forKey: kCIInputImageKey)applyProcessing()如果现在运行代码，您会看到我们的基本应用程序流程运行良好：我们可以选择一张图片，然后看到它应用了一个深褐色效果。但是我们添加的强度滑块没有任何作用，尽管它绑定到与我们的滤镜正在读取的相同 filterIntensity 值。 这里发生的事情不应该太令人惊讶：即使滑块正在改变 filterIntensity 的值，改变该属性不会自动再次触发我们的 applyProcessing() 方法。相反，我们需要通过手动告诉 SwiftUI 用 onChange() 监视 filterIntensity 来实现这一点。 再次，这些 onChange() 修饰符可以放在我们的 SwiftUI 视图层次结构的任何位置，但由于滑块直接更改值，我会将其附加在那里： Slider(value: $filterIntensity) .onChange(of: filterIntensity, applyProcessing)提示：如果多个视图调整相同的值，或者不太确定是什么在改变该值，那么我会在视图的末尾添加修饰符。 你现在可以运行应用程序了，但要警告你：尽管 Core Image 在所有 iPhone 上非常快，但在模拟器上通常非常慢。这意味着你可以尝试运行它以确保一切正常，但如果你的代码运行速度极慢也不要感到惊讶。 使用 confirmationDialog()自定义我们的过滤器到目前为止，我们已经将 SwiftUI 和 Core Image 结合在一起，但该应用程序仍然不是很有用——毕竟，棕褐色调效果并不是那么有趣。 为了使整个应用程序变得更好，我们将让用户自定义他们想要应用的过滤器，我们将使用确认对话框来完成此操作。在 iPhone 上，这是一个从屏幕底部向上滑动的按钮列表，您可以添加任意数量的按钮 - 如果您确实需要，它甚至可以滚动。 首先，我们需要一个属性来存储是否应显示确认对话框，因此将其添加到 ContentView ： @State private var showingFilters &#x3D; false现在我们可以使用 confirmationDialog() 修饰符添加按钮。这与 alert() 的工作原理相同：我们提供要监视的标题和条件，一旦条件变为真，就会显示确认对话框。 首先在导航标题下方添加此修饰符： .confirmationDialog(“Select a filter”, isPresented: $showingFilters) { &#x2F;&#x2F; dialog here}现在用以下内容填充 changeFilter() 方法： showingFilters &#x3D; true关于在确认对话框中显示的内容，我们可以创建一组要显示的按钮和一条可选消息。这些按钮的工作方式与 alert() 类似：我们提供文本标题和选择时要运行的操作。 对于此应用程序中的确认对话框，我们希望用户从一系列不同的 Core Image 过滤器中进行选择，当他们选择一个过滤器时，应该激活并立即应用它。为了完成这项工作，我们将编写一个方法，将 currentFilter 修改为他们选择的任何新过滤器，然后立即调用 loadImage() 。 我们的计划有一个问题，这是 Apple 包装 Core Image API 以使它们对 Swift 更友好的方式造成的。你看，底层的 Core Image API 完全是字符串类型的——它使用字符串来设置值，而不是固定的属性——所以苹果并没有发明所有新的类来让我们使用，而是创建了一系列协议。 当我们将 CIFilter.sepiaTone() 分配给属性时，我们会得到 CIFilter 类的对象，该对象恰好符合名为 CISepiaTone 的协议。然后该协议公开我们一直在使用的 intensity 参数，但在内部它只会将其映射到对 setValue(_:forKey:) 的调用。 这种灵活性实际上对我们有利，因为它意味着我们可以编写适用于所有过滤器的代码，只要我们小心不要发送无效值即可。 那么，让我们开始解决问题吧。请将您的 currentFilter 属性更改为： @State private var currentFilter: CIFilter &#x3D; CIFilter.sepiaTone()因此， CIFilter.sepiaTone() 返回一个符合 CISepiaTone 协议的 CIFilter 对象。添加显式类型注释意味着我们将丢弃一些数据：我们说过滤器必须是 CIFilter 但不必再符合 CISepiaTone 。 由于此更改，我们失去了对 intensity 属性的访问权限，这意味着此代码将不再有效： currentFilter.intensity &#x3D; Float(filterIntensity)相反，我们需要将其替换为对 setValue(:_forKey:) 的调用。无论如何，这就是协议所做的全部事情，但它确实提供了有价值的额外类型安全性。 将那行断线的代码替换为： currentFilter.setValue(filterIntensity, forKey: kCIInputIntensityKey)kCIInputIntensityKey 是另一个Core Image常量值，它与设置棕褐色色调滤镜的 intensity 参数具有相同的效果。 完成此更改后，我们可以返回确认对话框：我们希望能够将该过滤器更改为其他内容，然后调用 loadImage() 重置所有内容并应用初始处理。因此，将此方法添加到 ContentView 中： func setFilter(_ filter: CIFilter) { currentFilter &#x3D; filter loadImage()}提示：这意味着每次过滤器更改时都会触发图像加载。如果您想让运行速度更快一点，可以将 beginImage 存储在另一个 @State 属性中，以避免每次过滤器更改时重新加载图像。 完成后，我们现在可以用一系列尝试各种 Core Image 过滤器的按钮替换 &#x2F;&#x2F; dialog here 注释。 把它放在它的位置： Button(“Crystallize”) { setFilter(CIFilter.crystallize()) }Button(“Edges”) { setFilter(CIFilter.edges()) }Button(“Gaussian Blur”) { setFilter(CIFilter.gaussianBlur()) }Button(“Pixellate”) { setFilter(CIFilter.pixellate()) }Button(“Sepia Tone”) { setFilter(CIFilter.sepiaTone()) }Button(“Unsharp Mask”) { setFilter(CIFilter.unsharpMask()) }Button(“Vignette”) { setFilter(CIFilter.vignette()) }Button(“Cancel”, role: .cancel) { }我从大量的核心图像过滤器中挑选了这些过滤器，但欢迎您尝试使用代码完成来尝试其他东西 - 输入 CIFilter. 并看看会出现什么！ 继续运行应用程序，选择一张图片，然后尝试将棕褐色色调更改为晕影 - 这会在照片边缘周围应用变暗效果。 （如果您使用模拟器，请记住给它一点时间，因为它很慢！） 现在尝试将其更改为高斯模糊，这应该会模糊图像，但会导致我们的应用程序崩溃。通过放弃过滤器的 CISepiaTone 限制，我们现在被迫使用 setValue(_:forKey:) 发送值，这根本不提供安全性。在这种情况下，高斯模糊滤镜没有强度值，因此应用程序会崩溃。 为了解决这个问题 - 也为了让我们的单个滑块做更多的工作 - 我们将添加一些更多的代码来读取我们可以与 setValue(_:forKey:) 一起使用的所有有效键，并且仅在以下情况下设置强度键当前过滤器支持它。使用这种方法，我们实际上可以查询任意数量的键，并设置所有支持的键。因此，对于棕褐色调，这将设置强度，但对于高斯模糊，它将设置半径（模糊的大小），依此类推。 这种条件方法适用于您选择应用的任何过滤器，这意味着您可以安全地与其他过滤器进行实验。您唯一需要注意的是确保将 filterIntensity 放大一个有意义的数字 - 例如，1 像素模糊几乎是不可见的，所以我将乘以它200 使其更加明显。 替换这一行： currentFilter.setValue(filterIntensity, forKey: kCIInputIntensityKey) 有了这个： let inputKeys &#x3D; currentFilter.inputKeys if inputKeys.contains(kCIInputIntensityKey) { currentFilter.setValue(filterIntensity, forKey: kCIInputIntensityKey) }if inputKeys.contains(kCIInputRadiusKey) { currentFilter.setValue(filterIntensity * 200, forKey: kCIInputRadiusKey) }if inputKeys.contains(kCIInputScaleKey) { currentFilter.setValue(filterIntensity * 10, forKey: kCIInputScaleKey) }完成后，您现在可以安全地运行应用程序，导入您选择的图片，然后尝试所有各种过滤器 - 不会再出现任何崩溃。尝试尝试不同的过滤器和键，看看你能找到什么！ 使用 ShareLink 共享图像为了完成这个项目，我们将添加两个更重要的功能：让用户使用 SwiftUI 的 ShareLink 视图分享他们的图像，然后添加一个提示，鼓励他们在 App Store 上查看我们的应用程序 – 一旦当然，已经过去了适当的时间。 这些都没有挑战性，所以让我们直接进入代码。 SwiftUI 的 ShareLink 按钮让我们只需一行代码即可共享文本、URL 和图像等内容，并且它会自动使用系统标准共享表，以便用户看到支持该功能的所有应用程序。我们发送的数据。 在我们的例子中，我们已经有一个 &#x2F;&#x2F; share the picture 注释，但需要将其替换为检查是否有要共享的图像，如果有，则需要一个 ShareLink 按钮使用它。 将评论替换为： if let processedImage { ShareLink(item: processedImage, preview: SharePreview(“Instafilter image”, image: processedImage))}这已经是完成的第一步，但请记住在真实设备上尝试，以便您可以看到各种真实应用程序如何响应图像。 现在剩下的就是要求用户评论我们的应用程序。请记住，只有在用户真正感受到应用程序的好处之后才最好显示这一点，因为如果您问得太早，他们更有可能忽略该请求。 因此，我们不会总是显示请求，而是要等到用户更改过滤器至少 20 次——这足以让他们不止一次地浏览所有选项，所以希望他们很乐意提供帮助回顾。 首先，我们需要添加两个新属性：一个用于从 SwiftUI 环境获取审阅者请求者，另一个用于跟踪发生了多少个过滤器更改。添加另一个导入到 ContentView.swift，这次是 StoreKit，然后将这两个属性添加到 ContentView&#96;： @AppStorage(“filterCount”) var filterCount &#x3D; 0@Environment(.requestReview) var requestReview现在我们需要在 setFilter() 方法的末尾添加一些代码，以便为每个过滤器更改增加 filterCount ，然后在至少有 20 个过滤器更改时激活审核请求。将其放在方法的末尾： filterCount +&#x3D; 1 if filterCount &gt;&#x3D; 20 { requestReview()}这将在 Xcode 中触发错误：请求审核必须在 Swift 的主要参与者上完成，这是我们应用程序中能够与用户界面配合使用的部分。尽管我们目前正在 SwiftUI 视图中编写代码，但 Swift 无法保证此代码将在主要参与者上运行，除非我们特别强制这样做。 这听起来很复杂，但实际上它只是意味着将方法更改为： @MainActor func setFilter(_ filter: CIFilter) {现在，Swift 将确保代码始终在主要参与者上运行，并且编译错误将消失。 提示：出于测试目的，您或许应该将审核条件从 20 个更改为 5 个左右，以确保您的代码按照您期望的方式工作！ 最后一步完成了我们的应用程序，因此请继续再次运行它并从头到尾尝试 - 导入图片，应用过滤器，然后将其共享到其他应用程序。做得好！ 总结们在本教程中介绍了很多内容，尤其是了解如何依靠 Core Image 等强大的框架来引入令人印象深刻的图形效果。是的，它从未顺利过渡到 Swift - 如果您想充分利用它，您需要知道它的怪癖。不过，您现在已经度过了最糟糕的时期，所以希望您可以尝试在自己的代码中使用它！ 同时，我们还学习了一些很棒的 SwiftUI 东西，包括确认对话框、 onChange() 、 ContentUnavailableView 和 App Store 评论，所有这些都非常常见并且将继续有用未来几年。 回顾你所学到的内容任何人都可以听完教程，但需要实际工作才能记住所教的内容。我的工作是确保您从这些教程中获得尽可能多的知识，因此我准备了一篇简短的评论来帮助您检查您的学习情况。 单击此处查看您在此项目中学到的内容。 挑战最好的学习方法之一是尽可能多地编写自己的代码，因此您应该尝试扩展此应用程序，以确保您完全理解正在发生的事情，可以通过以下三种方法。 如果没有选择图像，请尝试禁用“滑块”和“更改过滤器”按钮。尝试使用多个滑块来控制您关心的每个输入键。例如，您可能有一个用于半径，一个用于强度。探索可用的 Core Image 滤镜范围，并将您选择的任意三个添加到应用程序中。提示：最后一个可能比您预期的要棘手一些。为什么？也许想一下 10 秒钟！","categories":[{"name":"技术","slug":"技术","permalink":"https://blog.five2fire.top/categories/%E6%8A%80%E6%9C%AF/"}],"tags":[{"name":"编程","slug":"编程","permalink":"https://blog.five2fire.top/tags/%E7%BC%96%E7%A8%8B/"},{"name":"Swift","slug":"Swift","permalink":"https://blog.five2fire.top/tags/Swift/"},{"name":"Hacking with Swift","slug":"Hacking-with-Swift","permalink":"https://blog.five2fire.top/tags/Hacking-with-Swift/"}]},{"title":"【Hacking With Swift】Project12_SwiftData","slug":"Project12_SwiftData","date":"2024-07-07T03:12:25.000Z","updated":"2025-01-02T02:17:10.813Z","comments":true,"path":"article/10671.html","permalink":"https://blog.five2fire.top/article/10671.html","excerpt":"","text":"英文原博博主是 Paul Hudson @twostraws 本文是学习Swift过程中翻译该网站的内容: https://www.hackingwithswift.com/ 简介本技术项目将更详细地探索 SwiftData，从总结一些基本技术开始，逐步解决一些更复杂的问题。 正如您所看到的，SwiftData 着实推动了 Swift 和 SwiftUI 的高级功能，这一切都有助于我们轻松高效地存储数据。不过，这并不总是那么容易，有几处地方需要花点心思才能正确使用。 我们有很多东西要探索，所以请创建一个新项目，让我们可以尝试一下。请将其命名为 “SwiftDataProject”，而不仅仅是 “SwiftData”，因为这会导致 Xcode 混淆。 确保不启用 SwiftData 存储。同样，我们将从头开始构建，这样你就能看到它是如何工作的。 准备好了吗？我们走吧 编辑 SwiftData 模型对象SwiftData 的模型对象由与 @Observable 类相同的观察系统提供支持，这意味着 SwiftUI 会自动接收模型对象的更改，从而使我们的数据和用户界面保持同步。 这种支持扩展到了我们之前看过的 @Bindable 属性包装器，这意味着我们可以获得令人愉悦的直接对象编辑。 为了演示这一点，我们可以创建一个带有少量属性的简单 User 类。创建一个名为 User.swift 的新文件，在顶部为 SwiftData 添加一个导入，然后编写以下代码： @Modelclass User { var name: String var city: String var joinDate: Date init(name: String, city: String, joinDate: Date) &#123; self.name = name self.city = city self.joinDate = joinDate &#125; }现在，我们可以通过在 App 结构文件中添加另一个 import SwiftData ，然后像这样使用 modelContainer() 来创建模型容器和模型上下文： WindowGroup { ContentView()}.modelContainer(for: User.self)在编辑 User 对象时，我们会创建一个新视图，名为 EditUserView ，然后使用 @Bindable 属性包装器为其创建绑定。因此，可以这样做 struct EditUserView: View { @Bindable var user: User var body: some View &#123; Form &#123; TextField(&quot;Name&quot;, text: $user.name) TextField(&quot;City&quot;, text: $user.city) DatePicker(&quot;Join Date&quot;, selection: $user.joinDate) &#125; .navigationTitle(&quot;Edit User&quot;) .navigationBarTitleDisplayMode(.inline) &#125; }这与我们使用普通 @Observable 类的方式完全相同，但 SwiftData 仍会自动将所有更改写入永久存储中，这对我们来说完全透明。 重要提示：如果您想使用 Xcode 的预览，则需要传递一个示例对象，这意味着需要创建一个自定义配置和容器。首先为 SwiftData 添加一个导入，然后将预览更改为这样： #Preview { do { let config &#x3D; ModelConfiguration(isStoredInMemoryOnly: true) let container &#x3D; try ModelContainer(for: User.self, configurations: config) let user &#x3D; User(name: “Taylor Swift”, city: “Nashville”, joinDate: .now) return EditUserView(user: user) .modelContainer(container) } catch { return Text(“Failed to create container: (error.localizedDescription)”) }}我们可以用它来制作一个非常简单的用户编辑应用程序，在按下按钮时添加一个新用户，然后使用编程导航将应用程序直接转到新用户处进行编辑。 让我们一步一步来构建它。首先，打开 ContentView.swift 并导入 SwiftData，然后添加属性以访问模型上下文，加载我们所有的 User 对象，然后存储我们可以绑定到 NavigationStack 的路径： @Environment(.modelContext) var modelContext@Query(sort: \\User.name) var users: [User]@State private var path &#x3D; User用此属性替换默认的 body 属性： NavigationStack(path: $path) { List(users) { user in NavigationLink(value: user) { Text(user.name) } } .navigationTitle(“Users”) .navigationDestination(for: User.self) { user in EditUserView(user: user) }}现在我们只需要一种添加用户的方法。仔细想想，添加和编辑是非常相似的，所以最简单的方法就是创建一个新的 User 对象（属性为空），将其插入到模型上下文中，然后通过调整 path 属性立即导航到该对象。 在两个导航修改器下方添加这个额外的修改器： .toolbar { Button(“Add User”, systemImage: “plus”) { let user &#x3D; User(name: “”, city: “”, joinDate: .now) modelContext.insert(user) path &#x3D; [user] }}这也行得通！事实上，这与苹果公司自己的便签应用所采用的方法基本相同，不过他们增加了一个额外的步骤，即如果你退出编辑视图而没有实际添加任何文字，便会自动删除便签。 正如您所看到的，使用 SwiftData 对象进行编辑与编辑常规的 @Observable 类没有什么不同，只是多了一个额外的好处，那就是我们的所有数据都能整齐地加载和保存！ 使用谓词过滤 @Query您已经看到 @Query 如何用于按特定顺序对 SwiftData 对象进行排序，但它还可以用于使用谓词过滤数据，谓词是应用于数据的一系列测试，用于决定返回什么数据。 这个语法一开始有点奇怪，主要是因为这实际上是另一个幕后宏–Swift 将我们的谓词代码转换成一系列规则，并应用到存储所有 SwiftData 对象的底层数据库中。 让我们从简单的开始，使用我们之前使用过的同一个 User 模型： @Modelclass User { var name: String var city: String var joinDate: Date init(name: String, city: String, joinDate: Date) &#123; self.name = name self.city = city self.joinDate = joinDate &#125; }现在，我们可以在 ContentView 中添加几个属性，以显示我们拥有的所有用户： @Environment(.modelContext) var modelContext@Query(sort: \\User.name) var users: [User]最后，我们可以在列表中显示所有这些用户，我们还将添加一个按钮，以便轻松添加一些样本数据： NavigationStack { List(users) { user in Text(user.name) } .navigationTitle(“Users”) .toolbar { Button(“Add Samples”, systemImage: “plus”) { let first &#x3D; User(name: “Ed Sheeran”, city: “London”, joinDate: .now.addingTimeInterval(86400 * -10)) let second &#x3D; User(name: “Rosa Diaz”, city: “New York”, joinDate: .now.addingTimeInterval(86400 * -5)) let third &#x3D; User(name: “Roy Kent”, city: “London”, joinDate: .now.addingTimeInterval(86400 * 5)) let fourth &#x3D; User(name: “Johnny English”, city: “London”, joinDate: .now.addingTimeInterval(86400 * 10)) modelContext.insert(first) modelContext.insert(second) modelContext.insert(third) modelContext.insert(fourth) &#125; &#125; }提示：这些连接日期代表过去或未来的天数，这为我们提供了一些有趣的数据。 在使用这样的样本数据时，在添加样本数据之前删除现有数据会很有帮助。为此，请在 let first &#x3D; 行之前添加以下代码： try? modelContext.delete(model: User.self)这就告诉 SwiftData 告知所有现有的 User 类型的模型对象，也就是说，在我们添加示例用户之前，数据库已经清空。 最后，我们只需确保 App 结构使用 modelContainer() 修改器来正确设置 SwiftData： WindowGroup { ContentView()}.modelContainer(for: User.self)现在继续运行应用程序，然后按 “+”按钮插入四个用户。 你可以看到它们是按字母顺序排列的，因为这是我们在 @Query 属性中要求的。 现在，让我们试着过滤这些数据，以便只显示姓名中包含大写字母 R 的用户。为此，我们向 @Query 传递一个 filter 参数，如下所示： @Query(filter: #Predicate { user in user.name.contains(“R”)}, sort: \\User.name) var users: [User]让我们来分析一下： 过滤器以 #Predicate 开头，这意味着我们要编写一个谓词（一个花哨的词，表示我们要进行的测试）。该谓词为我们提供了一个要检查的用户实例。实际上，SwiftData 加载的每个用户都会被调用一次，如果结果中包含该用户，我们就需要返回 true。我们的测试将检查用户姓名中是否包含大写字母 R。因此，当你现在运行代码时，你会发现 Rosa 和 Roy 都出现在我们的列表中，但 Ed 和 Johnny 却被排除在外，因为他们的名字不包含大写的 R。 contains() 方法是大小写敏感的：它认为大写的 R 和小写的 R 是不同的，这就是为什么它找不到 “Ed Sheeran “中的 “r”。 这对于简单的谓词测试非常有效，但很少有用户真正关心大写字母–他们通常只想写几个字母，然后在结果中的任何地方查找匹配，而忽略大小写。 为此，iOS 提供了一个单独的方法 localizedStandardContains() 。该方法也需要搜索一个字符串，但它会自动忽略字母大小写，因此当你试图通过用户文本进行筛选时，它是一个更好的选择。 看起来是这样的 @Query(filter: #Predicate { user in user.name.localizedStandardContains(“R”)}, sort: \\User.name) var users: [User]在我们的小测试数据中，这意味着我们将看到四个用户中的三个，因为这三个用户的名字中都有一个字母 “r”。 现在，让我们更进一步：升级我们的过滤器，使其匹配姓名中带有 “R “且居住在伦敦的人： @Query(filter: #Predicate { user in user.name.localizedStandardContains(“R”) &amp;&amp; user.city &#x3D;&#x3D; “London”}, sort: \\User.name) var users: [User]这使用了 Swift 的 “逻辑和 “操作符，这意味着条件的两边都必须为真，整个条件才能为真–用户的名字必须包含 “R”，而且他们必须住在伦敦。 如果我们只有第一个字母 R 的复选框，那么 Ed、Rosa 和 Roy 就会匹配。如果我们只有第二个字母 R 的复选框，那么艾德、罗伊和约翰尼就会匹配。把这两项放在一起，就意味着只有 Ed 和 Roy 符合，因为他们是唯一两个名字中带有 R 的人，而且还住在伦敦。 您可以添加越来越多这样的检查，但使用 &amp;&amp; 会让人有点困惑。幸运的是，这些谓词支持有限的 Swift 表达式子集，让阅读变得更容易一些。 例如，我们可以将当前的谓词改写成这样： @Query(filter: #Predicate { user in if user.name.localizedStandardContains(“R”) { if user.city &#x3D;&#x3D; “London” { return true } else { return false } } else { return false }}, sort: \\User.name) var users: [User]现在，你可能会觉得这有点啰嗦–可以删除 else 两个块，只以 return true 结尾，因为如果用户真的匹配了谓词， return true 就已经被命中了。 下面就是这样的效果： @Query(filter: #Predicate { user in if user.name.localizedStandardContains(“R”) { if user.city &#x3D;&#x3D; “London” { return true } } return false }, sort: \\User.name) var users: [User]遗憾的是，这段代码实际上是无效的，因为尽管它看起来像是在执行纯 Swift 代码，但重要的是你要记住这实际上并没有发生– #Predicate 宏实际上是将我们的代码改写成一系列可以应用于数据库的测试，而数据库内部并不使用 Swift。 要查看内部发生了什么，请按几次撤消键，以获得带有两个 else 块的原始版本。现在右键单击 #Predicate 并选择 “展开宏”，你会看到大量代码出现。请记住，这才是构建和运行的实际代码，也就是我们的 #Predicate 所转换的代码。 因此，这只是 #Predicate 工作原理的一小部分，以及为什么你可能会尝试的一些谓词并不能像你期望的那样工作–这些东西看起来很简单，但背后其实很复杂！ 使用 SwiftUI 对 @Query 进行动态排序和筛选现在您已经了解了 SwiftData #Predicate 的工作原理，下一个问题可能是 “如何让它与用户输入一起工作？”答案是……这很复杂。我将向你展示如何实现这一功能，以及如何使用相同的技术动态调整排序，但你需要花一点时间才能记住它是如何实现的–希望苹果公司将来能改进这一点！ 如果我们以之前看过的 SwiftData 代码为基础，每个用户对象都有不同的 joinDate 属性，有些是过去的，有些是未来的。我们还有一个显示查询结果的 List ： List(users) { user in Text(user.name)}我们要做的是将该列表移到一个单独的视图中–一个专门用于运行 SwiftData 查询并显示其结果的视图，然后让它可以选择显示所有用户或仅显示将来加入的用户。 因此，创建一个新的 SwiftUI 视图，调用 UsersView ，给它一个 SwiftData 导入，然后将 List 代码移到那里，不移动它的任何修改器–只移动上面显示的代码。 既然我们要在 UsersView 中显示 SwiftData 结果，就需要在其中添加一个 @Query 属性。该属性不应使用排序顺序或谓词，至少目前还没有。因此，请在此处添加此属性： @Query var users: [User]在预览中添加 modelContainer() 修改器后，UsersView.swift 代码就会变成这样： import SwiftDataimport SwiftUI struct UsersView: View { @Query var users: [User] var body: some View &#123; List(users) &#123; user in Text(user.name) &#125; &#125; } #Preview { UsersView() .modelContainer(for: User.self)}在完成这个视图之前，我们需要一种方法来自定义运行的查询。目前的情况是，只使用 @Query var users: [User] 意味着 SwiftData 将加载所有用户，且不带筛选器或排序顺序，但实际上我们希望从 ContentView 自定义其中一个或两个查询 - 我们希望传递一些数据。 最好的办法是使用初始化器向视图传递一个值，然后使用该值创建查询。正如我前面所说，我们的目标是显示所有用户，或者只显示未来加入的用户。因此，我们将通过传递一个最小加入日期来实现这一目标，并确保所有用户至少在该日期之后加入。 现在就将此初始化程序添加到 UsersView ： init(minimumJoinDate: Date) { _users &#x3D; Query(filter: #Predicate { user in user.joinDate &gt;&#x3D; minimumJoinDate }, sort: \\User.name)}大部分代码您都已经熟悉了，但请注意 users 前面有一个下划线。这是有意为之：我们不是要修改 User 数组，而是要修改生成数组的 SwiftData 查询。下划线是 Swift 访问查询的方式，这意味着我们将根据传入的日期创建查询。 至此，我们完成了 UsersView 的工作，因此，现在回到 ContentView ，我们需要删除现有的 @Query 属性，代之以切换某种布尔值的代码，并将其当前值传入 UsersView 。 首先，在 ContentView 中添加这个新的 @State 属性： @State private var showingUpcomingOnly &#x3D; false现在将 ContentView 中的 List 代码（同样不包括其修饰符）替换为以下代码： UsersView(minimumJoinDate: showingUpcomingOnly ? .now : .distantPast)这将向 UsersView 传递两个日期中的一个：当我们的布尔属性为真时，我们将传递 .now ，这样我们只显示在当前时间之后加入的用户，否则我们将传递 .distantPast ，这至少是 2000 年前的日期–除非我们的用户中包括一些罗马皇帝，否则他们的加入日期都将在这之后，因此所有用户都将被显示。 现在只需在 ContentView 中添加切换布尔值的方法–将其添加到 ContentView 工具栏： Button(showingUpcomingOnly ? “Show Everyone” : “Show Upcoming”) { showingUpcomingOnly.toggle()}这样就可以更改按钮的标签，使其始终反映下一次按下时发生的情况。 这样就完成了所有工作，现在运行应用程序就可以动态更改用户列表了。 是的，这是一个相当大的工程，但正如你所看到的，它的效果非常好，而且你也可以将同样的技术应用到其他类型的过滤中。 这种方法同样适用于排序数据：我们可以在 ContentView 中控制一个排序描述符数组，然后将它们传入 UsersView 的初始化器，让它们调整查询。 首先，我们需要升级 UsersView 初始化程序，使其接受 User 类的某种排序描述符。这再次使用了 Swift 的泛型： SortDescriptor 类型需要知道它在排序什么，因此我们需要在角括号内指定 User 。 将 UsersView 初始化程序修改为这样： init(minimumJoinDate: Date, sortOrder: [SortDescriptor]) { _users &#x3D; Query(filter: #Predicate { user in user.joinDate &gt;&#x3D; minimumJoinDate }, sort: sortOrder)}您还需要更新您的预览代码，以传入一个排序顺序示例，这样您的代码才能正常编译： UsersView(minimumJoinDate: .now, sortOrder: [SortDescriptor(\\User.name)]) .modelContainer(for: User.self)在 ContentView 中，我们又新增了一个属性来存储当前的排序顺序。我们将先使用名称，然后再加入日期，这似乎是一个合理的默认值： @State private var sortOrder &#x3D; [ SortDescriptor(\\User.name), SortDescriptor(\\User.joinDate),]然后，我们就可以像处理加入日期一样，将其传入 UsersView ： UsersView(minimumJoinDate: showingUpcomingOnly ? .now : .distantPast, sortOrder: sortOrder)最后，我们需要一种动态调整数组的方法。一种方法是使用 Picker 显示两个选项：按姓名排序和按加入日期排序。这本身并不难，但我们如何为每个选项附加一个 SortDescriptor 数组呢？ 答案就在一个名为 tag() 的有用修改器中，它可以让我们为每个拾取器选项附加自己选择的特定值。在这里，这意味着我们可以将每个选项的标签作为自己的 SortDescriptor 数组，SwiftUI 会自动将该标签分配给 sortOrder 属性。 试试把它添加到工具栏中： Picker(“Sort”, selection: $sortOrder) { Text(“Sort by Name”) .tag([ SortDescriptor(\\User.name), SortDescriptor(\\User.joinDate), ]) Text(&quot;Sort by Join Date&quot;) .tag([ SortDescriptor(\\User.joinDate), SortDescriptor(\\User.name) ]) }当你现在运行该应用时，很有可能看到的不是你想象的那样。视你使用的设备而定，”排序 “不是显示为一个菜单，里面有多个选项，你看到的是 圆圈内有三个点，按下即可显示选项。在导航栏中直接显示 “按姓名排序”，点击后可更改为 “加入日期”。这两个选项都不是很好，但我想借此机会介绍另一个有用的 SwiftUI 视图，名为 Menu 。它可以让你在导航栏中创建菜单，还可以在其中放置按钮、拾取器等。 在这种情况下，如果我们用 Menu 来封装当前的 Picker 代码，就会得到更好的结果。试试这个： Menu(“Sort”, systemImage: “arrow.up.arrow.down”) { &#x2F;&#x2F; current picker code}再试一次，你会发现情况好多了，更重要的是，我们的动态筛选和排序功能现在都很好用！ 与 SwiftData、SwiftUI 和 @Query 的关系SwiftData 允许我们创建相互引用的模型，例如，一个 School 模型拥有一个由许多 Student 对象组成的数组，或者一个 Employee 模型存储一个 Manager 对象。 这些关系被称为关系，有各种各样的形式。只要你告诉 SwiftData 你想要什么，它就能很好地自动形成这些关系，不过还是会有一些意外情况发生！ 我们现在就来试试。我们已经有了以下 User 模型： @Modelclass User { var name: String var city: String var joinDate: Date init(name: String, city: String, joinDate: Date) &#123; self.name = name self.city = city self.joinDate = joinDate &#125; }我们可以将其扩展为，每个 User 都可以附加一个工作数组，即他们需要完成的工作任务。为此，我们首先需要创建一个新的 Job 模型，就像这样： @Modelclass Job { var name: String var priority: Int var owner: User? init(name: String, priority: Int, owner: User? = nil) &#123; self.name = name self.priority = priority self.owner = owner &#125; }请注意我是如何让 owner 属性直接引用 User 模型的–我明确告诉 SwiftData 这两个模型是联系在一起的。 现在，我们可以调整 User 模型，创建工作岗位阵列： var jobs &#x3D; Job因此，作业有所有者，用户有作业数组–这种关系是双向的，这通常是个好主意，因为它能让你的数据更容易处理。 该数组将立即开始工作：SwiftData 会在首次请求时加载用户的所有作业，因此如果这些作业从未被使用过，它就会跳过这项工作。 更妙的是，当我们的应用程序下次启动时，SwiftData 会默默地将 jobs 属性添加到所有现有用户，默认情况下给他们一个空数组。这就是所谓的迁移：当我们在模型中添加或删除属性时，我们的需求会随着时间的推移而变化。SwiftData 可以自动完成像这样的简单迁移，但随着学习的深入，您将了解如何创建自定义迁移来处理更大的模型变化。 提示：当我们在 App 结构中使用 modelContainer() 修改器时，我们传入了 User.self ，这样 SwiftData 就知道要为该模型设置存储。我们不需要在这里添加 Job.self ，因为 SwiftData 可以看到两者之间的关系，所以它会自动处理这两个关系。 您无需更改用于加载数据的 @Query ，只需像平常一样使用数组即可。例如，我们可以像这样显示用户列表及其工作计数： List(users) { user in HStack { Text(user.name) Spacer() Text(String(user.jobs.count)) .fontWeight(.black) .padding(.horizontal, 10) .padding(.vertical, 5) .background(.blue) .foregroundStyle(.white) .clipShape(.capsule) &#125; }如果您想通过一些实际数据查看它的工作情况，可以创建一个 SwiftUI 视图，为选定的用户创建新的 Job 实例，但为了测试目的，我们可以采取一个小捷径，添加一些示例数据。 首先添加一个属性来访问活动 SwiftData 模型上下文： @Environment(.modelContext) var modelContext现在添加一个方法，比如这个，来创建一些样本数据： func addSample() { let user1 &#x3D; User(name: “Piper Chapman”, city: “New York”, joinDate: .now) let job1 &#x3D; Job(name: “Organize sock drawer”, priority: 3) let job2 &#x3D; Job(name: “Make plans with Alex”, priority: 4) modelContext.insert(user1) user1.jobs.append(job1) user1.jobs.append(job2) }请再次注意，几乎所有代码都是普通 Swift 代码，只有一行与 SwiftData 有关。 我鼓励你在这里尝试一下。您的出发点应该是假定处理数据就像处理普通的 @Observable 类一样–在您有理由不这么做之前，就让 SwiftData 做它自己的事情吧！ 不过，有一个小问题值得在继续讨论之前说明一下：我们已经将 User 和 Job 联系起来，这样一个用户就可以有很多工作要做，但如果我们删除了一个用户，会发生什么情况呢？ 答案是它们的所有工作都保持不变，不会被删除。这是 SwiftData 的明智之举，因为您不会意外丢失数据。 如果您特别希望同时删除用户的所有作业对象，我们需要告诉 SwiftData。为此，我们可以使用 @Relationship 宏，为其提供一条删除规则，描述当 Job 对象的所属 User 被删除时应如何处理。 默认的删除规则称为 .nullify ，这意味着每个 Job 对象的 owner 属性都会被设置为 nil，表示它们没有所有者。我们将把它改为 .cascade ，这意味着删除一个 User 会自动删除其所有 Job 对象。之所以称为级联，是因为删除会持续到所有相关对象–例如，如果我们的 Job 对象与 locations 有关系，那么这些对象也会被删除，依此类推。 因此，将 User 中的 jobs 属性改为这样： @Relationship(deleteRule: .cascade) var jobs &#x3D; Job现在我们是明确的，这意味着删除用户时不会留下任何隐藏的 Job 对象–这就好多了！ 将 SwiftData 与 CloudKit 同步SwiftData 可以将用户的所有数据与 iCloud 同步，最重要的是，它通常完全不需要代码。 在开始之前，有一个重要的警告：将数据同步到 iCloud 需要一个激活的 Apple 开发者账户。如果没有账户，以下操作将无法进行。 还在吗？好的，为了将本地 SwiftData 存储中的数据同步到 iCloud，您需要为应用程序启用 iCloud 功能。我们以前没有自定义过应用程序功能，所以这一步是新的。 首先，单击项目导航器顶部的 “SwiftDataTest “应用程序图标。该图标应位于 SwiftDataTest 组的正上方。 其次，在 “TARGETS（目标）”列表中选择 “SwiftDataTest”。你会看到一堆选项卡出现：常规”、”签名和功能”、”资源标签”、”信息 “等等。我们需要的是 “签名和功能”，因此请现在选择。 第三，按 “+ CAPABILITY “并选择 iCloud，这样 iCloud 就会出现在活动功能列表中–你会看到有三种可能的服务，还有一个 “CloudKit 控制台 “按钮等。 第四，选中标有 CloudKit 的复选框，这将允许我们的应用程序在 iCloud 中存储 SwiftData 信息。您还需要按 “+”按钮添加一个新的 CloudKit 容器，以配置数据在 iCloud 中的实际存储位置。您应该在此处使用以 “iCloud. “为前缀的应用程序捆绑 ID，例如 iCloud.com.hackingwithswift.swiftdatatest。 第五，再次按下 “+ CAPABILITY”，然后添加后台模式功能。这里面有一大堆配置选项，但你只需要选中 “远程通知 “复选框–这样当 iCloud 中的数据发生变化时，应用就能收到通知，从而在本地进行同步。 就这样，你的应用程序就可以使用 iCloud 同步 SwiftData 了。 也许吧。 iCloud 的 SwiftData 有一个本地 SwiftData 没有的要求：所有属性必须是可选的或有默认值，所有关系必须是可选的。前者只是一个小麻烦，但后者却是一个更大的麻烦–它可能会对你的代码造成相当大的破坏。 不过，这些都是要求，而不仅仅是建议。因此，就 Job 而言，我们需要调整它的属性： var name: String &#x3D; “None”var priority: Int &#x3D; 1var owner: User?对于 User ，我们需要使用这个： var name: String &#x3D; “Anonymous”var city: String &#x3D; “Unknown”var joinDate: Date &#x3D; Date.now@Relationship(deleteRule: .cascade) var jobs: [Job]? &#x3D; Job重要：如果不做这些更改，iCloud 将无法正常工作。如果您查看 Xcode 的日志（CloudKit 喜欢写入 Xcode 的日志），并滚动到最顶端附近，SwiftData 会在任何属性阻止 iCloud 同步正常工作时向您发出警告。 调整好模型后，现在需要修改代码以正确处理可选性。例如，在向用户添加工作时，可以这样使用可选链： user1.jobs?.append(job1)user1.jobs?.append(job2)读取用户的工作计数时，可以使用可选链和 nil 聚合，就像这样： Text(String(user.jobs?.count ?? 0))我不太喜欢在项目中到处散布这种代码，所以如果要经常使用作业，我更愿意创建一个名为 unwrappedJobs 或类似的只读计算属性–如果有值，则返回 jobs ，否则返回空数组，就像这样： var unwrappedJobs: [Job] { jobs ?? []}虽然这只是一件小事，但却能让代码的其他部分更加流畅，而且只读的设置还能防止你意外更改丢失的数组。 重要提示：虽然模拟器可以测试本地 SwiftData 应用程序，但它在测试 iCloud 方面却非常糟糕–你可能会发现数据同步不正确、不迅速，甚至根本无法同步。请使用真实设备以避免出现问题！ 总结虽然我们只是触及了 SwiftData 功能的表面，但我们还是看到了它是如何通过相对简单的代码实现添加、删除、排序、过滤等功能的。是的，在 Swift 中，有几个部分有点模糊，例如 #Predicate 就需要一些时间来适应，但只要小心谨慎，就不会有问题。 也许 SwiftData 最重要的一点是，它保证适用于苹果所有平台上的所有应用程序。这意味着，无论你有什么需求，都可以使用它：也许是保存重要数据，也许只是缓存下载的内容；这都不重要，因为 SwiftData 会为你做好管理工作。 回顾所学知识任何人都可以看完教程，但要记住教程的内容却需要付出实际的努力。我的工作就是确保你从这些教程中尽可能多地吸收知识，因此我准备了一份简短的复习资料，帮助你检查自己的学习情况。 单击此处复习在本项目中学到的知识。 挑战学习的最佳方法之一就是尽可能多地编写自己的代码，因此，以下三种方法是你应该尝试扩展此应用程序，以确保你完全理解发生了什么。 这三个挑战都与您的升级项目 7 iExpense 有关： 首先将其升级为使用 SwiftData。添加自定义排序选项：按名称或按金额排序。添加过滤选项，以显示所有支出、个人支出或业务支出。","categories":[{"name":"技术","slug":"技术","permalink":"https://blog.five2fire.top/categories/%E6%8A%80%E6%9C%AF/"}],"tags":[{"name":"编程","slug":"编程","permalink":"https://blog.five2fire.top/tags/%E7%BC%96%E7%A8%8B/"},{"name":"Swift","slug":"Swift","permalink":"https://blog.five2fire.top/tags/Swift/"},{"name":"Hacking with Swift","slug":"Hacking-with-Swift","permalink":"https://blog.five2fire.top/tags/Hacking-with-Swift/"}]},{"title":"【Hacking With Swift】Project11_Bookworm","slug":"Project11_BookWorm","date":"2024-07-04T06:45:25.000Z","updated":"2025-01-02T02:17:10.812Z","comments":true,"path":"article/12347.html","permalink":"https://blog.five2fire.top/article/12347.html","excerpt":"","text":"英文原博博主是 Paul Hudson @twostraws 本文是学习Swift过程中翻译该网站的内容: https://www.hackingwithswift.com/ 简介在这个项目中，我们将制作一个应用程序来跟踪你读过的书以及你对这些书的看法，它将遵循与项目 10 类似的主题：让我们利用你已经掌握的所有技能，然后添加一些额外的新技能，将它们提升到一个新的水平。 这一次，你将见到 SwiftData，它是苹果用于处理数据库的框架。本项目将作为 SwiftData 的入门介绍，但我们很快就会详细介绍。 与此同时，我们还将构建第一个自定义用户界面组件–一个星级评价小部件，用户可以点击该部件为每本书打分。这意味着要向你介绍另一个名为 @Binding 的属性包装器，相信我，这一切都会有意义的。 像往常一样，我们将首先讲解本项目所需的所有新技术，因此请使用 App 模板创建一个名为 Bookworm 的新 iOS 应用程序。 重要提示：我知道这很诱人，但请不要触碰存储选项，尽管我知道其中有一个 SwiftData 选项。它会给你的项目添加一大堆无用的代码，你只需删除它就能跟上进度了。 使用 @Binding 创建自定义组件您已经看到 SwiftUI 的 @State 属性包装器如何让我们使用本地值类型，以及 @Bindable 如何让我们绑定可观察类内部的属性。现在还有第三个选项，它的名字很容易让人混淆： @Binding 。它可以让我们与另一个视图共享一个简单的 @State 属性，因此它们都指向相同的整数、字符串、布尔等。 想想看：当我们创建一个拨动开关时，我们会发送某种可以更改的布尔属性，就像这样： 12345@State private var rememberMe = falsevar body: some View &#123; Toggle(&quot;Remember Me&quot;, isOn: $rememberMe)&#125; 因此，当用户与切换器交互时，切换器需要更改布尔值，但它如何记住应该更改的值呢？ 这就是 @Binding 的作用所在：它可以让我们在视图中存储一个单一的可变值，而这个值实际上指向其他地方的其他值。在 Toggle 的例子中，开关会将自己的本地绑定值更改为布尔值，但这实际上是在幕后操纵我们视图中的 @State 属性–它们都在读写同一个布尔值。 @Bindable 和 @Binding 之间的区别一开始会让人非常困惑，但最终会让人明白。 明确地说， @Bindable 是在访问使用 @Observable 宏的共享类时使用的：在一个视图中使用 @State 创建共享类，这样就可以在该视图中创建绑定，但在与其他视图共享时使用 @Bindable ，这样 SwiftUI 也可以在该视图中创建绑定。 另一方面， @Binding 用于简单的值类型数据，而不是单独的类。例如，您有一个 @State 属性，该属性存储布尔值、 Double 、字符串数组等，您希望将这些数据传递出去。这并没有使用 @Observable 宏，所以我们不能使用 @Bindable 。相反，我们可以使用 @Binding ，这样就可以在多个地方共享该布尔值或整数。 这种行为使得 @Binding 对创建自定义用户界面组件极为重要。用户界面组件的核心是 SwiftUI 视图，与其他所有视图一样，但 @Binding 是它们与众不同的地方：虽然它们可能有自己的本地 @State 属性，但它们也暴露了 @Binding 属性，使它们可以直接与其他视图接口。 为了演示这一点，我们将查看创建一个按下时保持向下的自定义按钮所需的代码。我们的基本实现都是你以前见过的东西：一个带填充的按钮、一个线性渐变的背景、一个 Capsule 剪贴形状，等等–现在就把这些添加到 ContentView.swift 中： 123456789101112131415161718struct PushButton: View &#123; let title: String @State var isOn: Bool var onColors = [Color.red, Color.yellow] var offColors = [Color(white: 0.6), Color(white: 0.4)] var body: some View &#123; Button(title) &#123; isOn.toggle() &#125; .padding() .background(LinearGradient(colors: isOn ? onColors : offColors, startPoint: .top, endPoint: .bottom)) .foregroundStyle(.white) .clipShape(.capsule) .shadow(radius: isOn ? 0 : 5) &#125;&#125; 其中唯一令人兴奋的是，我为两种渐变色使用了属性，这样它们就可以由创建按钮的人自定义。 现在我们可以创建一个这样的按钮，作为主用户界面的一部分： 12345678910struct ContentView: View &#123; @State private var rememberMe = false var body: some View &#123; VStack &#123; PushButton(title: &quot;Remember Me&quot;, isOn: rememberMe) Text(rememberMe ? &quot;On&quot; : &quot;Off&quot;) &#125; &#125;&#125; 按钮下方有一个文本视图，这样我们就可以跟踪按钮的状态–试试运行你的代码，看看效果如何。 你会发现，点击按钮确实会影响它的显示方式，但我们的文本视图却没有反映出这种变化–它总是显示 “关闭”。显然，有什么东西正在发生变化，因为按下按钮时，按钮的外观会发生变化，但这种变化并没有反映在 ContentView 中。这里发生的情况是，我们定义了一个单向数据流： ContentView 有其 rememberMe 布尔值，该布尔值用于创建 PushButton - 该按钮的初始值由 ContentView 提供。但是，一旦创建了按钮，它就接管了对值的控制：它在按钮内部切换 isOn 属性的 true 或 false，但不会将变化传回 ContentView 。 这是一个问题，因为我们现在有两个真相来源： ContentView 存储的是一个值，而 PushButton 存储的是另一个值。幸运的是，这正是 @Binding 的用武之地：它允许我们在 PushButton 和使用它的任何东西之间建立双向连接，这样，当一个值发生变化时，另一个也会发生变化。 要切换到 @Binding ，我们只需做两处修改。首先，在 PushButton 中将其 isOn 属性改为以下内容： 1@Binding var isOn: Bool 其次，在 ContentView 中，将我们创建按钮的方式改为这样： 1PushButton(title: &quot;Remember Me&quot;, isOn: $rememberMe) 这就在 rememberMe 前添加了一个美元符号–我们传递的是绑定本身，而不是绑定中的布尔值。 现在再次运行代码，你会发现一切正常：切换按钮现在也能正确更新文本视图。这就是 @Binding 的威力：就按钮而言，它只是在切换一个布尔值–它并不知道有其他东西在监控该布尔值并根据变化采取行动。 使用 TextEditor 接受多行文本输入我们已经多次使用 SwiftUI 的 TextField 视图，它非常适合用户输入短文本。不过，如果要输入较长的文本，您可能需要改用 TextEditor 视图：该视图也需要与文本字符串进行双向绑定，但它的另一个好处是允许输入多行文本–它更适合为用户提供大量的工作空间。 主要是因为它没有什么特别的配置选项，使用 TextEditor 实际上比使用 TextField 更简单–你不能调整它的样式或添加占位符文本，你只需将它绑定到一个字符串上。不过，你确实需要注意确保它不会超出安全区域，否则输入会很麻烦；可以将它嵌入 NavigationStack 、 Form 或类似内容中。 例如，我们可以将 TextEditor 与 @AppStorage 相结合，创建世界上最简单的笔记应用程序，就像这样： 1234567891011struct ContentView: View &#123; @AppStorage(&quot;notes&quot;) private var notes = &quot;&quot; var body: some View &#123; NavigationStack &#123; TextEditor(text: $notes) .navigationTitle(&quot;Notes&quot;) .padding() &#125; &#125;&#125; 提示： @AppStorage 并非用于存储安全信息，因此切勿将其用于任何私人用途。 现在，我说你可能想改用 TextEditor ，而不是说你应该改用，这是有原因的：SwiftUI 提供了第三种选择，在某些情况下效果更好。 在创建 TextField 时，我们可以选择提供一个轴，让它可以沿着轴增长。这意味着文本字段一开始是一个普通的单行文本字段，但随着用户的输入，它可以像 iMessage 文本框一样增长。 看起来是这样的 123456789101112struct ContentView: View &#123; @AppStorage(&quot;notes&quot;) private var notes = &quot;&quot; var body: some View &#123; NavigationStack &#123; TextField(&quot;Enter your text&quot;, text: $notes, axis: .vertical) .textFieldStyle(.roundedBorder) .navigationTitle(&quot;Notes&quot;) .padding() &#125; &#125;&#125; 值得一试，看看你的想法如何。 这两种方法您都会用到，只是时间不同而已。虽然我喜欢 TextField 自动展开的方式，但有时向用户显示一个较大的文本空间也很有帮助，这样他们就能预先知道可以在这里输入很多内容。 提示：SwiftUI 进入 Form 后往往会改变事物的外观，因此一定要在 Form 内外都试一试，看看它们有什么不同。 SwiftData 和 SwiftUI 简介SwiftUI 是一个功能强大的现代框架，用于在所有 Apple 平台上构建出色的应用程序，而 SwiftData 则是一个功能强大的现代框架，用于存储、查询和过滤数据。如果它们能以某种方式结合在一起，岂不美哉？ 它们不仅配合得天衣无缝，而且只需要很少的代码，你几乎不会相信其结果–你可以在短短几分钟内创造出非凡的东西。 首先是基础知识：SwiftData 是一个对象图和持久化框架，说得通俗一点，就是让我们定义对象和这些对象的属性，然后让我们从永久存储中读写它们。 从表面上看，这听起来就像使用 Codable 和 UserDefaults ，但它比这先进得多：SwiftData 可以对我们的数据进行排序和过滤，还能处理更大的数据–它能存储的数据量实际上是无限的。更棒的是，SwiftData 还能实现各种更高级的功能，以备不时之需：iCloud 同步、懒加载数据、撤销和重做等等。 在这个项目中，我们将只使用 SwiftData 的一小部分功能，但它很快就会扩展，我只是想先让大家体验一下。 在您创建 Xcode 项目时，我曾要求您不要启用 SwiftData 支持，因为这样做虽然可以省去一些枯燥的设置代码，但同时也会增加一大堆额外的示例代码，而这些代码毫无意义，只需删除即可。 因此，你将学习如何手动设置 SwiftData。这需要三个步骤，首先我们要定义要在应用程序中使用的数据。 在此之前，我们通过创建一个名为 Student.swift 的 Swift 文件来描述数据，然后为该文件提供以下代码： 12345678910@Observableclass Student &#123; var id: UUID var name: String init(id: UUID, name: String) &#123; self.id = id self.name = name &#125;&#125; 我们只需做两处很小的改动，就能将其转化为 SwiftData 对象，它可以保存在数据库中、与 iCloud 同步、搜索、排序等。 首先，我们需要在文件顶部添加另一个导入： 1import SwiftData 这就告诉 Swift，我们要引入 SwiftData 的所有功能。 现在，我们想改变这种状况：把下面这个代码 12@Observableclass Student &#123; 修改为 12@Modelclass Student &#123; ……仅此而已。这就是 SwiftData 加载和保存学生所需的全部信息。现在，SwiftData 还可以查询、删除、将学生与其他对象链接等。 该类称为 SwiftData 模型：它定义了我们希望在应用程序中使用的某种数据。在幕后， @Model 构建在与 @Observable 相同的观察系统之上，这意味着它能与 SwiftUI 完美配合。 既然我们已经定义了要处理的数据，就可以开始设置 SwiftData 的第二步：编写一段 Swift 代码来加载模型。这段代码将告诉 SwiftData 在 iPhone 上为我们准备一些存储空间，它将在这里读写 Student 对象。 这项工作最好在 App 结构中完成。每个项目都有一个这样的结构体，包括我们迄今为止制作的所有项目，它是我们正在运行的整个应用程序的启动板。 由于本项目名为 “书虫”，我们的 App 结构将位于文件 BookwormApp.swift 中。它应该是这样的 12345678910import SwiftUI@mainstruct BookwormApp: App &#123; var body: some Scene &#123; WindowGroup &#123; ContentView() &#125; &#125;&#125; 你可以看到它看起来有点像我们的常规视图代码：我们仍然有一个 import SwiftUI ，我们仍然使用结构体来创建自定义类型，我们的 ContentView 就在那里。其余部分都是新的，我们真正关心的是两个部分： @main 行告诉 Swift 这就是启动我们应用程序的程序。在内部，当用户从 iOS 主屏幕启动我们的应用程序时，它将引导整个程序。WindowGroup 部分告诉 SwiftUI，我们的应用程序可以在多个窗口中显示。这在 iPhone 上作用不大，但在 iPad 和 macOS 上就变得非常重要了。在这里，我们需要告诉 SwiftData 设置所有存储供我们使用，这同样只需要两个很小的改动。 首先，我们需要在 import SwiftUI 旁边添加 import SwiftData 。我非常喜欢按字母顺序对导入进行排序，但这并不是必须的。 其次，我们需要在 WindowGroup 中添加一个修饰符，这样 SwiftData 就可以在应用程序中的任何地方使用： 1.modelContainer(for: Student.self) 模型容器是 SwiftData 用来存储数据的地方。首次运行应用程序时，这意味着 SwiftData 必须创建底层数据库文件，但在以后的运行中，它将加载之前创建的数据库。 至此，您已经了解了如何使用 @Model 创建数据模型，并了解了如何使用 modelContainer() 修改器创建模型容器。拼图的第三个部分称为模型上下文，它实际上是数据的 “实时 “版本–当您加载对象并更改它们时，这些更改只存在于内存中，直到它们被保存。因此，模型上下文的作用就是让我们在内存中处理所有数据，这比不断读写数据到磁盘要快得多。 每个 SwiftData 应用程序都需要一个模型上下文来使用，而我们已经创建了我们的上下文–它是在我们使用 modelContainer() 修改器时自动创建的。SwiftData 会自动为我们创建一个模型上下文，称为主上下文，并将其存储在 SwiftUI 的环境中、 至此，我们完成了 SwiftData 的所有配置，现在该进入有趣的部分了：读取数据并写入数据。 从 SwiftData 中检索信息是通过查询完成的–我们描述我们想要什么、如何排序以及是否需要使用任何过滤器，然后 SwiftData 会发回所有匹配的数据。我们需要确保该查询随着时间的推移保持更新，这样当学生创建或删除时，我们的用户界面也能保持同步。 SwiftUI 有一个解决方案，你猜对了，就是另一个属性包装器。这次它的名字叫 @Query ，只要将 import SwiftData 添加到文件中，它就可以使用了。 因此，请在 ContentView.swift 顶部添加 SwiftData 的导入，然后在 ContentView 结构中添加此属性： @Query var students: [Student]这看起来就像一个普通的 Student 数组，但只要在开头添加 @Query 就足以让 SwiftData 从其模型容器中加载学生–它会自动找到放置到环境中的主上下文，并通过那里查询容器。我们没有指定要加载哪些学生，也没有指定如何对结果进行排序，因此我们将得到所有学生。 从这里开始，我们可以像使用普通 Swift 数组一样使用 students - 将此代码放入视图正文中： 123456NavigationStack &#123; List(students) &#123; student in Text(student.name) &#125; .navigationTitle(&quot;Classroom&quot;)&#125; 如果你愿意，可以运行代码，但实际上没有什么意义–列表将是空的，因为我们还没有添加任何数据，所以我们的数据库是空的。为了解决这个问题，我们将在列表下方创建一个按钮，每次点击它都会随机添加一个新学生，但首先我们需要一个新属性来访问之前创建的模型上下文。 立即将此属性添加到 ContentView ： 1@Environment(\\.modelContext) var modelContext 有了这些，下一步就是添加一个按钮，生成随机学生并保存在模型上下文中。为了帮助学生脱颖而出，我们将通过创建 firstNames 和 lastNames 数组来分配随机名称，然后使用 randomElement() 从每一个数组中任选一个。 首先将此工具栏添加到 List ： 1234567891011.toolbar &#123; Button(&quot;Add&quot;) &#123; let firstNames = [&quot;Ginny&quot;, &quot;Harry&quot;, &quot;Hermione&quot;, &quot;Luna&quot;, &quot;Ron&quot;] let lastNames = [&quot;Granger&quot;, &quot;Lovegood&quot;, &quot;Potter&quot;, &quot;Weasley&quot;] let chosenFirstName = firstNames.randomElement()! let chosenLastName = lastNames.randomElement()! // more code to come &#125;&#125; 注：难免有人会抱怨我强行解包了对 randomElement() 的调用，但我们只是手工创建了数组的值–它总是会成功的。如果你非常讨厌强制解包，也许可以用 nil coalescing 和默认值来代替它们。 现在开始有趣的部分：我们将创建一个 Student 对象。将其添加到 &#x2F;&#x2F; more code to come 注释中： 1let student = Student(id: UUID(), name: &quot;\\(chosenFirstName) \\(chosenLastName)&quot;) 最后，我们需要请求模型上下文添加该学生，这意味着将保存该学生。将最后一行添加到按钮的操作中： 1modelContext.insert(student) 最后，您现在应该可以运行应用程序并进行试用了–点击几次 “添加 “按钮随机生成一些学生，然后您就会看到他们滑入我们的列表中。更妙的是，如果你重新启动应用程序，你会发现你的学生还在那里，因为 SwiftData 会自动保存他们。 现在，你可能会认为这只是花了很少的时间却学了很多东西，但你现在已经知道了什么是模型、模型容器和模型上下文，也知道了如何插入和查询数据。在本项目的后续部分，我们将更多地了解 SwiftData，但现在你已经走得很远了。 这是本项目概述的最后一部分，因此请继续重置您的项目，准备开始真正的工作。这意味着重新设置 ContentView.swift、BookwormApp.swift，同时删除 Student.swift。 开始创建使用 SwiftData 创建图书在这个项目中，我们的首要任务是为书籍设计一个 SwitData 模型，然后创建一个新的视图将书籍添加到数据库中。 首先是模型：创建一个名为 Book.swift 的新文件，为 SwiftData 添加一个导入，然后添加以下代码： 12345678@Modelclass Book &#123; var title: String var author: String var genre: String var review: String var rating: Int&#125; 该类需要一个初始化器来为其所有属性提供值，但这里有一个小提示：如果您在类内开始键入 “in”，Xcode 会自动为您完成整个初始化器。 该类足以存储书名、作者姓名、流派、用户对该书的简要看法以及用户对该书的数字评分。 现在我们有了数据模型，可以让 SwiftData 为其创建一个模型容器。这意味着打开 BookwormApp.swift，在文件顶部添加 import SwiftData ，然后在 WindowGroup 中添加此修改器： 1.modelContainer(for: Book.self) 我们的下一步是编写一个可以创建新条目的表单。这将结合您目前所学到的许多技能： Form , @State , @Environment , TextField , TextEditor , Picker , sheet() , 等等，再加上所有新的 SwiftData 知识。 首先创建一个名为 “AddBookView “的新 SwiftUI 视图。在属性方面，我们需要一个环境属性来访问模型上下文： 1@Environment(\\.modelContext) var modelContext 由于该表单将存储组成一本书所需的所有数据，我们需要为每本书的值设置 @State 属性。因此，接下来要添加这些属性： 12345@State private var title = &quot;&quot;@State private var author = &quot;&quot;@State private var rating = 3@State private var genre = &quot;Fantasy&quot;@State private var review = &quot;&quot; 最后，我们还需要一个属性来存储所有可能的流派选项，这样我们就可以使用 ForEach 制作一个拾取器。现在将最后一个属性添加到 AddBookView ： 1let genres = [&quot;Fantasy&quot;, &quot;Horror&quot;, &quot;Kids&quot;, &quot;Mystery&quot;, &quot;Poetry&quot;, &quot;Romance&quot;, &quot;Thriller&quot;] 现在，我们可以对表单本身进行初步处理–我们很快就会对其进行改进，但现在这样就足够了。用以下内容替换当前的 body ： 12345678910111213141516171819202122232425262728293031NavigationStack &#123; Form &#123; Section &#123; TextField(&quot;Name of book&quot;, text: $title) TextField(&quot;Author&#x27;s name&quot;, text: $author) Picker(&quot;Genre&quot;, selection: $genre) &#123; ForEach(genres, id: \\.self) &#123; Text($0) &#125; &#125; &#125; Section(&quot;Write a review&quot;) &#123; TextEditor(text: $review) Picker(&quot;Rating&quot;, selection: $rating) &#123; ForEach(0..&lt;6) &#123; Text(String($0)) &#125; &#125; &#125; Section &#123; Button(&quot;Save&quot;) &#123; // add the book &#125; &#125; &#125; .navigationTitle(&quot;Add Book&quot;)&#125; 在填写按钮操作时，我们将使用表单中的所有值创建 Book 类的实例，然后将该对象插入模型上下文。 在 &#x2F;&#x2F; add the book 注释的位置添加此代码： 12let newBook = Book(title: title, author: author, genre: genre, review: review, rating: rating)modelContext.insert(newBook) 这样表单就完成了，但我们仍然需要一种方法，在添加书籍时显示或隐藏表单。 要显示 AddBookView ，需要返回 ContentView.swift，并遵循工作表的常规步骤： 添加 @State 属性，以跟踪工作表是否显示。在工具栏中添加某种按钮来切换该属性。sheet() 修改器，当属性变为 true 时显示 AddBookView 。废话少说，让我们开始编写更多代码吧。请先在 ContentView,swift 中添加 SwiftData 的导入，然后在 ContentView 结构中添加这些属性： 1234@Environment(\\.modelContext) var modelContext@Query var books: [Book]@State private var showingAddScreen = false 这样，我们就有了一个模型上下文，可以在以后用来删除图书；有了一个查询，可以读取我们拥有的所有图书（这样我们就可以测试一切是否正常）；有了一个布尔值，可以跟踪添加屏幕是否显示。 对于 ContentView 主体，我们将使用一个导航堆栈，这样就可以在其右上角添加一个标题和一个按钮，除此之外，它将只包含一些显示 books 数组中有多少个项目的文本–这样我们就可以确保一切正常。请记住，我们需要在这里添加 sheet() 修改器，以便根据需要显示 AddBookView 。 用 ContentView 替换现有的 body 属性： 1234567891011121314 NavigationStack &#123; Text(&quot;Count: \\(books.count)&quot;) .navigationTitle(&quot;Bookworm&quot;) .toolbar &#123; ToolbarItem(placement: .topBarTrailing) &#123; Button(&quot;Add Book&quot;, systemImage: &quot;plus&quot;) &#123; showingAddScreen.toggle() &#125; &#125; &#125; .sheet(isPresented: $showingAddScreen) &#123; AddBookView() &#125;&#125; 提示：这明确指定了按钮的尾部位置，以便我们稍后添加第二个按钮。 请耐心等待–我们就快完成了！现在我们已经设计了 SwiftData 模型，创建了一个用于添加数据的表单，然后更新了 ContentView ，以便在需要时显示表单。最后一步是让表单在用户添加书籍时自动关闭。 我们以前做过这样的操作，所以希望你知道该怎么做。首先，我们需要在 AddBookView 中添加另一个环境属性，以便能够取消当前视图： 1@Environment(\\.dismiss) var dismiss 最后，在 “保存 “按钮的操作闭合末尾添加一个调用 dismiss() 。 您现在应该可以运行应用程序并添加示例图书了。当 AddBookView 滑动离开时，计数标签应自行更新为 1。 添加自定义星级组件SwiftUI 让创建自定义 UI 组件变得非常容易，因为它们实际上就是视图，其中包含某种 @Binding ，供我们读取。 为了演示这一点，我们将创建一个星级评分视图，让用户通过点击图片在 1 到 5 之间输入分数。虽然我们可以让这个视图足够简单，以满足我们的具体使用情况，但最好还是在适当的地方增加一些灵活性，以便在其他地方也能使用。在这里，这意味着我们要创建六个可自定义的属性： 评级前的标签（默认：空字符串）最大整数评级（默认值：5）关闭图像和打开图像，决定了星形突出或不突出时使用的图像（默认情况下：关闭图像为 nil ，打开图像为填充星形；如果我们在关闭图像中找到 nil ，我们也会在那里使用打开图像）。关闭和打开的颜色，决定了星形高亮或不高亮时使用的颜色（默认值：关闭为灰色，打开为黄色）我们还需要一个额外的属性来存储 @Binding 整数，这样我们就可以将用户的选择反馈给使用星级的任何设备。 因此，请创建一个名为 “RatingView “的新 SwiftUI 视图，并赋予它这些属性： 1234567891011@Binding var rating: Intvar label = &quot;&quot;var maximumRating = 5var offImage: Image?var onImage = Image(systemName: &quot;star.fill&quot;)var offColor = Color.grayvar onColor = Color.yellow 在填写 body 属性之前，请尝试编译代码，您会发现编译失败，因为我们的 #Preview 代码没有为 rating 传递绑定。 SwiftUI 为此提供了一种特殊而简单的解决方案，称为常量绑定。这些绑定具有固定值，一方面意味着它们不能在用户界面中更改，另一方面也意味着我们可以轻松创建它们–它们非常适合预览。 因此，请用以下代码替换现有的预览代码： 123#Preview &#123; RatingView(rating: .constant(4))&#125; 现在我们来看看 body 属性。这将是一个 HStack ，其中包含所提供的任何标签，以及所要求的任意数量的星星–当然，他们可以选择任何想要的图片，所以可能根本就不是星星。 选择显示哪张图片的逻辑非常简单，但却非常适合用自己的方法来减少代码的复杂性。逻辑是这样的 如果传入的数字大于当前等级，则返回已设置的 “关闭 “图像，否则返回 “打开 “图像。如果传入的数字等于或小于当前等级，则返回打开的图像。我们可以将其封装在一个方法中，因此现在就将其添加到 RatingView ： 1234567func image(for number: Int) -&gt; Image &#123; if number &gt; rating &#123; offImage ?? onImage &#125; else &#123; onImage &#125;&#125; 现在，实现 body 属性出奇地简单：如果标签上有任何文本，就使用它，然后使用 ForEach 从 1 开始计数到最高评分加 1，并重复调用 image(for:) 。我们还将根据评分应用前景色，并将每颗星包裹在一个可调整评分的按钮内。 用它取代现有的 body 属性： 1234567891011121314HStack &#123; if label.isEmpty == false &#123; Text(label) &#125; ForEach(1..&lt;maximumRating + 1, id: \\.self) &#123; number in Button &#123; rating = number &#125; label: &#123; image(for: number) .foregroundStyle(number &gt; rating ? offColor : onColor) &#125; &#125;&#125; 这样，我们的评级视图就已经完成了，要将其付诸实施，请回到 AddBookView ，将第二部分替换为以下内容： Section(“Write a review”) { TextEditor(text: $review) RatingView(rating: $rating)}我们的默认值是合理的，因此开箱即可使用，现在就试试吧！ 你可能会发现事情不太对：无论你按哪个星级，它都会选择 5 星！ 我见过数以百计的人遇到过这个问题，无论他们有多少经验。问题在于，当我们在表单或列表中添加行时，SwiftUI 会假定行本身是可点击的。这让用户更容易选择，因为他们可以点击行中的任意位置来触发行中的按钮。 在我们的例子中，我们有多个按钮，因此 SwiftUI 会按顺序点击所有按钮 - rating 被设置为 1，然后是 2，然后是 3、4 和 5，这就是为什么无论如何它最终都是 5。 我们可以使用附加在整个 HStack 上的额外修改器来禁用整个 “点击行来触发其按钮 “的行为： .buttonStyle(.plain)这使得 SwiftUI 可以单独处理每个按钮，因此一切都能按计划运行。而且使用起来也更顺手：在这里不需要使用拾取器进入细节视图，因为星级评分更自然、更常见。 使用 @Query 创建列表现在，我们的 ContentView 有这样一个查询属性： @Query var books: [Book]我们在 body 中使用它来查看这个简单的文本视图： Text(“Count: (books.count)”)为了使该屏幕更加生动，我们将用一个 List 来取代文本视图，显示所有已添加的书籍，以及它们的评分和作者。 我们可以在这里使用之前制作的星级评定视图，但尝试其他东西会更有趣。 RatingView 控件可用于任何类型的项目，而我们可以制作一个新的 EmojiRatingView ，专门用于显示本项目的评分。它所要做的就是根据评分显示五种不同表情符号中的一种，这也是 SwiftUI 中视图构成多么简单明了的一个很好的例子–通过这种方式只需取出视图的一小部分就可以了。 因此，请创建一个名为 “EmojiRatingView “的新 SwiftUI 视图，并编写以下代码： struct EmojiRatingView: View { let rating: Int var body: some View &#123; switch rating &#123; case 1: Text(&quot;1&quot;) case 2: Text(&quot;2&quot;) case 3: Text(&quot;3&quot;) case 4: Text(&quot;4&quot;) default: Text(&quot;5&quot;) &#125; &#125; } #Preview { EmojiRatingView(rating: 3)}提示：我在文本中使用了数字，因为表情符号会给电子阅读器带来麻烦，但你应该用你认为代表各种评级的任何表情符号来代替数字。 现在，我们可以返回 ContentView ，对其用户界面进行初步处理。这将用列表和 ForEach 取代现有的文本视图， books 。我们不需要为 ForEach 提供标识符，因为所有 SwiftData 模型都自动符合 Identifiable 。 在列表中，我们将有一个指向当前图书的 NavigationLink ，在这个 中，我们将有新的 EmojiRatingView ，加上图书的标题和作者。因此，用这个替换现有的文本视图： List { ForEach(books) { book in NavigationLink(value: book) { HStack { EmojiRatingView(rating: book.rating) .font(.largeTitle) VStack(alignment: .leading) &#123; Text(book.title) .font(.headline) Text(book.author) .foregroundStyle(.secondary) &#125; &#125; &#125; &#125; }小贴士：确保保留前面的修饰词 - navigationTitle() 等。 由于我们还没有添加 navigationDestination() ，所以导航功能无法正常工作，不过没关系，我们很快就会回到这个界面。首先，让我们创建详细视图… 显示图书详细信息当用户点击 ContentView 中的一本书时，我们将显示一个包含更多信息的详细视图–书的类型、简短评论等。我们还将重复使用新的 RatingView ，甚至对其进行自定义，这样您就可以看到 SwiftUI 有多么灵活。 为了让这个界面更有趣，我们将添加一些代表应用程序中每个类别的艺术作品。我已经从 Unsplash 挑选了一些图片，并将其放入本书的 project11-files 文件夹中，如果你还没有下载，请现在下载，然后将其拖入你的资产目录。 Unsplash 的许可证允许我们以商业或非商业方式使用图片，无论是否注明出处，但我们都希望注明出处。我添加的图片来自 Ryan Wallace、Eugene Triguba、Jamie Street、Alvaro Serrano、Joao Silas、David Dilbert 和 Casey Horner - 如果你愿意，可以从 https://unsplash.com 上获取原件。 接下来，创建一个名为 “DetailView “的新 SwiftUI 视图，然后导入 SwiftData。这个新视图只需要一个属性，即它应该显示的书籍，所以请现在就添加： let book: Book即使只是拥有该属性，也足以破坏 DetailView.swift 底部的预览代码。以前这很容易解决，因为我们只需发送一个示例对象即可，但有了 SwiftData 的参与，事情就变得一团糟了：创建新书还意味着需要在视图上下文中创建新书。 在 SwiftData 中，这是第一件非常棘手的事情；我们必须把事情处理得恰到好处，它才能正常工作： 为了创建 Book 示例对象，我们必须首先创建一个模型上下文。模型上下文来自于创建模型容器。如果我们创建了一个模型容器，我们并不希望它实际存储任何东西，因此我们可以创建一个自定义配置，告诉 SwiftData 只在内存中存储信息。这意味着一切都是临时的。我知道这听起来很费事，但实际上只需要几行代码–我们需要手工制作模型容器，并使用名为 ModelConfiguration 的新类型来完成，该类型允许我们请求临时内存存储。有了它之后，我们就可以像往常一样创建一个 Book 对象，然后将它与模型容器本身一起发送到 DetailView 。 用以下代码替换当前的预览代码： #Preview { do { let config &#x3D; ModelConfiguration(isStoredInMemoryOnly: true) let container &#x3D; try ModelContainer(for: Book.self, configurations: config) let example &#x3D; Book(title: “Test Book”, author: “Test Author”, genre: “Fantasy”, review: “This was a great book; I really enjoyed it.”, rating: 4) return DetailView(book: example) .modelContainer(container) &#125; catch &#123; return Text(&quot;Failed to create preview: \\(error.localizedDescription)&quot;) &#125; }是的，创建 Book 实例时并没有在任何地方提及模型容器或配置，但这确实很重要：在没有容器的情况下创建 SwiftData 模型对象很可能会导致代码崩溃。 完成这些后，我们就可以将注意力转移到更有趣的问题上，即设计视图本身。首先，我们要把分类图片和流派放在 ZStack 中，这样就可以把一个很好地放在另一个的上面。我挑选了一些我认为看起来不错的样式，但也欢迎大家随意尝试这些样式–我唯一建议大家一定要保留的是 ScrollView ，它可以确保我们的评论完全适合屏幕，无论它有多长、用户使用的是什么设备，也无论他们是否调整了字体大小。 用此属性替换当前的 body 属性： ScrollView { ZStack(alignment: .bottomTrailing) { Image(book.genre) .resizable() .scaledToFit() Text(book.genre.uppercased()) .font(.caption) .fontWeight(.black) .padding(8) .foregroundStyle(.white) .background(.black.opacity(0.75)) .clipShape(.capsule) .offset(x: -5, y: -5) &#125; }.navigationTitle(book.title).navigationBarTitleDisplayMode(.inline).scrollBounceBehavior(.basedOnSize)这样，流派名称就会出现在 ZStack 的右下角，并用背景色、粗体字和少量衬垫来突出它。 在 ZStack 下方，我们将添加作者、评论和评分。我们不希望用户在这里调整评分，因此我们可以使用另一个常量绑定将其转换为简单的只读视图。更妙的是，由于我们使用 SF 符号创建了评分图片，因此我们可以使用简单的 font() 修改器将其无缝缩放，从而更好地利用我们的空间。 因此，将这些视图直接添加到之前的 ZStack 下方： Text(book.author) .font(.title) .foregroundStyle(.secondary) Text(book.review) .padding() RatingView(rating: .constant(book.rating)) .font(.largeTitle)至此， DetailView ，我们可以返回 ContentView.swift 向 List 视图添加导航目标： .navigationDestination(for: Book.self) { book in DetailView(book: book)}现在再次运行应用程序，你就可以点击输入的任何书籍，在新的详细视图中显示它们。 使用排序描述符对 SwiftData 查询排序当您使用 @Query 从 SwiftData 中提取对象时，您可以指定数据的排序方式–是按字段的字母顺序排序？还是按数字排序，先排最高的数字？无论您选择哪种排序方式，最好都能让用户获得可预测的体验。 在这个项目中，我们有多个字段可能对排序有用：书名、作者或评分都很合理，是不错的选择，但我们不必只依赖一个字段–您可以指定多个字段，这样您就可以先询问评分最高的书，然后用它们的名字来决定胜负。 查询排序有两种方式：一种是只允许使用一个排序字段的简单选项，另一种是允许使用名为 SortDescriptor 的新类型数组的高级版本。 如果使用简单版本，我们可能会要求按照书名的字母顺序提供图书： @Query(sort: \\Book.title) var books: [Book]或者，我们可以要求按评分从高到低排序： @Query(sort: \\Book.rating, order: .reverse) var books: [Book]当您只需要一个字段时，这种方法很有效，但一般来说，我认为最好还能有一个备用字段–”按评分排序，然后按标题排序 “可以为您的应用程序增加额外的可预测性，这总是件好事。 我们可以使用 SortDescriptor 类型创建它们，该类型可以由一个或两个值组成：我们要排序的属性，以及是否要反向排序。例如，我们可以这样按标题属性的字母顺序排序： @Query(sort: [SortDescriptor(\\Book.title)]) var books: [Book]与更简单的排序方法一样，使用 SortDescriptor 对结果进行排序的默认方式是升序，即文本按字母顺序排列，但如果想颠倒排序顺序，可以使用这个方法： @Query(sort: [SortDescriptor(\\Book.title, order: .reverse)]) var books: [Book]您可以指定多个排序描述符，它们将按照您提供的顺序应用。例如，如果用户添加了 Pete Hamill 的《Forever》一书，然后又添加了 Judy Blume 的《Forever》–一本完全不同的书，只是书名相同–那么指定第二个排序字段就很有帮助。 因此，我们可能要求书名升序排序在前，书的作者升序排序在后，就像这样： @Query(sort: [ SortDescriptor(\\Book.title), SortDescriptor(\\Book.author)]) var books: [Book]除非您有大量具有相似值的数据，否则第二个甚至第三个排序字段对性能几乎没有影响。以我们的书籍数据为例，几乎每本书都有一个唯一的书名，因此二级排序字段在性能方面或多或少无关紧要。 从 SwiftData 查询中删除我们已经使用 @Query 将 SwiftData 对象放入 SwiftUI List ，只需再做一点工作，我们就能启用轻扫删除和专用的编辑&#x2F;完成按钮。 就像普通的数据数组一样，大部分工作都是通过在 ForEach 中附加 onDelete(perform:) 修改器来完成的，但我们不需要直接从数组中删除项目，而是需要在查询中找到请求的对象，然后使用它在模型上下文中调用 delete() 。一旦删除了所有对象，SwiftData 的自动保存系统就会启动并永久应用更改。 因此，首先将此方法添加到 ContentView ： func deleteBooks(at offsets: IndexSet) { for offset in offsets { &#x2F;&#x2F; find this book in our query let book &#x3D; books[offset] // delete it from the context modelContext.delete(book) &#125; }我们可以通过在 ContentView 的 ForEach 上添加 onDelete(perform:) 修饰符来触发，但请记住：它必须位于 ForEach 上，而不是 List 上。 立即添加此修改器： .onDelete(perform: deleteBooks)这样我们就可以轻扫删除，还可以通过添加一个编辑&#x2F;删除按钮来做得更好。在 ContentView 中找到 toolbar() 修改器，然后再添加一个 ToolbarItem ： ToolbarItem(placement: .topBarLeading) { EditButton()}这就完成了 ContentView ，请尝试运行应用程序–现在应该可以自由添加和删除书籍了，可以通过轻扫删除或使用编辑按钮删除。 使用警报以编程方式弹出导航链接你已经看到 NavigationLink 如何让我们推送到细节界面，它可能是一个自定义视图，也可能是 SwiftUI 的内置类型之一，如 Text 或 Image 。因为我们是在 NavigationStack 中，所以 iOS 会自动提供一个 “返回 “按钮，让用户回到上一屏幕，用户也可以从左侧边缘轻扫返回。不过，有时以编程方式返回也很有用，即在我们需要时而不是在用户轻扫时返回上一屏幕。 我们之前已经讨论过这个问题，所以希望这对你来说只是一个很好的练习：我们将在应用程序中添加最后一个功能，删除用户当前正在阅读的书籍。为此，我们需要显示一个提示，询问用户是否真的要删除这本书，然后从当前的模型上下文中删除这本书，如果这正是用户想要的。一旦这样做了，就没有必要再停留在当前屏幕上了，因为与其相关联的图书已经不存在了，所以我们要弹出当前视图–将其从 NavigationStack 堆栈的顶部移除，这样我们就回到了上一个屏幕。 首先，我们需要在 DetailView 结构中添加三个新属性：一个用于保存 SwiftData 模型上下文（以便我们删除内容），一个用于保存删除操作（以便我们将视图从导航堆栈中弹出），还有一个用于控制是否显示删除确认提示。 因此，首先将这三个新属性添加到 DetailView ： @Environment(.modelContext) var modelContext@Environment(.dismiss) var dismiss@State private var showingDeleteAlert &#x3D; false第二步是编写一个方法，将当前图书从模型上下文中删除，并取消当前视图。使用导航链接而不是工作表显示该视图并不重要，我们仍然使用相同的 dismiss() 代码。 立即将此方法添加到 DetailView ： func deleteBook() { modelContext.delete(book) dismiss()}第三步是添加 alert() 修改器，该修改器会监视 showingDeleteAlert ，并要求用户确认操作。到目前为止，我们一直在使用带有取消按钮的简单警报，但这里我们需要两个按钮：一个按钮用于删除图书，另一个用于取消。这两个按钮都有特定的按钮角色，可以自动使它们看起来正确，因此我们将使用它们。 对于如何标注提示文本，苹果公司提供了非常明确的指导，但归根结底：如果是简单的 “我明白 “接受，那么 “OK “就很好，但如果你想让用户做出选择，那么就应该避免使用 “是 “和 “否 “这样的标题，而应使用 “忽略”、”回复 “和 “确认 “这样的动词。 在本例中，我们将使用 “删除 “作为破坏性按钮，然后在其旁边提供一个取消按钮，以便用户可以根据自己的需要取消删除。因此，请在 DetailView 中的 ScrollView 添加此修改器： .alert(“Delete book”, isPresented: $showingDeleteAlert) { Button(“Delete”, role: .destructive, action: deleteBook) Button(“Cancel”, role: .cancel) { }} message: { Text(“Are you sure?”)}最后一步是添加一个启动删除程序的工具栏项–这只需要翻转 showingDeleteAlert 布尔值，因为我们的 alert() 修改器已经在关注它了。因此，在 ScrollView 中添加最后一个修改器： .toolbar { Button(“Delete this book”, systemImage: “trash”) { showingDeleteAlert &#x3D; true }}现在，您可以在 ContentView 中使用 “轻扫删除 “或 “编辑 “按钮删除图书，或导航到 DetailView ，然后轻点其中的专用删除按钮–它应该会删除图书，更新 ContentView 中的列表，然后自动取消详细视图。 又一个应用程序完成了–干得好！ 总结恭喜您又完成了一个 SwiftUI 项目！有了 SwiftData 等技术的帮助，您现在已经能够构建一些与用户交互的重要应用程序，最重要的是，您还能记住用户输入的内容。虽然 SwiftData 只是浮出水面，但它的功能远不止于此，我期待苹果在未来的更新中继续扩展 SwiftData 和 SwiftUI 之间的联系。与此同时，下一个项目将深入关注 SwiftData，这其中有很多值得探索的地方！ 至于你学到的其他知识，你现在已经掌握了更多 SwiftUI 的属性包装器，我希望你已经了解了在什么时候应该选择哪个属性包装器。 @Binding 在构建自定义 UI 组件时尤其有用，因为它在视图之间共享数据的能力实在是太有用了。 还有最后一件事我想留给大家，大家可能还没注意到。当我们创建一个星级评定组件时，我们创建了一个成为用户交互式控件的东西，就像 Button 和 Slider 一样。然而，我们并没有停下来考虑它是如何与可访问性结合在一起的，而这就是一个问题： Button , Slider , 以及其他的控件都能很好地工作，但当我们开始创建自己的组件时，我们就需要介入并自己完成这项工作。 构建人人都能使用的应用程序是每个人都需要认真对待的事情，这也是为什么我在未来专门设立了一个完整的技术项目–我们将回顾之前的项目，看看如何改进它们。 不管怎么说，先做第一件事–你有了新的评论和一些挑战。祝你好运！ 回顾所学知识任何人都可以看完教程，但要记住教程的内容却需要付出实际的努力。我的工作就是确保你从这些教程中尽可能多地吸收知识，因此我准备了一份简短的复习资料，帮助你检查自己的学习情况。 单击此处复习在本项目中学到的知识。 挑战学习的最佳方法之一就是尽可能多地编写自己的代码，因此，以下三种方法是你应该尝试扩展此应用程序，以确保你完全理解发生了什么。 现在可以不选择图书的标题、作者或流派，这会给详细视图带来问题。请通过强制默认设置、验证表单或为未知类型显示默认图片来解决这个问题–您可以自己选择。修改 ContentView ，以某种方式突出显示被评为 1 星的图书，例如用红色显示其名称。在图书类中添加一个新的 “日期 “属性，将 Date.now 赋值给它，这样它就能获得当前的日期和时间，然后在 DetailView 中的某个地方将其格式化。","categories":[{"name":"技术","slug":"技术","permalink":"https://blog.five2fire.top/categories/%E6%8A%80%E6%9C%AF/"}],"tags":[{"name":"编程","slug":"编程","permalink":"https://blog.five2fire.top/tags/%E7%BC%96%E7%A8%8B/"},{"name":"Swift","slug":"Swift","permalink":"https://blog.five2fire.top/tags/Swift/"},{"name":"Hacking with Swift","slug":"Hacking-with-Swift","permalink":"https://blog.five2fire.top/tags/Hacking-with-Swift/"}]},{"title":"【Hacking With Swift】Project10_CupcakeCorner","slug":"Project10_CupcakeCorner","date":"2024-07-02T06:21:33.000Z","updated":"2025-01-02T02:17:10.812Z","comments":true,"path":"article/39062.html","permalink":"https://blog.five2fire.top/article/39062.html","excerpt":"","text":"英文原博博主是 Paul Hudson @twostraws 本文是学习Swift过程中翻译该网站的内容: https://www.hackingwithswift.com/ 引入在这个项目中，我们将构建一个用于订购纸杯蛋糕的多屏幕应用程序。这将使用几个表单，这对您来说是旧闻，但您还将学习如何从互联网发送和接收订单数据、如何验证表单等等。 随着我们不断深入研究 Codable ，我希望您能继续对它的灵活性和安全性印象深刻。特别是，我希望您记住它与更旧的 UserDefaults API 有多么不同 - 不用担心是否正确输入字符串真是太好了！ 不管怎样，我们还有很多事情要做，所以让我们开始吧：使用 App 模板创建一个新的 iOS 应用程序，并将其命名为 CupcakeCorner。如果您尚未下载本书的项目文件，请立即获取：https://github.com/twostraws/HackingWithSwift 一如既往，我们将从项目所需的新技术开始…… 使用 URLSession 和 SwiftUI 发送和接收 Codable 数据iOS 为我们提供了从互联网发送和接收数据的内置工具，如果我们将其与 Codable 支持相结合，就可以将 Swift 对象转换为 JSON 发送，然后接收回 JSON，再将其转换回 Swift 对象。更妙的是，当请求完成时，我们可以立即将其数据分配给 SwiftUI 视图中的属性，从而更新我们的用户界面。 为了演示这一点，我们可以从苹果公司的 iTunes API 中加载一些示例音乐 JSON 数据，并将其显示在 SwiftUI List 中。Apple 的数据包含大量信息，但我们将其精简为两种类型： Result 将存储曲目 ID、名称和所属专辑，而 Response 将存储结果数组。 那么，就从这段代码开始吧： 123456789struct Response: Codable &#123; var results: [Result]&#125;struct Result: Codable &#123; var trackId: Int var trackName: String var collectionName: String&#125; 现在我们可以编写一个简单的 ContentView 来显示结果数组： 12345678910111213struct ContentView: View &#123; @State private var results = [Result]() var body: some View &#123; List(results, id: \\.trackId) &#123; item in VStack(alignment: .leading) &#123; Text(item.trackName) .font(.headline) Text(item.collectionName) &#125; &#125; &#125;&#125; 一开始不会显示任何内容，因为 results 数组是空的。这就是我们的网络调用：我们将要求 iTunes API 向我们发送泰勒-斯威夫特的所有歌曲列表，然后使用 JSONDecoder 将这些结果转换为 Result 实例数组。 不过，这样做意味着你需要满足两个重要的 Swift 关键字： async 和 await 。要知道，任何能够运行 SwiftUI 的 iPhone 每秒都能执行数十亿次操作–速度快到我们甚至还没意识到它的启动，它就已经完成了大部分工作。反之，联网–从互联网下载数据–可能需要几百毫秒甚至更长的时间，这对于习惯于在这段时间内做数十亿件其他事情的电脑来说是极其缓慢的。 Swift 并没有强迫我们在联网时停止整个进程，而是让我们能够说：”这项工作需要一些时间，请等待它完成，应用程序的其他部分将照常运行。 这种功能–在我们的主应用程序代码继续运行时，让某些代码停止运行的能力–被称为异步函数。同步函数是指在返回所需值之前完全运行的函数，而异步函数是指能够暂时休眠的函数，这样它就可以等待其他工作完成后再继续运行。在我们的例子中，这意味着在网络代码运行时进入休眠状态，这样应用程序的其他部分就不会冻结数秒。 为了便于理解，让我们分几个阶段来编写。首先，这里是基本方法存根–请将其添加到 ContentView 结构中： 123func loadData() async &#123;&#125; 注意这里新加入的 async 关键字–我们要告诉 Swift，这个函数可能需要休眠才能完成工作。 我们希望在 List 显示后立即运行该函数，但这里不能使用 onAppear() ，因为它不知道如何处理休眠函数 - 它希望其函数是同步的。 SwiftUI 为这类任务提供了一个不同的修改器，并给它起了一个特别好记的名字： task() 。它可以调用可能会暂时休眠的函数；Swift 要求我们做的就是用第二个关键字 await 来标记这些函数，这样我们就明确承认了休眠可能会发生。 现在就将此修改器添加到 List ： 123.task &#123; await loadData()&#125; 提示：将 await 想象为 try - 我们表示我们理解可能会发生睡眠，就像 try 表示我们承认可能会发生错误一样被扔掉。 在 loadData() 内部，我们需要完成三个步骤： 创建我们想要读取的 URL。 获取该 URL 的数据。 将该数据的结果解码为 Response 结构。 我们将从 URL 开始，逐步添加这些内容。这个 URL 需要有精确的格式：”itunes.apple.com “后跟一系列参数–如果在网上搜索 “iTunes Search API”，就能找到全套参数。在我们的例子中，我们将使用搜索词 “Taylor Swift “和实体 “song”，因此现在就将其添加到 loadData() ： 1234guard let url = URL(string: &quot;https://itunes.apple.com/search?term=taylor+swift&amp;entity=song&quot;) else &#123; print(&quot;Invalid URL&quot;) return&#125; 第二步是从 URL 抓取数据，这也是我们可能发生休眠的地方。我说 “有可能 “是因为它可能不会发生–iOS 会对数据进行少量缓存，因此如果连续两次从 URL 抓取数据，数据就会立即发送回来，而不会触发睡眠。 无论如何，这里都有可能发生休眠，而每当有可能发生休眠时，我们都需要使用 await 关键字和我们想要运行的代码。同样重要的是，这里也可能会出现错误，例如用户当前没有连接到互联网。 因此，我们需要同时使用 try 和 await 。请在前一段代码后直接添加这段代码： 1234567do &#123; let (data, _) = try await URLSession.shared.data(from: url) // more code to come&#125; catch &#123; print(&quot;Invalid data&quot;)&#125; 这介绍了三件重要的事情，所以让我们来分解一下： 我们的工作是通过 data(from:) 方法完成的，该方法接受一个 URL 并返回该 URL 处的 Data 对象。此方法属于 URLSession 类，如果需要，您可以手动创建和配置该类，但您也可以使用带有合理默认值的共享实例。 data(from:) 的返回值是一个元组，其中包含 URL 处的数据和一些描述请求如何进行的元数据。我们不使用元数据，但我们确实需要 URL 的数据，因此有下划线——我们为数据创建一个新的本地常量，然后丢弃元数据。 当同时使用 try 和 await 时，我们必须写 try await ——不允许使用 await try 。这没有什么特殊原因，但他们必须选择一个，所以他们选择了读起来更自然的一个。 因此，如果我们的下载成功，我们的 data 常量将被设置为从 URL 发回的任何数据，但如果由于任何原因失败，我们的代码将打印“无效数据”并且不执行任何其他操作。 该方法的最后一部分是使用 JSONDecoder 将 Data 对象转换为 Response 对象，然后将里面的数组分配给我们的 results 财产。这正是我们之前使用过的，所以这应该不足为奇 - 现在添加最后一个代码来代替 &#x2F;&#x2F; more code to come 注释： 123if let decodedResponse = try? JSONDecoder().decode(Response.self, from: data) &#123; results = decodedResponse.results&#125; 如果你现在运行代码，你应该会看到泰勒·斯威夫特的歌曲列表在短暂的停顿后出现——考虑到最终结果的效果，这实际上并不是很多代码。 所有这些仅处理下载数据。稍后在这个项目中，我们将研究如何采用稍微不同的方法，以便您可以发送 Codable 数据，但现在就足够了。 从远程服务器加载图像SwiftUI 的 Image 视图可以很好地处理应用程序捆绑包中的图片，但如果您想从互联网加载远程图片，则需要使用 AsyncImage 。这些图片是使用图片 URL 创建的，而不是使用简单的资产名称或 Xcode 生成的常量，但 SwiftUI 会为我们处理其余所有工作–下载图片、缓存下载并自动显示。 因此，我们可以创建的最简单的图像是这样的： 1AsyncImage(url: URL(string: &quot;https://hws.dev/img/logo.png&quot;)) 我创建的图片高度为 1200 像素，但当它显示出来时，你会发现它要大得多。这直接涉及到使用 AsyncImage 的基本复杂性之一：在运行我们的代码并下载图片之前，SwiftUI 对图片一无所知，因此无法提前适当调整图片大小。 如果要在我的项目中包含 1200px 的图片，我会将其命名为 &#108;&#x6f;&#x67;&#x6f;&#x40;&#x33;&#x78;&#46;&#x70;&#110;&#x67;，然后再添加一张 800px 的图片，即 &#x6c;&#x6f;&#x67;&#111;&#x40;&#50;&#120;&#46;&#112;&#x6e;&#x67;。这样 SwiftUI 就会为我们加载正确的图片，并确保图片清晰美观，尺寸也正确。现在的情况是，SwiftUI 在加载图片时将其设计为以 1200 像素的高度显示，因此图片会比我们的屏幕大得多，而且看起来也有点模糊。 为了解决这个问题，我们可以提前告诉 SwiftUI 我们正在尝试加载 3 倍比例的图像，就像这样： 1AsyncImage(url: URL(string: &quot;https://hws.dev/img/logo.png&quot;), scale: 3) 现在运行代码，你会发现生成的图片大小更合理了。 如果您想精确确定尺寸呢？那你可以先试试这个： 12AsyncImage(url: URL(string: &quot;https://hws.dev/img/logo.png&quot;)) .frame(width: 200, height: 200) 这行不通，但也许你并不感到惊讶，因为这在普通的 Image 上也行不通。因此，你可以尝试调整它的大小，就像这样： 123AsyncImage(url: URL(string: &quot;https://hws.dev/img/logo.png&quot;)) .resizable() .frame(width: 200, height: 200) ……但这也行不通，事实上情况更糟，因为现在我们的代码甚至无法编译。要知道，我们在这里应用的修改器并不能直接应用于 SwiftUI 下载的图像 - 它们不能，因为 SwiftUI 在实际获取图像数据之前不知道如何应用这些修改器。 取而代之的是，我们将修改器应用于图像的包装器，即 AsyncImage 视图。该视图最终将包含我们完成的图像，但它也将包含一个占位符，该占位符将在图像加载时使用。实际上，当你的应用程序运行时，你可以短暂地看到这个占位符，就是那个 200x200 的灰色方块，一旦加载完成，它就会自动消失。 要调整我们的图片，需要使用一种更高级的 AsyncImage 形式，一旦图片准备就绪，它就会将最终的图片视图传递给我们，然后我们可以根据需要对其进行自定义。另外，这还为我们提供了第二个闭合器，可以根据需要自定义占位符。 例如，我们可以让成品图像视图既能调整大小，又能按比例调整，并使用 Color.red 作为占位符，这样在学习时就会更明显。 12345678AsyncImage(url: URL(string: &quot;https://hws.dev/img/logo.png&quot;)) &#123; image in image .resizable() .scaledToFit()&#125; placeholder: &#123; Color.red&#125;.frame(width: 200, height: 200) 可调整大小的图片和 Color.red 都会自动占用所有可用空间，这意味着 frame() 修改器现在可以正常工作了。 占位符视图可以是任何你想要的。例如，如果将 Color.red 替换为 ProgressView() （就是这样），就会得到一个小的旋转器活动指示器，而不是纯色。 如果你想完全控制远程图片，还有第三种创建 AsyncImage 的方法，它可以告诉我们图片是否已加载、出错或尚未完成。当下载失败时，如果 URL 不存在或用户离线等情况，需要显示专用视图时，这种方法尤其有用。 看起来是这样的 123456789101112AsyncImage(url: URL(string: &quot;https://hws.dev/img/bad.png&quot;)) &#123; phase in if let image = phase.image &#123; image .resizable() .scaledToFit() &#125; else if phase.error != nil &#123; Text(&quot;There was an error loading the image.&quot;) &#125; else &#123; ProgressView() &#125;&#125;.frame(width: 200, height: 200) 因此，如果可以，它会显示我们的图像；如果下载因故失败，则会显示错误信息；如果下载仍在进行中，则会显示一个旋转的活动指示器。 验证和禁用表单SwiftUI 的 Form 视图可以让我们以一种非常快速、方便的方式存储用户输入，但有时还需要更进一步–在继续操作前检查输入是否有效。 为此，我们有一个修改器： disabled() 。这个修改器需要一个条件来检查，如果条件为真，那么它所连接的任何东西都不会响应用户的输入–按钮不能被点击，滑块不能被拖动，等等。这里可以使用简单的属性，但任何条件都可以：读取计算属性、调用方法等、 为了演示这一点，这里有一个接受用户名和电子邮件地址的表单： 12345678910111213141516171819struct ContentView: View &#123; @State private var username = &quot;&quot; @State private var email = &quot;&quot; var body: some View &#123; Form &#123; Section &#123; TextField(&quot;Username&quot;, text: $username) TextField(&quot;Email&quot;, text: $email) &#125; Section &#123; Button(&quot;Create account&quot;) &#123; print(&quot;Creating account…&quot;) &#125; &#125; &#125; &#125;&#125; 在本例中，除非两个字段都已填写，否则我们不希望用户创建账户，因此我们可以像这样添加 disabled() 修改器，禁用包含创建账户按钮的表单部分： 123456Section &#123; Button(&quot;Create account&quot;) &#123; print(&quot;Creating account…&quot;) &#125;&#125;.disabled(username.isEmpty || email.isEmpty) 这意味着 “如果用户名为空或电子邮件为空，则禁用此部分”，而这正是我们想要的。 您可能会发现，值得将您的条件分拆成一个单独的计算财产，比如这样： 123var disableForm: Bool &#123; username.count &lt; 5 || email.count &lt; 5&#125; 现在你只需在修改器中引用即可： 1.disabled(disableForm) 无论您采用哪种方法，我都希望您能尝试运行应用程序，看看 SwiftUI 是如何处理禁用按钮的–当我们的测试失败时，按钮的文字会变成灰色，但一旦测试通过，按钮就会变成蓝色。 为 @Observable 类添加 Codable 一致性如果一个类型的所有属性都已经符合 Codable ，那么该类型本身就可以符合 Codable ，而无需额外工作–Swift 会根据需要合成归档和取消归档类型所需的代码。不过，由于 Swift 重写代码的方式，在处理使用 @Observable 宏的类时，情况就有点棘手了。 为了了解问题的实际情况，我们可以创建一个简单的可观测类，该类只有一个名为 name 的属性，就像这样： 1234@Observableclass User: Codable &#123; var name = &quot;Taylor&quot;&#125; 现在，我们可以编写一段 SwiftUI 代码，在按下按钮时对我们的类实例进行编码，并打印出结果文本： 1234567891011struct ContentView: View &#123; var body: some View &#123; Button(&quot;Encode Taylor&quot;, action: encodeTaylor) &#125; func encodeTaylor() &#123; let data = try! JSONEncoder().encode(User()) let str = String(decoding: data, as: UTF8.self) print(str) &#125;&#125; 您将看到意想不到的结果： &#123;&quot;_name&quot;: &quot;Taylor&quot;,&quot;_$observationRegistrar&quot;:&#123;&#125;&#125;。我们的 name 属性现在是 _name ，JSON 中还有一个观测注册器实例。 请记住， @Observable 宏正在悄悄重写我们的类，以便 SwiftUI 可以监控它，而这里的重写是泄漏的–我们可以看到它的发生，这可能会导致各种问题。例如，如果您试图向服务器发送一个 “name “值，服务器可能不知道该如何处理”_name”。 为了解决这个问题，我们需要告诉 Swift 应该如何对我们的数据进行编码和解码。为此，我们在类中嵌套了一个名为 CodingKeys 的枚举，并使其具有 String 原始值和 CodingKey 协议一致性。是的，这有点令人困惑–枚举的名称是 CodingKeys ，协议是 CodingKey ，但这确实很重要。 在枚举中，你需要为每一个要保存的属性写入一种情况，同时写入一个包含你要为其命名的原始值。在我们的例子中，这意味着 _name （我们的 name 属性的底层存储）应该写成字符串 “name”，不带下划线： 12345678@Observableclass User: Codable &#123; enum CodingKeys: String, CodingKey &#123; case _name = &quot;name&quot; &#125; var name = &quot;Taylor&quot;&#125; 就是这样！如果你再试一次这段代码，就会发现 name 属性的命名是正确的，而且也不再有观察注册器了–结果要干净得多。 这种编码键映射是双向的：当 Codable 在某些 JSON 中看到 name 时，它将自动保存在 _name 属性中。 添加触觉效果SwiftUI 内置支持简单的触觉效果，它使用苹果的触觉引擎让手机以各种方式振动。在 iOS 中，我们有两个选项：简单和完整–我将向你展示这两个选项，以便你了解有哪些可能性，但我认为可以说，除非你有非常特殊的需求，否则你会希望坚持使用简单选项！ 重要提示：这些触觉效果仅适用于实体 iPhone，Mac 和 iPad 等其他设备不会震动。 让我们从简单的选项开始。与工作表和警报一样，我们告诉 SwiftUI 何时触发效果，它就会为我们处理剩下的事情。 首先，我们可以编写一个简单的视图，每当按下一个按钮，就在计数器中加 1： 123456789struct ContentView: View &#123; @State private var counter = 0 var body: some View &#123; Button(&quot;Tap Count: \\(counter)&quot;) &#123; counter += 1 &#125; &#125;&#125; 这些都是老代码了，让我们添加一个触觉效果，使其更有趣，只要按下按钮就会触发–在按钮上添加这个修改器： 1.sensoryFeedback(.increase, trigger: counter) 试着在真实设备上运行一下，你就会感觉到每次按下按钮时都会有轻微的触觉敲击。 .increase 是内置触觉反馈变体之一，在增加计数器等数值时使用效果最佳。还有很多其他类型可供选择，包括 , , , , 等等。 .success .warning .error .start .stop 每种反馈方式都有不同的感觉，虽然你很想把它们都看一遍，然后挑出你最喜欢的，但请考虑一下这可能会让依赖触觉来传递信息的盲人用户感到困惑–如果你的应用程序出错了，但你却因为非常喜欢而播放了成功的触觉，这可能会造成困惑。 如果你想对触觉效果有更多的控制，有一种名为 .impact() 的替代方法，它有两种变体：一种是由你指定对象的灵活性和效果的强度，另一种是由你指定重量和强度。 例如，我们可以要求两个软体物体发生中等程度的碰撞： 1.sensoryFeedback(.impact(flexibility: .soft, intensity: 0.5), trigger: counter) 或者，我们可以指定两个重物之间的激烈碰撞： 1.sensoryFeedback(.impact(weight: .heavy, intensity: 1), trigger: counter) 对于更高级的触觉效果，苹果为我们提供了一个名为 Core Haptics 的整体框架。Core Haptics 可让我们结合轻敲、连续振动、参数曲线等多种方式，创建高度可定制的触觉效果。我不想在这里讲得太深入，因为这有点跑题，但我至少想给你举个例子，让你自己试试。 首先在 ContentView.swift 顶部附近添加这个新的导入： 1import CoreHaptics 接下来，我们需要创建 CHHapticEngine 的实例作为属性–这是负责产生振动的实际对象，因此我们需要在产生触觉效果之前创建它。 因此，将此属性添加到 ContentView ： 1@State private var engine: CHHapticEngine? 我们将在主视图出现后立即创建该引擎。在创建引擎时，您可以附加处理程序，以便在活动停止时（如应用移动到后台时）帮助恢复活动，但在这里我们将保持简单：如果当前设备支持触觉，我们将启动引擎，如果失败则打印错误信息。 将此方法添加到 ContentView ： 12345678910func prepareHaptics() &#123; guard CHHapticEngine.capabilitiesForHardware().supportsHaptics else &#123; return &#125; do &#123; engine = try CHHapticEngine() try engine?.start() &#125; catch &#123; print(&quot;There was an error creating the engine: \\(error.localizedDescription)&quot;) &#125;&#125; 现在是有趣的部分：我们可以配置参数来控制触觉的强度 ( .hapticIntensity ) 和 “锐利 “程度 ( .hapticSharpness )，然后将这些参数置入带有相对时间偏移的触觉事件中。”锐利度 “是个奇怪的词，但一旦你尝试过，就会明白它的意义–锐利度值为 0 确实比值为 1 的时候感觉沉闷。 立即将此方法添加到 ContentView ： 1234567891011121314151617181920func complexSuccess() &#123; // make sure that the device supports haptics guard CHHapticEngine.capabilitiesForHardware().supportsHaptics else &#123; return &#125; var events = [CHHapticEvent]() // create one intense, sharp tap let intensity = CHHapticEventParameter(parameterID: .hapticIntensity, value: 1) let sharpness = CHHapticEventParameter(parameterID: .hapticSharpness, value: 1) let event = CHHapticEvent(eventType: .hapticTransient, parameters: [intensity, sharpness], relativeTime: 0) events.append(event) // convert those events into a pattern and play it immediately do &#123; let pattern = try CHHapticPattern(events: events, parameters: []) let player = try engine?.makePlayer(with: pattern) try player?.start(atTime: 0) &#125; catch &#123; print(&quot;Failed to play pattern: \\(error.localizedDescription).&quot;) &#125;&#125; 要试用我们的自定义触觉，请将 body 属性修改为 ContentView ： 12Button(&quot;Tap Me&quot;, action: complexSuccess) .onAppear(perform: prepareHaptics) 添加 onAppear() 可确保触觉系统启动，从而使点击手势正常工作。 如果你想进一步尝试触觉效果，可将 let intensity 、 let sharpness 和 let event 行替换为你想要的任何触觉效果。例如，如果用下面的代码替换这三行，你就能获得强度和锐度先增后减的数次敲击： 12345678910111213for i in stride(from: 0, to: 1, by: 0.1) &#123; let intensity = CHHapticEventParameter(parameterID: .hapticIntensity, value: Float(i)) let sharpness = CHHapticEventParameter(parameterID: .hapticSharpness, value: Float(i)) let event = CHHapticEvent(eventType: .hapticTransient, parameters: [intensity, sharpness], relativeTime: i) events.append(event)&#125;for i in stride(from: 0, to: 1, by: 0.1) &#123; let intensity = CHHapticEventParameter(parameterID: .hapticIntensity, value: Float(1 - i)) let sharpness = CHHapticEventParameter(parameterID: .hapticSharpness, value: Float(1 - i)) let event = CHHapticEvent(eventType: .hapticTransient, parameters: [intensity, sharpness], relativeTime: 1 + i) events.append(event)&#125; Core Haptics 是一项非常有趣的实验，但考虑到它需要更多的工作，我认为你可能会尽可能坚持使用内置特效！ 本项目的概述到此结束，请将 ContentView.swift 恢复到初始状态，这样我们就可以开始构建主项目了。 主项目记录基本订单信息这个项目的第一步将是创建一个订购屏幕，记录订单的基本细节：他们想要多少个纸杯蛋糕、想要哪种类型，以及是否有任何特殊定制。 在进入用户界面之前，我们需要先定义数据模型。以前我们混合使用结构体和类来获得正确的结果，但现在我们将采用不同的解决方案：我们将使用一个类来存储所有数据，这些数据将在屏幕之间传递。这意味着我们应用程序中的所有屏幕都共享相同的数据，正如你将看到的那样，这将非常有效。 目前，该类不需要很多属性： 蛋糕类型，以及包含所有可能选项的静态数组。用户希望订购多少个蛋糕。用户是否希望提出特殊要求，这将在我们的用户界面中显示或隐藏额外的选项。用户是否希望在蛋糕上添加糖霜。用户是否想在蛋糕上添加糖粉。每一个类在更改时都需要更新用户界面，这意味着我们需要确保该类使用 @Observable 宏。 因此，请新建一个名为 Order.swift 的 Swift 文件，将其基础导入改为 SwiftUI，并给出以下代码： 1234567891011@Observableclass Order &#123; static let types = [&quot;Vanilla&quot;, &quot;Strawberry&quot;, &quot;Chocolate&quot;, &quot;Rainbow&quot;] var type = 0 var quantity = 3 var specialRequestEnabled = false var extraFrosting = false var addSprinkles = false&#125; 现在，我们可以通过添加此属性，在 ContentView 中创建该属性的单个实例： 1@State private var order = Order() 这是创建订单的唯一位置–我们应用程序中的其他屏幕都将传递该属性，以便它们使用相同的数据。 我们将从纸杯蛋糕的类型和数量开始，分三个部分为该屏幕创建用户界面。第一部分将显示一个选择器，让用户从香草、草莓、巧克力和彩虹蛋糕中进行选择，然后显示一个步进器，在 3 到 20 的范围内选择数量。所有这些都将封装在一个表单中，而表单本身又位于一个导航堆栈中，因此我们可以设置一个标题。 这里有一个小障碍：我们的纸杯蛋糕配料列表是一个字符串数组，但我们将用户的选择存储为整数–我们如何将两者匹配起来呢？一个简单的解决方案是使用数组的 indices 属性，它可以为我们提供每个项目的位置，我们可以将其用作数组索引。对于可变数组来说，这是一个坏主意，因为数组的顺序随时都可能改变，但在这里，我们的数组顺序不会改变，所以是安全的。 现在就把它放到 ContentView 的正文中： 1234567891011121314NavigationStack &#123; Form &#123; Section &#123; Picker(&quot;Select your cake type&quot;, selection: $order.type) &#123; ForEach(Order.types.indices, id: \\.self) &#123; Text(Order.types[$0]) &#125; &#125; Stepper(&quot;Number of cakes: \\(order.quantity)&quot;, value: $order.quantity, in: 3...20) &#125; &#125; .navigationTitle(&quot;Cupcake Corner&quot;)&#125; 表单的第二部分将包含三个切换开关，分别绑定到 specialRequestEnabled 、 extraFrosting 和 addSprinkles 。不过，第二和第三个开关只有在第一个开关启用时才可见，因此我们将把它们封装在一个条件中。 现在添加第二部分： 123456789Section &#123; Toggle(&quot;Any special requests?&quot;, isOn: $order.specialRequestEnabled) if order.specialRequestEnabled &#123; Toggle(&quot;Add extra frosting&quot;, isOn: $order.extraFrosting) Toggle(&quot;Add extra sprinkles&quot;, isOn: $order.addSprinkles) &#125;&#125; 继续再次运行应用程序，试试看。 但是，有一个我们自己造成的错误：如果我们启用特殊要求，然后启用 “额外糖霜 “和 “额外糖粉 “中的一个或两个，然后禁用特殊要求，我们之前的特殊要求选择就会保持激活状态。这意味着如果我们重新启用特殊要求，之前的特殊要求仍然有效。 如果代码的每一层都能意识到这个问题，那么解决这个问题并不难–如果应用程序、服务器、数据库等都被编程为在 specialRequestEnabled 设置为 false 时忽略 extraFrosting 和 addSprinkles 的值。不过，更好、更安全的办法是，当 specialRequestEnabled 设置为 false 时，确保 extraFrosting 和 addSprinkles 都被重置为 false。 我们可以通过在 specialRequestEnabled 中添加 didSet 属性观察器来实现这一点。现在就添加： 12345678var specialRequestEnabled = false &#123; didSet &#123; if specialRequestEnabled == false &#123; extraFrosting = false addSprinkles = false &#125; &#125;&#125; 我们的第三个部分是最简单的，因为它只是一个指向下一个屏幕的 NavigationLink 。我们没有第二个屏幕，但我们可以很快添加它：创建一个名为 “AddressView “的新 SwiftUI 视图，并像这样赋予它一个 order 属性： 1234567891011struct AddressView: View &#123; var order: Order var body: some View &#123; Text(&quot;Hello World&quot;) &#125;&#125;#Preview &#123; AddressView(order: Order())&#125; 我们很快就会让它变得更有用，但现在这意味着我们可以返回 ContentView.swift 并为表单添加最后一个部分。这将创建一个指向 AddressView 的 NavigationLink ，并传入当前订单对象。 请现在添加这最后一部分： 12345Section &#123; NavigationLink(&quot;Delivery details&quot;) &#123; AddressView(order: order) &#125;&#125; 这就是我们的第一个屏幕，在我们继续之前，请最后再试一次 - 你应该可以选择蛋糕类型、选择数量并切换所有开关。 检查有效地址我们项目的第二步将是让用户在表单中输入地址，但作为其中的一部分，我们将添加一些验证功能–我们只想在用户地址看起来不错的情况下进入第三步。 为此，我们可以在之前创建的 AddressView 结构中添加 Form 视图，该视图将包含四个文本字段：姓名、街道地址、城市和邮政编码。然后，我们可以添加一个 NavigationLink ，进入下一个屏幕，在这里用户将看到最终价格并可以结账。 为了便于理解，我们首先要添加一个名为 CheckoutView 的新视图，一旦用户准备就绪，地址视图就会推送到该视图。这样做只是为了避免我们现在添加一个占位符，然后记住稍后再返回。 因此，创建一个名为 CheckoutView 的新 SwiftUI 视图，并赋予它与 AddressView 相同的 Order 属性和预览： 1234567891011struct CheckoutView: View &#123; var order: Order var body: some View &#123; Text(&quot;Hello, World!&quot;) &#125;&#125;#Preview &#123; CheckoutView(order: Order())&#125; 同样，我们稍后再讨论这个问题，但首先让我们实现 AddressView 。就像我说过的，这需要有一个表单，其中有四个文本字段与 Order 对象的四个属性绑定，另外还有一个 NavigationLink ，将控件传递给我们的结账视图。 首先，我们需要在 Order 中添加四个新属性来存储配送详细信息： 1234var name = &quot;&quot;var streetAddress = &quot;&quot;var city = &quot;&quot;var zip = &quot;&quot; 现在，用这个替换 body 中的 AddressView ： 12345678910111213141516Form &#123; Section &#123; TextField(&quot;Name&quot;, text: $order.name) TextField(&quot;Street Address&quot;, text: $order.streetAddress) TextField(&quot;City&quot;, text: $order.city) TextField(&quot;Zip&quot;, text: $order.zip) &#125; Section &#123; NavigationLink(&quot;Check out&quot;) &#123; CheckoutView(order: order) &#125; &#125;&#125;.navigationTitle(&quot;Delivery details&quot;).navigationBarTitleDisplayMode(.inline) 如您所见，这将我们的 order 对象传递到更深一层，即 CheckoutView ，这意味着我们现在有三个视图指向相同的数据。 这段代码会出现很多错误，但只需一个小小的改动就能解决，那就是将 order 属性改成这样： 1@Bindable var order: Order 在此之前，您已经看到 Xcode 是如何让我们绑定到本地 @State 属性的，即使这些属性是使用 @Observable 宏的类。这是因为 @State 属性封装器会自动为我们创建双向绑定，我们可以通过$ 语法访问这些绑定 $name ,$age 等。 我们没有在 AddressView 中使用 @State ，因为我们没有在这里创建类，我们只是从其他地方接收类。这意味着 SwiftUI 无法访问我们通常使用的双向绑定，这是一个问题。 现在，我们知道该类使用了 @Observable 宏，这意味着 SwiftUI 能够监视这些数据的变化。因此， @Bindable 属性包装器的作用就是为我们创建缺失的绑定–它生成的双向绑定能够与 @Observable 宏配合使用，而无需使用 @State 来创建本地数据。它在这里是完美的，你会在今后的项目中经常用到它。 请再运行一次应用程序，因为我想让你明白为什么这些都很重要。在第一个屏幕上输入一些数据，在第二个屏幕上输入一些数据，然后试着返回到起点，然后再前进到终点–也就是说，返回到第一个屏幕，然后点击底部按钮两次，再次进入结账视图。 你应该看到的是，无论你在哪个屏幕上，输入的所有数据都会被保存下来。是的，这是使用类来保存数据的自然副作用，但它是我们应用程序中的一项即时功能，无需做任何工作–如果我们使用本地状态，那么我们输入的任何地址详细信息都会在我们返回原始视图时消失。 现在 AddressView 可以工作了，是时候阻止用户继续结账了，除非满足某些条件。什么条件？这得由我们来决定。虽然我们可以为四个文本字段中的每个字段编写长度校验，但这往往会让人犯难–有些名字只有四五个字母，如果尝试添加长度校验，可能会不小心将某些人排除在外。 因此，我们只需检查订单的 name , streetAddress , city 和 zip 属性是否为空。我更喜欢在我的数据中添加这种复杂的检查，这意味着你需要像这样在 Order 中添加一个新的计算属性： 1234567var hasValidAddress: Bool &#123; if name.isEmpty || streetAddress.isEmpty || city.isEmpty || zip.isEmpty &#123; return false &#125; return true&#125; 现在，我们可以将该条件与 SwiftUI 的 disabled() 修改器结合使用–将该修改器与要检查的条件一起附加到任何视图，如果条件为真，视图将停止响应用户交互。 在我们的例子中，我们要检查的条件是我们刚刚编写的计算属性 hasValidAddress 。如果该属性为 false，那么包含 NavigationLink 的表单部分就应该被禁用，因为我们需要用户先填写他们的快递详细信息。 因此，在 AddressView 中的第二节末尾添加该修饰符： 1.disabled(order.hasValidAddress == false) 代码应该是这样的 123456Section &#123; NavigationLink(&quot;Check out&quot;) &#123; CheckoutView(order: order) &#125;&#125;.disabled(order.hasValidAddress == false) 现在，如果您运行应用程序，就会发现所有四个地址字段都必须至少包含一个字符才能继续。更妙的是，当条件不成立时，SwiftUI 会自动使按钮变灰，让用户清楚地知道什么时候是互动，什么时候不是。 准备结账我们应用程序的最后一个屏幕是 CheckoutView ，它实际上是一个两半的故事：前半部分是基本的用户界面，对你来说应该没有什么真正的挑战；但后半部分是全新的：我们需要将 Order 类编码为 JSON，通过互联网发送，并获得响应。 我们很快就会看到整个编码和传输过程，但首先让我们来解决最简单的部分：为 CheckoutView 提供一个用户界面。更具体地说，我们要创建一个带有图片、订单总价和下单按钮的 ScrollView ，以启动网络。 关于图片，我已经将纸杯蛋糕图片上传到服务器上，我们将通过 AsyncImage 远程加载该图片–我们可以将其存储在应用程序中，但远程图片意味着我们可以根据季节性替代品和促销活动动态切换图片。 至于订单成本，我们的数据中实际上没有纸杯蛋糕的定价，所以我们可以随便编一个，又不是真的要在这里向人们收费。我们要使用的定价如下： 每个纸杯蛋糕的基本成本为 2 美元。如果蛋糕比较复杂，我们会增加一点费用。每块蛋糕的额外糖霜费用为 1 美元。每个蛋糕再加 50 美分。我们可以在 Order 的一个新计算属性中封装所有这些逻辑，就像这样： 12345678910111213141516171819var cost: Decimal &#123; // $2 per cake var cost = Decimal(quantity) * 2 // complicated cakes cost more cost += Decimal(type) / 2 // $1/cake for extra frosting if extraFrosting &#123; cost += Decimal(quantity) &#125; // $0.50/cake for sprinkles if addSprinkles &#123; cost += Decimal(quantity) / 2 &#125; return cost&#125; 实际视图本身非常简单：我们将在垂直 ScrollView 内使用 VStack ，然后使用我们的图片、费用文本和下单按钮。 稍后我们将填写按钮的操作，但首先让我们完成基本布局–用以下内容替换现有的 body CheckoutView ： 1234567891011121314151617181920ScrollView &#123; VStack &#123; AsyncImage(url: URL(string: &quot;https://hws.dev/img/cupcakes@3x.jpg&quot;), scale: 3) &#123; image in image .resizable() .scaledToFit() &#125; placeholder: &#123; ProgressView() &#125; .frame(height: 233) Text(&quot;Your total is \\(order.cost, format: .currency(code: &quot;USD&quot;))&quot;) .font(.title) Button(&quot;Place Order&quot;, action: &#123; &#125;) .padding() &#125;&#125;.navigationTitle(&quot;Check out&quot;).navigationBarTitleDisplayMode(.inline) 现在，这些对你来说应该都是旧闻了，但在我们完成这个屏幕之前，我想向你展示一个小而有用的 SwiftUI 修改器，我们可以在这里添加： scrollBounceBehavior() 。 使用滚动视图是一种很好的方法，可以确保无论用户启用什么尺寸的动态类型，布局都能很好地工作，但它也带来了一个小麻烦：当你的视图在单个屏幕上非常适合时，当用户在上面上下移动时，视图还是会有一点跳动。 scrollBounceBehavior() 修改器可帮助我们在无滚动内容时禁用弹跳功能。将此添加到 navigationBarTitleDisplayMode() 下方： 1.scrollBounceBehavior(.basedOnSize) 有了这个功能，当我们有实际滚动的内容时，就能获得很好的滚动弹跳效果，否则滚动视图就会像不存在一样。 完成了最后一项调整后，我们就该结束这个项目，开始处理棘手的部分：联网！ 通过互联网收发订单iOS 自带了一些用于处理网络的神奇功能，尤其是 URLSession 类，它让发送和接收数据变得异常简单。如果我们将其与 Codable 结合，将 Swift 对象转换为 JSON 或从 JSON 转换为 Swift 对象，我们就可以使用新的 URLRequest 结构来准确配置数据的发送方式，这样我们只需编写约 20 行代码就能完成大量工作。 首先，让我们创建一个可以从 “下订单 “按钮调用的方法–将其添加到 CheckoutView ： 12func placeOrder() async &#123;&#125; 就像我们使用 URLSession 下载数据一样，上传也是异步完成的。 现在将 “下订单 “按钮修改为 12Button(&quot;Place Order&quot;, action: placeOrder) .padding() 这段代码不会工作，Swift 会相当清楚地说明原因：它从一个不支持并发的函数中调用了一个异步函数。这意味着我们的按钮希望能够立即运行其操作，而不理解如何等待–即使我们写了 await placeOrder() ，它仍然不会工作，因为按钮不想等待。 之前我提到 onAppear() 无法与这些异步函数配合使用，因此我们需要使用 task() 修改器。但 Swift 提供了另一种选择：我们可以凭空创建一个新任务，就像 task() 修改器一样，它可以运行我们想要的任何异步代码。 事实上，我们只需将 await 调用放在任务中即可，就像这样： 12345Button(&quot;Place Order&quot;) &#123; Task &#123; await placeOrder() &#125;&#125; 现在我们一切就绪–这段代码将以异步方式调用 placeOrder() 。当然，这个函数实际上还没有做任何事情，所以我们现在来解决这个问题。 在 placeOrder() 内部，我们需要做三件事： 将当前 order 对象转换成可以发送的 JSON 数据。告诉 Swift 如何通过网络呼叫发送数据。运行该请求并处理响应。其中第一项很简单，让我们先把它做完。我们将使用 JSONEncoder 来存档我们的订单，在 placeOrder() 中添加以下代码： 1234guard let encoded = try? JSONEncoder().encode(order) else &#123; print(&quot;Failed to encode order&quot;) return&#125; 由于 Order 类不符合 Codable 协议，所以这段代码还不能工作。不过这很容易修改，只需将其类定义修改为以下内容即可： 1class Order: Codable &#123; 第二步是使用一种名为 URLRequest 的新类型，它与 URL 类似，只是提供了添加额外信息（如请求类型、用户数据等）的选项。 我们需要以非常特殊的方式附加数据，以便服务器能正确处理，这意味着除了订单之外，我们还需要提供两个额外的数据： 请求的 HTTP 方法决定了数据的发送方式。HTTP 方法有多种，但在实际应用中，只有 GET（”我想读取数据”）和 POST（”我想写入数据”）使用较多。我们想在这里写入数据，所以我们将使用 POST。请求的内容类型决定了发送的数据类型，从而影响服务器处理数据的方式。这种类型被称为 MIME 类型，最初是用于发送电子邮件的附件，它有数千个高度特定的选项。因此， placeOrder() 的下一步代码将是创建 URLRequest 对象，然后将其配置为使用 HTTP POST 请求发送 JSON 数据。然后，我们就可以使用 URLSession 上传数据，并处理任何返回的数据。 当然，真正的问题是向哪里发送我们的请求，我想你并不想为了学习本教程而设置自己的网络服务器。因此，我们将使用一个非常有用的网站 https://reqres.in，它可以让我们发送任何数据，并自动将数据发送回来。这是一种很好的网络代码原型开发方式，因为无论你发送什么，都会得到真实的数据。 立即将此代码添加到 placeOrder() ： 1234let url = URL(string: &quot;https://reqres.in/api/cupcakes&quot;)!var request = URLRequest(url: url)request.setValue(&quot;application/json&quot;, forHTTPHeaderField: &quot;Content-Type&quot;)request.httpMethod = &quot;POST&quot; 第一行包含了对 URL(string:) 初始化器的强制解缠，意思是 “这将返回一个可选的 URL，但请将其强制为非可选的”。从字符串创建 URL 可能会因为插入了一些胡言乱语而失败，但在这里，我手工键入了 URL，所以我可以看到它始终是正确的–这里没有可能导致问题的字符串插值。 至此，我们就可以进行网络请求了，我们将使用名为 URLSession.shared.upload() 的新方法和刚才的 URL 请求来进行网络请求。因此，请将此添加到 placeOrder() ： 123456do &#123; let (data, _) = try await URLSession.shared.upload(for: request, from: encoded) // handle the result &#125; catch &#123; print(&quot;Checkout failed: \\(error.localizedDescription)&quot;)&#125; 现在开始重要的工作：我们需要在一切正常的情况下读取请求结果。如果出了问题，也许是因为没有互联网连接，那么我们的 catch 程序块就会运行，因此我们不必担心这个问题。 因为我们使用的是 ReqRes.in，所以实际上我们会得到与发送时相同的订单，这意味着我们可以使用 JSONDecoder 将其从 JSON 转换为对象。 为了确认一切工作正常，我们将显示一个包含订单详细信息的警报，但我们将使用 ReqRes.in 发回的解码订单。是的，这应该与我们发送的订单完全一致，如果不一致，就说明我们的编码出错了。 显示警报需要存储信息和是否可见的属性，因此请立即将这两个新属性添加到 CheckoutView ： 12@State private var confirmationMessage = &quot;&quot;@State private var showingConfirmation = false 我们还需要附加一个 alert() 修改器来监视布尔值，并在布尔值为真时立即显示警报。将此修改器添加到 CheckoutView 中的导航标题修改器下方： 12345.alert(&quot;Thank you!&quot;, isPresented: $showingConfirmation) &#123; Button(&quot;OK&quot;) &#123; &#125;&#125; message: &#123; Text(confirmationMessage)&#125; 现在我们可以完成网络代码了：我们将解码传回的数据，用它来设置确认信息属性，然后将 showingConfirmation 设置为 true，这样警报就会出现。如果解码失败，即服务器因某种原因发回的数据不是订单，我们将只打印一条错误信息。 将最后这段代码添加到 placeOrder() ，替换 &#x2F;&#x2F; handle the result 注释： 123let decodedOrder = try JSONDecoder().decode(Order.self, from: data)confirmationMessage = &quot;Your order for \\(decodedOrder.quantity)x \\(Order.types[decodedOrder.type].lowercased()) cupcakes is on its way!&quot;showingConfirmation = true 如果您现在试着运行它，您应该可以准确地选择您想要的蛋糕，输入您的送货信息，然后按下 “下订单”，就会看到一个提示–一切都运行得很好！ 但我们还没有完全完成，因为现在我们的网络有一个小问题，但看不见。为了了解问题所在，我想向您介绍一下使用 Xcode 进行调试的小技巧：我们将暂停应用程序，以便检查一个特定的值。 首先，点击 “let url &#x3D; URL…” 行旁边的行号。那里会出现一个蓝色箭头，这是 Xcode 表示我们在那里设置了一个断点的方式。当执行到该行时，Xcode 就会暂停执行，这样我们就可以查看所有数据了。 现在再次运行应用程序，输入一些发货数据，然后下订单。如果一切顺利，您的应用程序就会暂停，Xcode 就会显示在前面，那行代码也会高亮显示，因为它即将运行。 如果一切顺利，您应该会在 Xcode 窗口的右下方看到 Xcode 的调试控制台–它通常会显示 Apple 的所有内部日志信息，但现在它应该显示”(ldb)”。LLDB 是 Xcode 调试器的名称，我们可以在这里运行命令来探索数据。 我想让你在那里运行这条命令： p String(decoding: encoded, as: UTF8.self) 。该命令会将编码数据转换为字符串并打印出来。你会看到它有很多下划线变量名，以及 @Observable 宏提供给我们的观测注册器。 我们的代码实际上并不关心这个，因为我们发送的所有属性都是带下划线的名称，ReqRes.in 服务器返回给我们的也是同样的名称，而我们将它们解码为带下划线的属性。但是，当你使用真正的服务器时，这些名称就很重要了–你需要发送实际的名称，而不是由 @Observable 宏生成的奇怪版本。 这意味着我们需要为 Order 类创建一些自定义编码键。这相当繁琐，尤其是像这个类这样需要保存和加载大量属性的类，但这是确保正确联网的最佳方法。 因此，打开 Order 类并在其中添加嵌套枚举： 1234567891011enum CodingKeys: String, CodingKey &#123; case _type = &quot;type&quot; case _quantity = &quot;quantity&quot; case _specialRequestEnabled = &quot;specialRequestEnabled&quot; case _extraFrosting = &quot;extraFrosting&quot; case _addSprinkles = &quot;addSprinkles&quot; case _name = &quot;name&quot; case _city = &quot;city&quot; case _streetAddress = &quot;streetAddress&quot; case _zip = &quot;zip&quot;&#125; 如果再次运行代码，你会发现可以通过按向上光标键和回车键再次运行 p 命令，这次发送和接收的数据要干净得多。 有了这些最后的代码，我们的网络代码就完成了，事实上，我们的应用程序也完成了。 我们完成了！好吧，我完成了 - 你们还有一些挑战要完成！ 纸杯蛋糕角总结希望这个项目能向您展示如何将您所掌握的 SwiftUI 表单、拾取器、步进器和导航等技能运用到应用程序中，将用户的所有数据发送到服务器并处理响应。 你可能还没有意识到这一点，但你在这个项目中学到的技能对于绝大多数 iOS 开发人员来说都是最重要的技能：获取用户数据、将其发送到服务器并处理响应，这可能是现存非大型应用程序的半壁江山。是的，发送什么数据以及如何使用这些数据更新 UI 有很大不同，但概念是相同的。 回顾所学知识任何人都可以看完教程，但要记住教程的内容却需要付出实际的努力。我的工作就是确保你从这些教程中尽可能多地吸收知识，因此我准备了一份简短的复习资料，帮助你检查自己的学习情况。 单击此处复习在本项目中学到的知识。 挑战学习的最佳方法之一就是尽可能多地编写自己的代码，因此，以下三种方法是你应该尝试扩展此应用程序，以确保你完全理解发生了什么。 目前，如果地址字段包含任何内容，即使只是空白，也会被视为有效。改进验证方法，确保纯空格字符串无效。 如果我们对 placeOrder() 的调用失败（例如在没有互联网连接的情况下），请向用户显示一个提示信息。要测试这一点，请尝试注释掉代码中的 request.httpMethod &#x3D; “POST” 行，这将迫使请求失败。 对于更具挑战性的任务，可以尝试更新 Order 类，以便将用户的收货地址等数据保存到 UserDefaults 。这需要花点心思，因为 @AppStorage 在这里不起作用，而且你会发现 getters 和 setters 会给 Codable 的支持带来问题。您能找到一个中间方案吗？（这个未完成）","categories":[{"name":"技术","slug":"技术","permalink":"https://blog.five2fire.top/categories/%E6%8A%80%E6%9C%AF/"}],"tags":[{"name":"编程","slug":"编程","permalink":"https://blog.five2fire.top/tags/%E7%BC%96%E7%A8%8B/"},{"name":"Swift","slug":"Swift","permalink":"https://blog.five2fire.top/tags/Swift/"},{"name":"Hacking with Swift","slug":"Hacking-with-Swift","permalink":"https://blog.five2fire.top/tags/Hacking-with-Swift/"}]},{"title":"【Hacking With Swift】Project9_Navigation","slug":"Project9_Navigation","date":"2024-06-26T01:35:03.000Z","updated":"2025-01-02T02:17:10.820Z","comments":true,"path":"article/33439.html","permalink":"https://blog.five2fire.top/article/33439.html","excerpt":"","text":"英文原博博主是 Paul Hudson @twostraws 本文是学习Swift过程中翻译该网站的内容: https://www.hackingwithswift.com/ 今天启动另一个新技术项目，我们将重点关注导航。这是我们在上一个项目中简单触及的 SwiftUI 领域，但它确实是您将构建的几乎每个应用程序的核心。 正如您将看到的，导航实际上分为两种主要类型：由用户交互驱动的导航和您自己触发的编程导航。两者都很重要，您会发现自己可以自由地混合两者。 导航：简介在这个技术项目中，我们将仔细研究 SwiftUI 中的导航 - 我们如何使用 NavigationStack 从一个屏幕移动到另一个屏幕，这既是因为用户要求这样做，也是因为我们想要这样做在特定时间自动。 介绍完这些基础知识后，我们将了解更高级的导航，包括处理状态恢复 - 准确记住用户导航到的位置，以便当您的应用将来启动时，他们可以从上次中断的地方继续。 完成后，我们将查看一些自定义选项：更改导航栏的外观、将按钮放置在正确的位置，甚至如何让用户根据需要更改导航标题。 需要填充的内容有很多，但到最后，您将对 SwiftUI 中的导航工作原理有更深入的了解，这样您就可以在所有应用程序中真正充分利用它。 请创建一个名为“导航”的新应用程序项目，让我们开始吧…… 简单的NavigationLink的问题如果你使用这样的代码创建详细视图，你会发现有一些问题 1234567891011121314151617181920struct DetailView: View &#123; var number: Int var body: some View &#123; Text(&quot;Detail View \\(number)&quot;) &#125; init(number: Int) &#123; self.number = number print(&quot;Creating detail view \\(number)&quot;) &#125;&#125;NavigationStack &#123; List(0..&lt;1000) &#123; i in NavigationLink(&quot;Tap Me&quot;) &#123; DetailView(number: i) &#125; &#125;&#125; 你会发现，现在，当您滚动时，您会看到许多 DetailView 实例正在创建，而且通常不止一次。 也就是说，你还没点进去视图呢，视图就已经被创建了。 这使得 Swift 和 SwiftUI 做了比必要的更多的工作，因此当您处理动态数据时 – 例如，当您有许多不同的整数以相同的方式显示时 – SwiftUI 为我们提供了更好的解决方案：附加我们的导航链接的呈现值。 使用 navigationDestination() 以智能方式处理导航对于一个简单的导航形式，如下所示 12345NavigationStack &#123; NavigationLink(&quot;Tap Me&quot;) &#123; Text(&quot;Detail View&quot;) &#125;&#125; 但对于更高级的导航，最好将目的地与值分开。这允许 SwiftUI 仅在需要时加载目标。 执行此操作需要两个步骤： 我们为 NavigationLink 附加一个值。该值可以是您想要的任何值 - 字符串、整数、自定义结构实例或其他任何值。但是，有一个要求：无论您使用什么类型，都必须符合名为 Hashable 的协议。 在导航堆栈中附加一个 navigationDestination() 修饰符，告诉它收到数据后要做什么。 这两个都是新的只是，但一开始你可以忽略 Hashable 要求，因为大多数 Swift 的内置类型已经符合 Hashable 。例如， Int 、 String 、 Date 、 URL 、数组和字典已经符合 Hashable ，所以你不需要担心他们。 因此，让我们首先看一下 navigationDestination() 修饰符，然后再回头更详细地看一下 Hashable 。 首先，我们可以创建一个由 100 个数字组成的 List ，每个数字都附加到一个导航链接作为其表示值 - 我们告诉 SwiftUI 我们想要导航到一个数字。看起来是这样的： 12345NavigationStack &#123; List(0..&lt;100) &#123; i in NavigationLink(&quot;Select \\(i)&quot;, value: i) &#125;&#125; 现在，该代码还不够。是的，我们已经告诉 SwiftUI 我们希望在点击“Select 0”时导航到 0，但我们还没有说明如何显示该数据。它应该是一些文本、带有一些图片的 VStack 、自定义 SwiftUI 视图还是完全其他的东西？ 这就是 navigationDestination() 修饰符的用武之地：我们可以告诉它“当你被要求导航到一个整数时，这是你应该做的……” 将您的代码修改为： 12345678NavigationStack &#123; List(0..&lt;100) &#123; i in NavigationLink(&quot;Select \\(i)&quot;, value: i) &#125; .navigationDestination(for: Int.self) &#123; selection in Text(&quot;You selected \\(selection)&quot;) &#125;&#125; 因此，当 SwiftUI 尝试导航到任何 Int 值时，它会在 selection 常量中为我们提供该值，并且我们需要返回正确的 SwiftUI 视图来显示它。 提示：如果您有多种不同类型的数据要导航到它们，只需添加几个 navigationDestination() 修饰符即可。实际上，您是在说，“当您想要导航到整数时执行此操作，但当您想导航到字符串时执行此操作。” 这对于大量数据非常有效，例如导航到字符串、整数和 UUID。但对于更复杂的数据（例如自定义结构），我们需要使用哈希。 Swift 在内部大量使用 Hashable 。例如，当您使用 Set 而不是数组时，您放入其中的所有内容都必须符合 Hashable 协议。这就是集合比数组更快的原因：当您说“集合是否包含这个特定对象？”时Swift 将计算对象的哈希值，然后在集合中搜索该哈希值，而不是尝试将每个属性与每个对象进行比较。 如果这一切听起来很复杂，请记住 Swift 的大多数内置类型已经符合 Hashable 。如果您创建一个具有全部符合 Hashable 属性的自定义结构，则只需进行一个微小的更改即可使整个结构符合 Hashable 。 例如，此结构包含一个 UUID、一个字符串和一个整数： 12345struct Student &#123; var id = UUID() var name: String var age: Int&#125; 如果我们想让该结构符合 Hashable ，我们只需添加如下协议： 12345struct Student: Hashable &#123; var id = UUID() var name: String var age: Int&#125; 现在我们的 Student 结构符合 Hashable 它可以与 NavigationLink 和 navigationDestination() 一起使用，就像整数或字符串一样 使用 NavigationStack 进行编程导航我们可以通过设定一个路径，来控制从一个视图移动到另一个视图，像这样 1234567891011121314struct ContentView: View &#123; @State private var path = [Int]() var body: some View &#123; NavigationStack(path: $path) &#123; VStack &#123; // more code to come &#125; .navigationDestination(for: Int.self) &#123; selection in Text(&quot;You selected \\(selection)&quot;) &#125; &#125; &#125;&#125; 这做了两件重要的事情： 它创建一个 @State 属性来存储整数数组。 它将该属性绑定到 NavigationStack 的 path ，这意味着更改数组将自动导航到数组中的任何内容，而且当用户按 Back 时也会更改数组导航栏。 因此，我们可以通过按钮向路径中加入数字 1234567Button(&quot;Show 32&quot;) &#123; path = [32]&#125;Button(&quot;Show 64&quot;) &#123; path.append(64)&#125; 在第一个按钮中，我们设置整个数组，使其仅包含数字 32。如果数组中发生其他任何内容，它将被删除，这意味着 NavigationStack 将返回到其原始状态在导航到数字 32 之前。 在第二个按钮中，我们附加 64，这意味着它将添加到我们导航到的任何内容中。因此，如果我们的数组已经包含 32，那么我们现在在堆栈中将拥有三个视图：原始视图（称为“根”视图），然后是显示数字 32 的视图，最后是显示数字 64 的视图。 您还可以同时推送多个值，如下所示： 123Button(&quot;Show 32 then 64&quot;) &#123; path = [32, 64]&#125; 这将显示 32 的视图，然后显示 64 的视图，因此用户需要点击“返回”两次才能返回到根视图。 您可以根据需要混合用户导航和编程导航 - SwiftUI 将负责确保您的 path 数组与您显示的任何数据保持同步，无论其显示方式如何。 使用 NavigationPath 导航到不同的数据类型导航到不同的数据类型采用两种形式之一。最简单的是当您将 navigationDestination() 与不同的数据类型一起使用时，但您没有跟踪显示的确切路径，因为这里的事情很简单：只需多次添加 navigationDestination() ，对于您想要的每种数据类型一次。 例如，我们可以显示五个数字和五个字符串，并以不同的方式导航到它们： 1234567891011121314151617NavigationStack &#123; List &#123; ForEach(0..&lt;5) &#123; i in NavigationLink(&quot;Select Number: \\(i)&quot;, value: i) &#125; ForEach(0..&lt;5) &#123; i in NavigationLink(&quot;Select String: \\(i)&quot;, value: String(i)) &#125; &#125; .navigationDestination(for: Int.self) &#123; selection in Text(&quot;You selected the number \\(selection)&quot;) &#125; .navigationDestination(for: String.self) &#123; selection in Text(&quot;You selected the string \\(selection)&quot;) &#125;&#125; 但是，当您想要添加编程导航时，事情会变得更加复杂，因为您需要能够将一些数据绑定到导航堆栈的路径。之前我向您展示了如何使用整数数组执行此操作，但现在我们可能有整数或字符串，因此我们不能再使用简单的数组。 因为一个数组只能包含一种固定的数据类型，所以SwiftUI 的解决方案是一种名为 NavigationPath 的特殊类型，它能够在单个路径中保存多种数据类型。实际上，它的工作方式与数组非常相似——我们可以使用它创建一个属性，并绑定到NavigationStack 如下所示： 123@State private var path = NavigationPath()NavigationStack(path: $path) &#123; 然后以编程方式将内容推送到它，例如使用工具栏按钮： 123456789.toolbar &#123; Button(&quot;Push 556&quot;) &#123; path.append(556) &#125; Button(&quot;Push Hello&quot;) &#123; path.append(&quot;Hello&quot;) &#125;&#125; 如果您想感觉更奇特， NavigationPath 就是我们所说的类型擦除器 - 它存储任何类型的 Hashable 数据，而不暴露每个项目的数据类型。 如何以编程方式使 NavigationStack 返回其根视图通常在 NavigationStack 中深入几个级别，然后决定要返回到开头。例如，也许您的用户正在下订单，并通过显示购物篮的屏幕进行操作，询问运输详细信息，询问付款详细信息，然后确认订单，但是当他们完成后，您想返回到最开始的界面。开始 – 返回 NavigationStack 的根视图。 为了证明这一点，我们可以创建一个小沙箱，它可以通过每次生成新的随机数来不断地推送新视图。 首先，这是我们的 DetailView ，它将当前数字显示为标题，并有一个按钮，只要按下它就会推送到新的随机数字： 12345678struct DetailView: View &#123; var number: Int var body: some View &#123; NavigationLink(&quot;Go to Random Number&quot;, value: Int.random(in: 1...1000)) .navigationTitle(&quot;Number: \\(number)&quot;) &#125;&#125; 现在我们可以从 ContentView 中呈现它，从初始值 0 开始，但每次显示新整数时导航到新的 DetailView ： 123456789101112struct ContentView: View &#123; @State private var path = [Int]() var body: some View &#123; NavigationStack(path: $path) &#123; DetailView(number: 0) .navigationDestination(for: Int.self) &#123; i in DetailView(number: i) &#125; &#125; &#125;&#125; 效果是这样的： 现在，如果您深入其中 10 次查看并决定回家，您有两个选择： 如果您使用简单的数组作为路径，就像我们在上面的代码中所做的那样，您可以在该数组上调用 removeAll() 来删除路径中的所有内容，然后返回到根视图。 如果您使用 NavigationPath 作为路径，则可以将其设置为 NavigationPath 的新空实例，如下所示： path &#x3D; NavigationPath() 。 但是，还有一个更大的问题：当您无权访问原始 path 属性时，如何从子视图中执行此操作？ 这里有两个选择：要么将路径存储在使用 @Observable 的外部类中，要么引入一个名为 @Binding 的新属性包装器。我之前已经演示过 @Observable ，所以我们在这里重点关注 @Binding 。 您已经了解了 @State 如何让我们在视图中创建一些存储，以便我们可以在应用程序运行时修改值。 @Binding 属性包装器允许我们将 @State 属性传递到另一个视图并从那里修改它 - 我们可以在多个地方共享 @State 属性，并更改它在一个地方会改变它在任何地方。 在我们当前的代码中，这意味着向 DetailView 添加一个新属性以访问导航路径数组： 1@Binding var path: [Int] 现在我们需要从 ContentView 中使用 DetailView 的两个地方传递它，如下所示： 1234DetailView(number: 0, path: $path) .navigationDestination(for: Int.self) &#123; i in DetailView(number: i, path: $path) &#125; 正如您所看到的，我们传入 $path 是因为我们想要传入绑定 - 我们希望 DetailView 能够读取和写入路径。 现在我们可以向 DetailView 添加一个工具栏来操作路径数组： 12345.toolbar &#123; Button(&quot;Home&quot;) &#123; path.removeAll() &#125;&#125; 如果你使用 NavigationPath 你会使用这个： 12345.toolbar &#123; Button(&quot;Home&quot;) &#123; path = NavigationPath() &#125;&#125; 像这样共享绑定很常见 - 这正是 TextField 、 Stepper 和其他控件的工作方式。事实上，当我们创建自己的自定义组件时，我们将在项目 11 中再次查看 @Binding ，因为它确实很有帮助。 在运行过程中，我发现虽然第三个第四个以及之后所有的都是随机的数字，但number0的下一个视图，也就是第二个视图都是一个固定数字，而我在代码里已经用random来生成视图了，这是为什么？ 这个问题出现的原因是因为 NavigationLink 创建的目标视图在初次加载时就已经决定了，不会在每次点击时重新计算随机数。因此，第一个 NavigationLink 生成的随机数在应用启动时就已经固定下来。 如果想要每次都是随机的，可以这样修改 1234567891011121314151617struct DetailView: View &#123; var number: Int @Binding var path: [Int] var body: some View &#123; VStack &#123; Button(action: &#123; let randomNumber = Int.random(in: 1...1000) path.append(randomNumber) &#125;) &#123; Text(&quot;Go to Random Number&quot;) &#125; .navigationTitle(&quot;Number: \\(number)&quot;) &#125; &#125;&#125; 如何使用 Codable 保存 NavigationStack 路径您可以通过以下两种方式之一使用 Codable 保存和加载导航堆栈路径，具体取决于您拥有的路径类型： 如果您使用 NavigationPath 来存储 NavigationStack 的活动路径，SwiftUI 会提供两个帮助器来更轻松地保存和加载路径。 如果您使用同质数组 – 例如 [Int] 或 [String] – 那么你不需要这些助手，你可以自由地加载或保存你的数据。 这些技术非常相似，因此我将在这里介绍它们。 两者都依赖于将路径存储在视图之外，因此路径数据的所有加载和保存都是在不可见的情况下发生的 - 外部类会自动处理它。更准确地说，每当我们的路径数据发生变化时——无论是整数或字符串数​​组，还是 NavigationPath 对象——我们都需要保存新路径，以便将来保留它，并且我们将当类初始化时，还会从磁盘加载该数据。 当我们的路径数据存储为整数数组时，该类的外观如下： 12345678910111213141516171819202122232425262728293031@Observableclass PathStore &#123; var path: [Int] &#123; didSet &#123; save() &#125; &#125; private let savePath = URL.documentsDirectory.appending(path: &quot;SavedPath&quot;) init() &#123; if let data = try? Data(contentsOf: savePath) &#123; if let decoded = try? JSONDecoder().decode([Int].self, from: data) &#123; path = decoded return &#125; &#125; // Still here? Start with an empty path. path = [] &#125; func save() &#123; do &#123; let data = try JSONEncoder().encode(path) try data.write(to: savePath) &#125; catch &#123; print(&quot;Failed to save navigation data&quot;) &#125; &#125;&#125; 如果您使用 NavigationPath ，则只需进行四个小更改。 1234567891011121314151617var path: NavigationPath &#123; didSet &#123; save() &#125;&#125;/*******************************/if let decoded = try? JSONDecoder().decode(NavigationPath.CodableRepresentation.self, from: data) &#123; path = NavigationPath(decoded) return&#125;/*******************************/path = NavigationPath()/*******************************//**在 save() 方法的开头添加一个检查，该方法尝试检索 Codable 导航路径，如果我们没有得到任何返回，则立即退出：**/guard let representation = path.codable else &#123; return &#125;let data = try JSONEncoder().encode(representation) 现在您可以继续正常编写 SwiftUI 代码，确保将 NavigationStack 的路径绑定到 PathStore 实例的 path 属性。例如，这可以让您显示附加随机整数的视图 - 您可以推送任意数量的视图，然后安静并重新启动应用程序以使其完全恢复为您离开时的状态： 123456789101112131415161718192021struct DetailView: View &#123; var number: Int var body: some View &#123; NavigationLink(&quot;Go to Random Number&quot;, value: Int.random(in: 1...1000)) .navigationTitle(&quot;Number: \\(number)&quot;) &#125;&#125;struct ContentView: View &#123; @State private var pathStore = PathStore() var body: some View &#123; NavigationStack(path: $pathStore.path) &#123; DetailView(number: 0) .navigationDestination(for: Int.self) &#123; i in DetailView(number: i) &#125; &#125; &#125;&#125; 自定义导航栏外观iOS 喜欢它的导航栏看起来非常特别，但我们对其样式的控制确实有限。 首先，您已经了解了如何使用大型或内联导航标题样式，从而在顶部提供大型或小型文本。因此，这将在顶部使用一个小标题： 1234567NavigationStack &#123; List(0..&lt;100) &#123; i in Text(&quot;Row \\(i)&quot;) &#125; .navigationTitle(&quot;Title goes here&quot;) .navigationBarTitleDisplayMode(.inline)&#125; 您会看到顶部的导航栏默认情况下是不可见的，但只要向上滚动一点，它就会变成纯灰色背景，以便其标题从列表的内容中清晰地突出。 SwiftUI 让我们可以稍微自定义一下：我们可以指定用于该背景的替代颜色。请记住，只有当列表在导航栏下方滚动时，此信息才可见，因此您一开始不会看到它。 要尝试一下，请在 navigationBarTitleDisplayMode() 下面添加以下内容： 1.toolbarBackground(.blue) 效果如图 当您运行应用程序并稍微滚动时，您会看到导航栏变成纯蓝色。您还会发现标题可能难以阅读，因为在浅色模式下它会是黑色文本。您可以通过在前一个修饰符下方添加另一个修饰符来解决此问题，强制导航栏始终使用深色模式，这又意味着标题文本将为白色： 1.toolbarColorScheme(.dark) 提示：稍后您将遇到其他类型的工具栏。这两个修饰符会影响所有栏，但如果您只想修改导航栏，则应将 for: .navigationBar 作为第二个参数添加到它们中。 自定义导航栏还有最后一种方法：您可以始终隐藏它或根据应用程序中的当前状态隐藏它。 为此，请将 toolbar() 修饰符设置为 .hidden ，对于所有栏或仅导航栏： 1.toolbar(.hidden, for: .navigationBar) 隐藏工具栏不会阻止您导航到新视图，但可能会导致滚动视图位于时钟等系统信息下 - 请小心！ 将工具栏按钮放置在某个特定位置如果您将按钮放置在 NavigationStack 工具栏中，SwiftUI 将根据您的代码运行的平台自动放置它们。我们在这里构建 iOS 应用程序，这意味着我们的按钮将放置在导航栏的右侧，并且使用从左到右阅读的语言（例如英语）。 如果需要，您可以使用 ToolbarItem 进行自定义。它围绕着您的工具栏按钮，允许您通过从多个选项之一中进行选择，将它们准确地放置在您想要的位置。 例如，我们可以要求像这样的左侧放置： 12345678910NavigationStack &#123; Text(&quot;Hello, world!&quot;) .toolbar &#123; ToolbarItem(placement: .topBarLeading) &#123; Button(&quot;Tap Me&quot;) &#123; // button action here &#125; &#125; &#125;&#125; 尽管这种方法效果很好，但通常最好使用语义选项之一 - 具有特定含义的放置，而不是仅仅依赖于它们的位置。这些包括： .confirmationAction ，当您希望用户同意某件事时，例如同意服务条款。 .destructiveAction ，当用户需要选择销毁他们正在使用的任何内容时，例如确认他们想要删除他们创建的一些数据。 .cancellationAction，当用户需要撤销他们所做的更改时，例如放弃他们所做的更改。 .navigation ，用于使用户在数据之间移动的按钮，例如在 Web 浏览器中后退和前进。 这些语义布局有两个重要的好处。首先，由于 iOS 拥有有关按钮功能的额外信息，因此它可以添加额外的样式 - 例如，确认按钮可以以粗体呈现。其次，这些位置会自动适应其他平台，因此您的按钮将始终显示在 iOS、macOS、watchOS 等平台上的正确位置。 提示：如果您需要用户决定保存更改还是放弃更改，您可能需要添加 navigationBarBackButtonHidden() 修饰符，以便他们在没有做出选择的情况下无法点击“返回”退出。 如果您希望多个按钮使用相同的位置，您可以像这样重复 ToolbarItem ： 12345678910111213.toolbar &#123; ToolbarItem(placement: .topBarLeading) &#123; Button(&quot;Tap Me&quot;) &#123; // button action here &#125; &#125; ToolbarItem(placement: .topBarLeading) &#123; Button(&quot;Or Tap Me&quot;) &#123; // button action here &#125; &#125;&#125; 或者您可以使用 ToolbarItemGroup ，如下所示： 1234567891011.toolbar &#123; ToolbarItemGroup(placement: .topBarLeading) &#123; Button(&quot;Tap Me&quot;) &#123; // button action here &#125; Button(&quot;Tap Me 2&quot;) &#123; // button action here &#125; &#125;&#125; 使您的导航标题可编辑基本的 navigationTitle() 修饰符让我们在导航栏中显示一个字符串，如下所示： 12345678struct ContentView: View &#123; var body: some View &#123; NavigationStack &#123; Text(&quot;Hello, world!&quot;) .navigationTitle(&quot;SwiftUI&quot;) &#125; &#125;&#125; 但如果您使用 .inline 标题显示模式，您还可以将绑定传递给 navigationTitle() 。然后，这将像往常一样显示，但有一个重要的补充：iOS 将在您的标题旁边显示一个小箭头，显示一个“重命名”按钮来更改标题。代码如下： 1234567891011struct ContentView: View &#123; @State private var title = &quot;SwiftUI&quot; var body: some View &#123; NavigationStack &#123; Text(&quot;Hello, world!&quot;) .navigationTitle($title) .navigationBarTitleDisplayMode(.inline) &#125; &#125;&#125; 当标题反映用户输入的内容的名称时，这非常有用，因为这意味着您不需要在布局中添加额外的文本字段。","categories":[{"name":"技术","slug":"技术","permalink":"https://blog.five2fire.top/categories/%E6%8A%80%E6%9C%AF/"}],"tags":[{"name":"编程","slug":"编程","permalink":"https://blog.five2fire.top/tags/%E7%BC%96%E7%A8%8B/"},{"name":"Swift","slug":"Swift","permalink":"https://blog.five2fire.top/tags/Swift/"},{"name":"Hacking with Swift","slug":"Hacking-with-Swift","permalink":"https://blog.five2fire.top/tags/Hacking-with-Swift/"}]},{"title":"【Hacking With Swift】project8_MoonShot","slug":"Project8_MoonShot","date":"2024-06-25T09:07:23.000Z","updated":"2025-01-02T02:17:10.817Z","comments":true,"path":"article/53249.html","permalink":"https://blog.five2fire.top/article/53249.html","excerpt":"","text":"英文原博博主是 Paul Hudson @twostraws 本文是学习Swift过程中翻译该网站的内容: https://www.hackingwithswift.com/ 引入在这个项目中，我们将构建一个应用程序，让用户了解组成 NASA 阿波罗太空计划的任务和宇航员。您将获得更多使用 Codable 的经验，但更重要的是，您还将使用滚动视图、导航和更有趣的布局。 是的，您将获得一些使用 List 、 Text 等内容的练习时间，但您还将开始解决重要的 SwiftUI 问题 – 如何使图像适合其空间正确吗？我们如何使用计算属性来清理代码？我们如何将较小的视图组合成较大的视图以帮助保持我们的项目井井有条？ 一如既往，有很多事情要做，所以让我们开始吧：使用应用程序模板创建一个新的 iOS 应用程序，并将其命名为“Moonshot”。我们将在项目中使用它，但首先让我们仔细看看您需要熟悉的新技术…… 调整图像大小以适合可用的空间首先在项目中导入一个图片“example”，我们可以这样在视图中调用它 12345struct ContentView: View &#123; var body: some View &#123; Image(&quot;Example&quot;) &#125;&#125; 你也可以将“example”替换成.example ，这在SwiftUI中将会更安全。 此时你想要修改这个图像的大小，因为他看起来有些大。图像是一个视图，它和其他视图一样都有frame() 修饰符，所以可以尝试添加这个修饰符 12Image(.example) .frame(width: 300, height: 300) 然而，这是行不通的——你的图像仍然会显示为完整尺寸。如果您想知道原因，请将 Xcode 的预览模式从“实时”更改为“可选”——查找 Xcode 预览左下角的三个按钮，然后单击其中有鼠标光标的按钮。 启用可选模式后，仔细查看预览窗口：您会看到图像是全尺寸的，但现在有一个 300x300 的框位于中间。图像视图的框架已正确设置，但图像内容仍按其原始大小显示 这样更改 123Image(.example) .frame(width: 300, height: 300) .clipped() 现在你会看得更清楚了：我们的图像视图确实是 300x300，但这并不是我们真正想要的。 也许你需要添加.resizable() 修饰符，就像这样 123Image(.example) .resizable() .frame(width: 300, height: 300) 但是现在你会看到，图像现在已正确调整大小，但它可能看起来被压扁了。我的图像不是方形的，所以现在它被调整为方形后看起来扭曲了。 这里给出两个方案，scaledToFit() 以及scaledToFill() ，你可以看到他的不同效果 如果我们想要固定大小的图像，那么所有这些都非常有用，但通常您希望图像能够自动放大以在一维或两个维度上填充更多屏幕。也就是说，您真正想说的是“使该图像填充屏幕宽度的 80%”，而不是硬编码宽度 300。、 wiftUI 没有强制使用特定的框架，而是有一个专用的 containerRelativeFrame() 修饰符，可以让我们准确地获得我们想要的结果。 “容器”部分可能是整个屏幕，但也可能只是该视图的直接父级占据的屏幕部分 - 也许我们的图像与其他视图一起显示在 VStack 内。 这是个占屏幕宽度80%的图像的例子 123456Image(.example) .resizable() .scaledToFit() .containerRelativeFrame(.horizontal) &#123; size, axis in size * 0.8 &#125; 我们不需要在这里指定高度。这是因为我们已经给了 SwiftUI 足够的信息，它可以自动计算出高度：它知道原始宽度，它知道我们的目标宽度，它知道我们的内容模式，所以它知道图像的目标高度将如何与目标宽度成正比。 滚动视图首先创建一个1——100的滚动列表 123456789ScrollView &#123; VStack(spacing: 10) &#123; ForEach(0..&lt;100) &#123; Text(&quot;Item \\($0)&quot;) .font(.title) &#125; &#125;&#125; 这些视图会立即创建，也就是说，在你还没有滚动到第100行的时候，它已经被创建好了，SwiftUI 不会等到你向下滚动才能看到它们，它只会立即创建它们。 为了演示这一点，我们可以围绕常规文本视图创建一个简单的包装器，并在ForEach中使用它，如下所示： 123456789101112131415161718struct CustomText: View &#123; let text: String var body: some View &#123; Text(text) &#125; init(_ text: String) &#123; print(&quot;Creating a new CustomText&quot;) self.text = text &#125;&#125;ForEach(0..&lt;100) &#123; CustomText(&quot;Item \\($0)&quot;) .font(.title)&#125; 你会看到“Creating a new CustomText”在 Xcode 日志中打印了一百次 如果您想避免这种情况发生，可以为 VStack 和 HStack 提供一个替代方案，分别称为 LazyVStack 和 LazyHStack 。它们的使用方式与常规堆栈完全相同，但会按需加载其内容 - 在实际显示之前它们不会创建视图，因此最大限度地减少了所使用的系统资源量。 最后，可以在创建 ScrollView 时通过传递 .horizontal 作为参数来创建水平滚动视图，传递.vertical参数创建垂直滚动视图（默认的） 使用 NavigationLink 将新视图推送到堆栈上SwiftUI 的 NavigationStack 在视图顶部显示一个导航栏，但还执行其他操作：它允许我们将视图推送到视图堆栈上。事实上，这确实是 iOS 导航的最基本形式 - 当您点击 Wi-Fi 或常规时，您可以在“设置”中看到它，或者当您点击某人的名字时，您可以在“消息”中看到它。 这个视图堆栈系统与我们之前使用的工作表（.sheet）非常不同。是的，两者都显示了某种新视图，但它们的呈现方式存在差异，影响了用户对它们的思考方式。 对比一下这两个代码 12345678910111213141516struct ContentView: View &#123; var body: some View &#123; NavigationStack &#123; Text(&quot;Tap Me&quot;) .navigationTitle(&quot;SwiftUI&quot;) &#125; NavigationStack &#123; NavigationLink(&quot;Tap Me&quot;) &#123; Text(&quot;Detail View&quot;) &#125; .navigationTitle(&quot;SwiftUI&quot;) &#125; &#125;&#125; 您会看到“点击我”现在看起来像一个按钮，点击它会使一个新视图从右侧滑入，显示“详细信息视图”。更好的是，您会看到“SwiftUI”标题向下动画变成后退按钮，您可以点击该按钮或从左边缘滑动以返回。 如果您想要简单文本视图以外的其他内容作为标签，则可以在 NavigationLink 中使用两个尾随闭包。例如，我们可以用多个文本视图和图像制作标签： 因此， sheet() 和 NavigationLink 都允许我们显示当前视图的新视图，但它们的方式不同，您应该仔细选择它们： NavigationLink 用于显示有关用户选择的详细信息，就像您正在深入研究某个主题一样。 sheet() 用于显示不相关的内容，例如设置或撰写窗口。 接下来用navigationlink改写ForEach列表： 12345678NavigationStack &#123; List(0..&lt;100) &#123; row in NavigationLink(&quot;Row \\(row)&quot;) &#123; Text(&quot;Detail \\(row)&quot;) &#125; &#125; .navigationTitle(&quot;SwiftUI&quot;)&#125; navifationlink后面跟随的闭包则是详细视图内的内容。 使用分层可编码数据（Working with hierarchical Codable data）``` 协议使得解码平面数据变得很简单：如果您正在解码类型的单个实例，或者这些实例的数组或字典，那么事情就可以了。然而，在这个项目中，我们将解码稍微复杂的 JSON：一个数组位于另一个数组中，使用不同的数据类型。123456789101112131415161718如果您想解码这种分层数据，关键是为每个级别创建单独的类型。只要数据与您要求的层次结构相匹配， ``` Codable``` 就能够解码所有内容，无需我们进行进一步的工作。为了演示这一点，请将此按钮放入您的内容视图中：```swiftButton(&quot;Decode JSON&quot;) &#123; let input = &quot;&quot;&quot; &#123; &quot;name&quot;: &quot;Taylor Swift&quot;, &quot;address&quot;: &#123; &quot;street&quot;: &quot;555, Taylor Swift Avenue&quot;, &quot;city&quot;: &quot;Nashville&quot; &#125; &#125; &quot;&quot;&quot; // more code to come&#125; 创建与json格式匹配的结构： 123456789struct User: Codable &#123; let name: String let address: Address&#125;struct Address: Codable &#123; let street: String let city: String&#125; 然后将解析步骤写入到按钮的执行函数中 12345let data = Data(input.utf8)let decoder = JSONDecoder()if let user = try? decoder.decode(User.self, from: data) &#123; print(user.address.street)&#125; 如果您运行该程序并点击按钮，您应该会看到打印出的地址。Codable 将经历的级别数量没有限制 - 重要的是您定义的结构与您的 JSON 字符串相匹配。 如何在滚动网格中布局视图我们前面学习过HStack以及VStack等，还有List来显示滚动数据行，但如果需要显示网格要如何做呢？——通过两个视图LazyVGrid 和 LazyHGrid。 LazyHGrid 用于显示水平数据， LazyVGrid 用于显示垂直数据。就像惰性堆栈一样，名称中的“惰性”部分之所以存在，是因为 SwiftUI 会自动延迟加载它包含的视图，直到需要它们的那一刻，这意味着我们可以显示更多数据，而无需消耗大量系统资源。 创建网格分两步完成。首先，我们需要定义我们想要的行或列——我们只定义两者之一，具体取决于我们想要哪种类型的网格。 例如，如果我们有一个垂直滚动的网格，那么我们可能会说，通过将此属性添加到我们的视图中，我们希望将数据布局在三列中，宽度正好为 80 点： 12345let layout = [ GridItem(.fixed(80)), GridItem(.fixed(80)), GridItem(.fixed(80))] 定义布局后，您应该将网格以及所需数量的项目放置在 ScrollView 内。您在网格中创建的每个项目都会自动分配一列，就像列表中的行自动放置在其父项中一样。例如，我们可以在三列网格内渲染 1000 个项目，如下所示： 1234567ScrollView &#123; LazyVGrid(columns: layout) &#123; ForEach(0..&lt;1000) &#123; Text(&quot;Item \\($0)&quot;) &#125; &#125;&#125; 还可以创建自适应各种屏幕尺寸的网格，同时指定每一列的最小宽度和最大宽度。SwiftUI会根据屏幕大小自动填充列数。 1234let layout = [ GridItem(.adaptive(minimum: 80, maximum: 120)),] 可以比较一下指定列宽以及自适应列数的效果 在我们完成之前，我想简要向您展示如何制作水平网格。该过程几乎相同，您只需使 ScrollView 水平工作，然后使用行而不是列创建 LazyHGrid 。同样的，如果你使用了自适应视图，那会自动填充行数 12345678ScrollView(.horizontal) &#123; LazyHGrid(rows: layout) &#123; ForEach(0..&lt;1000) &#123; Text(&quot;Item \\($0)&quot;) &#125; &#125;&#125; 正式开始构建项目加载特定类型的可编码数据在此应用程序中，我们将把两种不同类型的 JSON 加载到 Swift 结构中：一种用于宇航员，一种用于任务。以一种易于维护且不会使我们的代码混乱的方式实现这一点需要一些思考，但我们将逐步努力实现这一目标。 将两个JSON文件拖入项目内，分别是astronauts.json 和missions.json。 接下来让我们将宇航员数据转换为 Swift 结构 - 按 Cmd+N 创建一个新文件，选择 Swift 文件，然后将其命名为 Astronaut.swift。（根据json文件中的格式来创建） 12345struct Astronaut: Codable, Identifiable &#123; let id: String let name: String let description: String&#125; 接下来我们要将 astronauts.json 转换为 Astronaut 实例的字典，这意味着我们需要使用 Bundle 查找文件的路径，将其加载到 Data ，并将其传递给 JSONDecoder 。之前我们将其放入 ContentView 的方法中，但在这里我想向您展示一种更好的方法：我们将在 Bundle 上编写一个扩展来完成这一切一个集中的地方。 创建另一个新的 Swift 文件，这次名为 Bundle-Decodable.swift。这将主要使用您以前见过的代码，但有一个小区别：之前我们使用 String(contentsOf:) 将文件加载到字符串中，但因为 Codable 使用 Data 我们将使用 Data(contentsOf:) 。它的工作方式与 String(contentsOf:) 相同：给它一个要加载的文件 URL，它要么返回其内容，要么抛出错误。 现在将其添加到 Bundle-Decodable.swift 中： 12345678910111213141516171819extension Bundle &#123; func decode(_ file: String) -&gt; [String: Astronaut] &#123; guard let url = self.url(forResource: file, withExtension: nil) else &#123; fatalError(&quot;Failed to locate \\(file) in bundle.&quot;) &#125; guard let data = try? Data(contentsOf: url) else &#123; fatalError(&quot;Failed to load \\(file) from bundle.&quot;) &#125; let decoder = JSONDecoder() guard let loaded = try? decoder.decode([String: Astronaut].self, from: data) else &#123; fatalError(&quot;Failed to decode \\(file) from bundle.&quot;) &#125; return loaded &#125;&#125; 我们稍后会回到这个问题，但正如您所看到的，它充分利用了 fatalError() ：如果无法找到、加载或解码文件，应用程序将崩溃。不过，和以前一样，除非您犯了错误，否则这种情况永远不会真正发生，例如，如果您忘记将 JSON 文件复制到项目中。 现在，您可能想知道为什么我们在这里使用扩展而不是方法，但当我们将该 JSON 加载到内容视图中时，原因就会变得清晰。现在将此属性添加到 ContentView 结构中： 12let astronauts = Bundle.main.decode(&quot;astronauts.json&quot;) 你可以使用Text(String(astronauts.count)) 来查看是否真的读取成功了。 在我们完成之前，我想回到我们的小扩展并更仔细地看看它。我们拥有的代码非常适合此应用程序，但如果您想在将来使用它，我建议您添加一些额外的代码来帮助您诊断问题。 将方法的第二部分替换为： 123456789101112131415let decoder = JSONDecoder()do &#123; return try decoder.decode([String: Astronaut].self, from: data)&#125; catch DecodingError.keyNotFound(let key, let context) &#123; fatalError(&quot;Failed to decode \\(file) from bundle due to missing key &#x27;\\(key.stringValue)&#x27; – \\(context.debugDescription)&quot;)&#125; catch DecodingError.typeMismatch(_, let context) &#123; fatalError(&quot;Failed to decode \\(file) from bundle due to type mismatch – \\(context.debugDescription)&quot;)&#125; catch DecodingError.valueNotFound(let type, let context) &#123; fatalError(&quot;Failed to decode \\(file) from bundle due to missing \\(type) value – \\(context.debugDescription)&quot;)&#125; catch DecodingError.dataCorrupted(_) &#123; fatalError(&quot;Failed to decode \\(file) from bundle because it appears to be invalid JSON.&quot;)&#125; catch &#123; fatalError(&quot;Failed to decode \\(file) from bundle: \\(error.localizedDescription)&quot;)&#125; 这不是一个大的变化，但这意味着该方法现在会告诉您解码出了什么问题 - 当您的 Swift 代码和 JSON 文件不太匹配时，这非常有用！ 使用泛型来加载任何类型的可编码数据在上一节，我们添加了一个 Bundle 扩展，用于从应用程序包中加载一种特定类型的 JSON 数据，但现在我们有第二种类型：missions.json。这包含稍微复杂一点的 JSON： 每个任务都有一个ID号，这意味着我们可以轻松使用 Identifiable 。 每个任务都有一个描述，它是来自维基百科的自由文本字符串。 每个任务都有一组机组人员，每个机组人员都有名字和角色。 除一项任务外，所有任务都有发射日期。遗憾的是，阿波罗一号从未发射，因为发射排练舱火灾摧毁了指挥舱并杀死了机组人员。 接下来转换Json为Swift数据。要创建多个结构来存储数据你可以这样创建 1234567891011struct CrewRole: Codable &#123; let name: String let role: String&#125;struct Mission: Codable, Identifiable &#123; let id: Int let launchDate: String? let crew: [CrewRole] let description: String&#125; 首先注意在Mission结构中，launchDate是一个可选项，因为上面提到 除一项任务外，所有任务都有发射日期。遗憾的是，阿波罗一号从未发射，因为发射排练舱火灾摧毁了指挥舱并杀死了机组人员。 因此可能有项目是没有发射日期的。事实上，如果我们将某个属性标记为可选，如果输入 JSON 中缺少该值， Codable 将自动跳过该属性。 另外还要注意，我们的 CrewRole 结构是专门用来保存有关任务的数据的，因此我们实际上可以将 CrewRole 结构也放到Misson的结构内 1234567891011struct Mission: Codable, Identifiable &#123; struct CrewRole: Codable &#123; let name: String let role: String &#125; let id: Int let launchDate: String? let crew: [CrewRole] let description: String&#125; 这称为嵌套结构，只是将一个结构放置在另一个结构中。这不会影响我们在这个项目中的代码，但在其他地方它有助于保持代码的组织性：而不是说 CrewRole 你会写 Mission.CrewRole 。如果您可以想象一个具有数百个自定义类型的项目，那么添加这个额外的上下文确实会有帮助！ 现在让我们考虑如何将 Mission.json 加载到 Mission 结构数组中。我们已经添加了一个 Bundle 扩展，它将一些 JSON 文件加载到 Astronaut 结构的字典中，因此我们可以非常轻松地复制和粘贴它，然后对其进行调整，以便它加载任务而不是宇航员。然而，有一个更好的解决方案：我们可以利用 Swift 的泛型系统。 泛型允许我们编写能够处理各种不同类型的代码。在这个项目中，我们编写了 Bundle 扩展来处理宇航员字典，但实际上我们希望能够处理宇航员字典、任务数组或可能的许多其他东西。 为了使方法具有通用性，我们为它提供了某些类型的占位符。这写在方法名称之后、参数之前的尖括号（ &lt; 和 &gt; ）中，如下所示： 1func decode&lt;T&gt;(_ file: String) -&gt; [String: Astronaut] &#123; 我们可以使用任何东西作为该占位符——我们可以写“Type”、“TypeOfThing”，甚至“Fish”；没关系。 “T”是编码中的一种约定，作为“type”的简写占位符。 在方法内部，我们现在可以在任何需要使用 [String: Astronaut] 的地方使用“T”——它实际上是我们想要使用的类型的占位符。因此，我们不会返回 [String: Astronaut] 我们会使用这个： 1func decode&lt;T&gt;(_ file: String) -&gt; T &#123; 要非常小心： T 和 [T] 之间有很大的区别。请记住， T 是我们要求的任何类型的占位符，因此如果我们说“解码我们的宇航员字典”，那么 T 就会变成 [String: Astronaut] 。如果我们尝试从 decode() 返回 [T] 那么我们实际上会返回 [[String: Astronaut]] – 宇航员字典的数组！ 在 decode() 方法的中间还有一个使用 [String: Astronaut] 的地方，再次，请将其更改为 T ，如下所示： 123456return try decoder.decode([String: Astronaut].self, from: data)//改为return try decoder.decode(T.self, from: data) 因此，我们所说的是 decode() 将与某种类型一起使用，例如 [String: Astronaut] ，并且它应该尝试将其加载的文件解码为该类型。 如果您尝试编译此代码，您将在 Xcode 中看到错误：“实例方法 ‘decode(_:from:)’ 要求 ‘T’ 符合 ‘Decodable’”。它的意思是 T 可以是任何东西：它可以是宇航员的字典，也可以是完全其他东西的字典。问题是 Swift 无法确定我们正在使用的类型是否符合 Codable 协议，因此与其冒险，不如拒绝构建我们的代码。 幸运的是，我们可以通过一个约束来解决这个问题：我们可以告诉 Swift T 可以是我们想要的任何东西，只要它符合 Codable 。这样 Swift 就知道它可以安全使用，并确保我们不会尝试使用不符合 Codable 的类型的方法。 要添加约束，请将方法签名更改为： 12func decode&lt;T: Codable&gt;(_ file: String) -&gt; T &#123; 如果您尝试再次编译，您会发现事情仍然无法正常工作，但现在是由于不同的原因：“无法推断通用参数’T’”，在 astronauts 属性中 ContentView 。这条线以前工作得很好，但现在有一个重要的变化：以前 decode() 总是返回宇航员的字典，但现在它返回任何我们想要的东西，只要它符合 Codable . 我们知道它仍然会返回宇航员字典，因为实际的底层数据没有改变，但 Swift 不知道这一点。我们的问题是 decode() 可以返回任何符合 Codable 的类型，但 Swift 需要更多信息——它想知道它到底是什么类型。 因此，为了解决这个问题，我们需要使用类型注释，以便 Swift 确切地知道 astronauts 是什么： 12let astronauts: [String: Astronaut] = Bundle.main.decode(&quot;astronauts.json&quot;) 终于——在所有工作之后！ – 我们现在还可以将 Mission.json 加载到 ContentView 中的另一个属性中。请在下面添加此 astronauts ： 12let missions: [Mission] = Bundle.main.decode(&quot;missions.json&quot;) 这就是泛型的力量：我们可以使用相同的 decode() 方法将我们的包中的任何 JSON 加载到符合 Codable 的任何 Swift 类型中 - 我们不需要半个同一方法的十几种变体。 在我们结束之前，我想解释最后一件事。之前您看到消息“实例方法 ‘decode(_:from:)’ 要求 ‘T’ 符合 ‘Decodable’”，您可能想知道 Decodable 是什么 - 毕竟，我们已经到处都在使用 Codable 。好吧，在幕后， Codable 只是两个单独协议的别名： Encodable 和 Decodable 。如果需要，您可以使用 Codable ，如果您喜欢具体，则可以使用 Encodable 和 Decodable – 这取决于您。 现在我们可以同时解析宇航员和任务了： 12let astronauts: [String: Astronaut] = Bundle.main.decode(&quot;astronauts.json&quot;)let missions: [Mission] = Bundle.main.decode(&quot;missions.json&quot;) 格式化任务视图现在我们已经有了所有数据，我们可以看看第一个屏幕的设计：所有任务的网格，位于任务徽章旁边。 我们之前添加的资产包含名为“&#97;&#112;&#x6f;&#108;&#108;&#x6f;&#x31;&#64;&#x32;&#x78;&#46;&#x70;&#x6e;&#x67;”和类似的图片，这意味着它们可以在资产目录中以“apollo1”、“apollo12”等形式访问。我们的 Mission 结构有一个 id 整数提供数字部分，因此我们可以使用字符串插值，例如 &quot;apollo\\(mission.id)&quot; 来获取图像名称和 &quot;Apollo \\(mission.id)&quot; 来获取任务名称 不过，在这里，我们将采取不同的方法：我们将向 Mission 结构添加一些计算属性以发回相同的数据。结果将是相同的 - “apollo1”和“Apollo 1” - 但现在代码位于一个位置：我们的 Mission 结构体。这意味着任何其他视图都可以使用相同的数据，而不必重复我们的字符串插值代码，这反过来意味着如果我们改变这些东西的格式化方式 - 即我们将图像名称更改为“apollo-1”或其他东西 - 那么我们只需更改 Mission 中的属性即可更新所有代码。 因此，请立即将这两个属性添加到 Mission 结构中： 12345678var displayName: String &#123; &quot;Apollo \\(id)&quot;&#125;var image: String &#123; &quot;apollo\\(id)&quot;&#125; 有了这两个，我们现在可以第一次填写 ContentView ：它将有一个带有标题的 NavigationStack ，一个使用我们的 missions 数组作为输入，里面的每一行都会有一个 NavigationLink 包含任务的图像、名称和发射日期。其中唯一的小复杂性是我们的启动日期是一个可选字符串，因此我们需要使用 nil 合并来确保文本视图有一个要显示的值。 首先，将此属性添加到 ContentView 以定义自适应列布局： 123let columns = [ GridItem(.adaptive(minimum: 150))] 现在用以下内容替换现有的 body 属性： 123456789101112131415161718192021222324252627NavigationStack &#123; ScrollView &#123; LazyVGrid(columns: columns) &#123; ForEach(missions) &#123; mission in NavigationLink &#123; Text(&quot;Detail view&quot;) &#125; label: &#123; VStack &#123; Image(mission.image) .resizable() .scaledToFit() .frame(width: 100, height: 100) VStack &#123; Text(mission.displayName) .font(.headline) Text(mission.launchDate ?? &quot;N/A&quot;) .font(.caption) &#125; .frame(maxWidth: .infinity) &#125; &#125; &#125; &#125; &#125; .navigationTitle(&quot;Moonshot&quot;)&#125; 优化显示接下来优化一下显示。 Swift 的 JSONDecoder 类型有一个名为 dateDecodingStrategy 的属性，它决定了它应该如何解码日期。我们可以提供一个 DateFormatter 实例来描述日期的格式。在本例中，我们的日期写为年-月-日，在 DateFormat 的世界中写为“y-MM-dd”——这意味着“一年，然后是破折号，然后是零填充的月份，然后是破折号，然后是零填充的日”，其中“零填充”意味着一月写为“01”而不是“1”。 警告：日期格式区分大小写！ mm 表示“零填充分钟”， MM 表示“零填充月份”。 因此，打开 Bundle-Decodable.swift 并直接在 let decoder &#x3D; JSONDecoder() 之后添加此代码： 123let formatter = DateFormatter()formatter.dateFormat = &quot;y-MM-dd&quot;decoder.dateDecodingStrategy = .formatted(formatter) 如果你现在运行代码……事情看起来会完全一样。是的，什么都没有改变，但这没关系：什么都没有改变，因为 Swift 没有意识到 launchDate 是一个日期。毕竟，我们是这样声明的：let launchDate: String? ，现在把他改成let launchDate: Date? ，你会发现这里出错了 1Text(mission.launchDate ?? &quot;N/A&quot;) 它尝试在文本视图中使用可选的 Date ，或者如果日期为空，则将其替换为“N&#x2F;A”。这是计算属性效果更好的另一个地方：我们可以要求任务本身提供格式化的启动日期，将可选日期转换为格式整齐的字符串，或者针对缺失的日期发回“N&#x2F;A”。 这使用了我们之前使用过的相同的 formatted() 方法，所以这对你来说应该有点熟悉。现在将此计算属性添加到 Mission 中：然后将Text(mission.launchDate ?? &quot;N/A&quot;) 替换为Text(mission.formattedLaunchDate) 1234var formattedLaunchDate: String &#123; launchDate?.formatted(date: .abbreviated, time: .omitted) ?? &quot;N/A&quot;&#125; 通过这一更改，我们的日期将以更自然的方式呈现，甚至更好，将以适合用户区域的任何方式呈现 - 您看到的不一定是我看到的。 现在让我们关注更大的问题：我们的布局非常乏味！ 为了稍微美化一下，我想向您介绍两个有用的功能：如何轻松共享自定义应用程序颜色，以及如何为我们的应用程序强制使用深色主题。 首先，颜色。有两种方法可以做到这一点，两种方法都很有用：您可以使用特定名称将颜色添加到资产目录中，或者可以将它们添加为 Swift 扩展。它们都有各自的优点——使用资产目录可以让您直观地工作，但使用代码可以更轻松地使用 GitHub 等工具来监控更改。 在这两种方法中，我更喜欢代码方法，因为当您在团队中工作时，它可以更轻松地跟踪更改，因此我们将把颜色名称作为扩展放入 Swift 中。 如果我们在 Color 上进行这些扩展，我们可以在 SwiftUI 中的几个地方使用它们，但 Swift 为我们提供了一个更好的选择，只需要多一点代码。您会看到， Color 符合一个名为 ShapeStyle 的更大协议，该协议允许我们使用颜色、渐变、材质等，就好像它们是同一事物一样。 这个 ShapeStyle 协议是 background() 修饰符使用的，所以我们真正想做的是扩展 Color 但这样做的方式是所有 SwiftUI 修饰符都使用 ShapeStyle 也可以工作。这可以通过非常精确的扩展来完成，字面意思是“我们想向 ShapeStyle 添加功能，但仅限于它被用作颜色的时候。” 要尝试此操作，请创建一个名为 Color-Theme.swift 的新 Swift 文件，将其更改为 SwiftUI 的 Foundation import，然后为其提供以下代码： 123456789extension ShapeStyle where Self == Color &#123; static var darkBackground: Color &#123; Color(red: 0.1, green: 0.1, blue: 0.2) &#125; static var lightBackground: Color &#123; Color(red: 0.2, green: 0.2, blue: 0.3) &#125;&#125; 这添加了两种新颜色，称为 darkBackground 和 lightBackground ，每种颜色都有红色、绿色和蓝色的精确值。但更重要的是，他们将它们放置在一个非常具体的扩展中，使我们可以在 SwiftUI 需要 ShapeStyle 的任何地方使用这些颜色。 我想立即将这些新颜色付诸实践。首先，找到包含任务名称和发射日期的 VStack - 它应该已经有 .frame(maxWidth: .infinity) 了，但我希望您将其修饰符顺序更改为： 123.padding(.vertical).frame(maxWidth: .infinity).background(.lightBackground) 最终其他的显示优化代码如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354struct ContentView: View &#123; let astronauts: [String: Astronaut] = Bundle.main.decode(&quot;astronauts.json&quot;) let missions: [Mission] = Bundle.main.decode(&quot;missions.json&quot;) let columns = [ GridItem(.adaptive(minimum: 150)) ] var body: some View &#123; NavigationStack &#123; ScrollView &#123; LazyVGrid(columns: columns) &#123; ForEach(missions) &#123; mission in NavigationLink &#123; Text(&quot;Detail View&quot;) &#125; label: &#123; VStack &#123; Image(mission.image) .resizable() .scaledToFit() .frame(width: 100, height: 100) .padding() VStack &#123; Text(mission.displayName) .font(.headline) .foregroundStyle(.white) Text(mission.formattedLaunchDate) .font(.caption) .foregroundStyle(.white.opacity(0.5)) &#125; .padding(.vertical) .frame(maxWidth: .infinity) .background(.lightBackground) &#125; .clipShape(.rect(cornerRadius: 10)) .overlay( RoundedRectangle(cornerRadius: 10) .stroke(.lightBackground) ) &#125; &#125; &#125; .padding([.horizontal, .bottom]) .preferredColorScheme(.dark) &#125; .navigationTitle(&quot;MoonShot&quot;) .background(.darkBackground) &#125; &#125;&#125; 如果您现在运行该应用程序，您会看到我们有一个精美的任务数据滚动网格，可以平滑地适应各种设备尺寸，无论用户启用什么外观，我们都有明亮的白色导航文本和深色导航背景，点击我们的任何任务都会带来临时的详细视图。一个好的开始！ 使用 ScrollView 和 containerRelativeFrame() 显示任务详细信息当用户从我们的主列表中选择一项阿波罗任务时，我们希望显示有关该任务的信息：其任务徽章、任务描述以及机组人员中的所有宇航员及其角色。前两个并不太难，但第三个需要更多工作，因为我们需要将两个 JSON 文件中的船员 ID 与船员详细信息进行匹配。 让我们从简单的开始，逐步完善：创建一个名为 MissionView.swift 的新 SwiftUI 视图。最初，它只有一个 mission 属性，以便我们可以显示任务徽章和描述，但很快我们将添加更多内容。 在布局方面，这个东西需要有一个滚动 VStack 和一个可调整大小的任务徽章图像，然后是一个文本视图。我们将使用 containerRelativeFrame() 来设置任务图像的宽度 - 通过一些试验和错误，我发现任务徽章在不是全宽时效果最好 - 看起来宽度在 50% 到 70% 之间更好的是，避免它在屏幕上变得异常大。 现在将此代码放入 MissionView.swift 中： 12345678910111213141516171819202122232425262728293031struct MissionView: View &#123; let mission: Mission var body: some View &#123; ScrollView &#123; VStack &#123; Image(mission.image) .resizable() .scaledToFit() .containerRelativeFrame(.horizontal) &#123; width, axis in width * 0.6 &#125; .padding(.top) VStack(alignment: .leading) &#123; Text(&quot;Mission Highlights&quot;) .font(.title.bold()) .padding(.bottom, 5) Text(mission.description) &#125; .padding(.horizontal) &#125; .padding(.bottom) &#125; .navigationTitle(mission.displayName) .navigationBarTitleDisplayMode(.inline) .background(.darkBackground) &#125;&#125; 效果如下： 合并可编码结构在我们的任务描述下方，我们希望显示每个机组成员的图片、姓名和角色，这意味着匹配来自两个不同 JSON 文件的数据。 如果您还记得，我们的 JSON 数据分为 Mission.json 和 astronauts.json。这消除了数据中的重复，因为一些宇航员参加了多次任务，但这也意味着我们需要编写一些代码将我们的数据连接在一起 - 例如，将“阿姆斯特朗”解析为“尼尔·阿姆斯特朗”。你看，一方面我们的任务知道机组成员“阿姆斯特朗”的角色是“指挥官”，但不知道“阿姆斯特朗”是谁，而另一方面我们有“尼尔·阿姆斯特朗”和描述他，但不知道他是阿波罗 11 号的指挥官。 因此，我们需要做的是让我们的 MissionView 接受被点击的任务，以及我们完整的宇航员字典，然后让它找出哪些宇航员实际参加了发射。 现在在 MissionView 中添加这个嵌套结构： 1234struct CrewMember &#123; let role: String let astronaut: Astronaut&#125; 但是我们如何设置该属性呢？好吧，想一想：如果我们让这个视图被赋予其任务和所有宇航员，我们可以遍历任务机组人员，然后为每个机组人员在字典中查找具有匹配 ID 的人员。当我们找到一个时，我们可以将其及其角色转换为 CrewMember 对象，但如果我们不这样做，则意味着我们有一个具有无效或未知名称的船员角色。 后一种情况绝对不应该发生。需要明确的是，如果您在项目中添加了一些指向应用程序中丢失数据的 JSON，那么您就犯了一个根本性错误 - 这不是您应该尝试在运行时编写错误处理的类型，因为它从一开始就不应该允许这种情况发生。所以，这是 fatalError() 有用的一个很好的例子：如果我们无法使用他们的 ID 找到宇航员，我们应该立即退出并大声抱怨。 让我们将所有这些都放入代码中，使用 MissionView 的自定义初始值设定项。就像我说的，这将接受它与所有宇航员一起代表的任务，它的工作是存储任务，然后找出已解决的宇航员数组。 12345678910111213141516// init(mission: Mission, crew: [CrewMember]) &#123;// self.mission = mission// self.crew = crew// &#125; init(mission: Mission, astronauts: [String: Astronaut]) &#123; self.mission = mission self.crew = mission.crew.map &#123; member in if let astronaut = astronauts[member.name] &#123; return CrewMember(role: member.role, astronaut: astronaut) &#125; else &#123; fatalError(&quot;Missing \\(member.name)&quot;) &#125; &#125; &#125; 这里就是本节合并可编码结构的重点，注意和默认的init方法的区分， 一旦该代码进入，我们的预览结构将再次停止工作，因为它需要更多信息。因此，添加对 decode() 的第二次调用，以便加载所有宇航员，然后将它们也传递进去： 1234567#Preview &#123; let missions: [Mission] = Bundle.main.decode(&quot;missions.json&quot;) let astronauts: [String: Astronaut] = Bundle.main.decode(&quot;astronauts.json&quot;) return MissionView(mission: missions[0], astronauts: astronauts) .preferredColorScheme(.dark)&#125; 现在我们有了所有宇航员数据，我们可以使用水平滚动视图直接在任务描述下方显示这些数据。我们还将使用胶囊夹形状和叠加层为宇航员照片添加一些额外的样式，使它们看起来更好。 在 VStack(alignment: .leading) 之后添加此代码： 1234567891011121314151617181920212223242526272829ScrollView(.horizontal, showsIndicators: false) &#123; HStack &#123; ForEach(crew, id: \\.role) &#123; crewMember in NavigationLink &#123; Text(&quot;Astronaut details&quot;) &#125; label: &#123; HStack &#123; Image(crewMember.astronaut.id) .resizable() .frame(width: 104, height: 72) .clipShape(.capsule) .overlay( Capsule() .strokeBorder(.white, lineWidth: 1) ) VStack(alignment: .leading) &#123; Text(crewMember.astronaut.name) .foregroundStyle(.white) .font(.headline) Text(crewMember.role) .foregroundStyle(.white.opacity(0.5)) &#125; &#125; .padding(.horizontal) &#125; &#125; &#125;&#125; ContentView也替换MissionView(mission: mission, astronauts: astronauts) 在我的项目中，我认为在任务视图中添加一点视觉分离会很有用，这样任务徽章、描述和人员就可以更清晰地分开。 SwiftUI 确实提供了一个专用的 Divider 视图，用于在布局中创建视觉划分，但它不可自定义 - 它始终只是一条细线。因此，为了获得更有用的东西，我将绘制一个自定义分隔线来分隔我们的视图。 完成最后一张视图为了完成这个程序，我们将制作第三个也是最后一个视图来显示宇航员的详细信息，这可以通过点击任务视图中的一名宇航员来实现。这主要应该只是您的练习，但我希望它也向您展示了 NavigationStack 的重要性 - 我们正在更深入地挖掘我们应用程序的信息，滑入和滑出视图的呈现确实能让您明白这一点给用户。 首先创建一个名为 AstronautView 的新 SwiftUI 视图。这将有一个 Astronaut 属性，因此它知道要显示什么，然后它将使用类似于 ScrollView &#x2F; VStack 组合来布局，就像我们在 &lt; b4&gt; 。给它这个代码： 12345678910111213141516171819struct AstronautView: View &#123; let astronaut: Astronaut var body: some View &#123; ScrollView &#123; VStack &#123; Image(astronaut.id) .resizable() .scaledToFit() Text(astronaut.description) .padding() &#125; &#125; .background(.darkBackground) .navigationTitle(astronaut.name) .navigationBarTitleDisplayMode(.inline) &#125;&#125; 我们需要再次更新预览，以便它使用一些数据创建视图： 1234567#Preview &#123; let astronauts: [String: Astronaut] = Bundle.main.decode(&quot;astronauts.json&quot;) return AstronautView(astronaut: astronauts[&quot;aldrin&quot;]!) .preferredColorScheme(.dark)&#125; 现在我们可以从 MissionView 内的 NavigationLink 来呈现它。现在它指向 Text(“Astronaut details”) ，但我们可以将其更新为指向新的 AstronautView ： 12AstronautView(astronaut: crewMember.astronaut) 这很容易，对吧？但是，如果您现在运行该应用程序，您会发现它使我们的用户界面感觉多么自然 - 我们从最广泛的信息级别开始，显示我们的所有任务，然后点击以选择一项特定任务，然后点击以选择一名特定宇航员。 iOS 负责新视图中的动画，但也提供后退按钮和滑动以返回到以前的视图。 最终效果图","categories":[{"name":"技术","slug":"技术","permalink":"https://blog.five2fire.top/categories/%E6%8A%80%E6%9C%AF/"}],"tags":[{"name":"编程","slug":"编程","permalink":"https://blog.five2fire.top/tags/%E7%BC%96%E7%A8%8B/"},{"name":"Swift","slug":"Swift","permalink":"https://blog.five2fire.top/tags/Swift/"},{"name":"Hacking with Swift","slug":"Hacking-with-Swift","permalink":"https://blog.five2fire.top/tags/Hacking-with-Swift/"}]},{"title":"电脑自动重启的尝试解决办法记录","slug":"电脑自动重启的尝试解决办法","date":"2024-06-24T02:52:38.000Z","updated":"2025-01-02T02:17:10.825Z","comments":true,"path":"article/16673.html","permalink":"https://blog.five2fire.top/article/16673.html","excerpt":"","text":"主机配置 配件 型号 CPU AMD 5800X 显卡 AMD 6750xt 现象描述 DOTA2游戏，4+2游廊的时候，游戏过程中无规律自动重启 DOTA2游戏，回到主菜单时（包括但不仅限于直接点击主菜单按钮，4+2结束时自动回到主菜单），自动重启。这个算是有规律？ 其余时间偶尔（比较少数情况）重启 CS2好像没重启过，可能有重启的情况我忘记了 分手厨房也重启过一次，也是无规律 最极端情况下，打4+2一局内反复重启，能掉线5次之多！（这一点看来很可能是温度问题，因为一直开游戏导致温度降不下来，但是我风扇拉满了温度监测显示温度也没有很高啊！！！） 可能原因 显卡掉驱动：但是一般掉驱动是花屏黑屏，不会重启。我是直接关机自动重启 CPU&#x2F;显卡过热：打开了温度检测软件了，基本没有过热。（之前倒是出现过CPU过热导致重启，但是清灰换硅脂改风道后，CPU常年60℃左右，排除该原因） 显卡过热倒是有可能，但是通过驱动自定义调整风扇转速（满速）后，显卡温度也在70℃上下。况且打个DOTA2或者分手厨房，还不至于让显卡冒汗吧？！！！ Windows11与AMD不太兼容。看网上说windows会自动更新驱动。 内存问题：应该不是吧，我也没有死机蓝屏之类的，而是直接黑屏然后自动开机重启。 显卡刚买来装上玩没有任何问题（2023年6月购入），问题首次出现大概是2024年3月份左右，第一次自动重启提示是CPU过热保护，确实快3年没换硅脂了，之后给CPU换硅脂，散热塔清灰后，再也没有提示CPU过热，但是重启更频繁了。 尝试解决方法 禁用windows自动更新驱动：禁用自动更新驱动 “计算机配置 - 管理模板 - Windows组件 - Windows更新”—“Windows更新不包括驱动程序”，调成已启用，重启。 使用DDU卸载电脑所有驱动（需要安全模式无网启动） 重新安装amd老版本稳定驱动。AMD历史版本驱动下载 [不吹不黑不玄学] 显卡掉驱动&#x2F;不稳定的分析与解决方案[2023.8.9] 这篇挺详细的 禁止快速启动（控制面板-硬件和声音-电源选项-选择电源按钮的功能-更改当前不可用设置-关机设置：关闭快速启动） 关闭内存完整性保护：测试数据表明Windows 10&#x2F;11开启内核隔离后游戏帧率出现显著下降 设置路径为：系统安全中心、设备安全性、内核隔离、内存完整性，在这里可以根据需要决定是否启用内核隔离。 启用的好处：通过内存完整性检查可以检测出恶意软件修改进程或读取数据，启用后有助于提高系统整体安全性。 如果是企业设备不做游戏用途的话推荐启用此选项，这可以避免恶意软件通过注入等技术盗取企业的机密数据等。 关闭的好处：关闭内存完整性检查后有助于提高性能性能，如前文所述可以发挥游戏最佳性能从而获得最佳体验。","categories":[{"name":"技术","slug":"技术","permalink":"https://blog.five2fire.top/categories/%E6%8A%80%E6%9C%AF/"}],"tags":[{"name":"系统","slug":"系统","permalink":"https://blog.five2fire.top/tags/%E7%B3%BB%E7%BB%9F/"}]},{"title":"【Hacking With Swift】project7_iExpense","slug":"Project7-iExpense","date":"2024-06-23T04:06:18.000Z","updated":"2025-01-02T02:17:10.817Z","comments":true,"path":"article/46793.html","permalink":"https://blog.five2fire.top/article/46793.html","excerpt":"","text":"英文原博博主是 Paul Hudson @twostraws 本文是学习Swift过程中翻译该网站的内容: https://www.hackingwithswift.com/ iExpense 电子记账这个项目中我们仍然要完成一个小程序——iExpense，可以记录简单的账目。主要是学习如何显示另一个屏幕、如何跨屏幕共享数据、如何保存并加载用户数据。 我们将了解@observable、sheet()、onDelete()等等。 iExpense简介接下来的两个项目将开始推动我们的 SwiftUI 技能超越基础知识，因为我们将探索具有多个屏幕、加载和保存用户数据以及具有更复杂用户界面的应用程序。 在这个项目中，我们将构建 iExpense，这是一个费用跟踪器，可将个人成本与业务成本分开。从本质上讲，这是一个带有表单（花了多少钱？）和列表（花费的金额）的应用程序，但为了完成这两件事，我们需要学习如何： 显示和关闭第二个数据屏幕。 从列表中删除行 保存和加载用户数据 更多其他内容…… 有很多事情要做，所以让我们开始吧！ 在类中使用@state前面我们学习到，@state属性包装器专为当前视图本地的简单数据而设计，但一旦您想要共享数据，您就需要采取一些重要的额外步骤。 先看下面这段代码，这是一个存储用户名字和姓氏的结构，我们现在可以在 SwiftUI 视图中使用它，方法是创建 @State 属性并将内容附加到 $user.firstName 和 $user.lastName 。 1234567891011121314151617struct User &#123; var firstName = &quot;Bilbo&quot; var lastName = &quot;Baggins&quot;&#125;struct ContentView: View &#123; @State private var user = User() var body: some View &#123; VStack &#123; Text(&quot;Your name is \\(user.firstName) \\(user.lastName).&quot;) TextField(&quot;First name&quot;, text: $user.firstName) TextField(&quot;Last name&quot;, text: $user.lastName) &#125; &#125;&#125; 这一切都有效：SwiftUI 足够智能，可以理解一个对象包含我们的所有数据，并且当任一值发生变化时都会更新 UI。在幕后，实际发生的情况是，每次结构体中的值更改时，整个结构体都会发生更改 - 就像每次我们键入一个新用户一样名字或姓氏的键。这听起来可能有点浪费，但实际上速度非常快。 之前我们研究了类和结构之间的差异，我提到了两个重要的差异。首先，结构总是有唯一的所有者，而对于类，多个事物可以指向相同的值。其次，该类在更改其属性的方法之前不需要mutating 关键字，因为您可以更改属性常量类。 实际上，这意味着，如果我们有两个 SwiftUI 视图，并且向它们发送相同的结构来使用，它们实际上每个都有该结构的唯一副本；如果一个人改变了它，另一个人将看不到这种变化。另一方面，如果我们创建 class 的实例并将其发送到两个视图，它们将&lt; &#x2F;span&gt; 分享更改。 对于 SwiftUI 开发人员来说，这意味着如果我们想要在多个视图之间共享数据 – 如果我们希望两个或多个视图指向相同的数据，以便当一个视图发生更改时，它们都会得到这些更改 – 我们需要使用类而不是结构。 因此，请将 User 结构更改为类。 1234class User &#123; var firstName = &quot;Bilbo&quot; var lastName = &quot;Baggins&quot;&#125; 你会发现程序无法正常运行了。当然，我们可以像以前一样在文本字段中输入内容，但上面的文本视图不会改变。 当我们使用 @State 时，我们要求 SwiftUI 监视属性的更改。因此，如果我们更改字符串、翻转布尔值、添加到数组等，则属性已更改，SwiftUI 将重新调用视图的 body 属性。 当 User 是一个结构体时，每次我们修改该结构体的属性时，Swift 实际上都会创建该结构体的一个新实例。 @State 能够发现该更改，并自动重新加载我们的视图。现在我们有了一个类，这种行为就不再发生：Swift 可以直接修改值。 还记得我们如何使用 mutating 关键字来修改属性的结构体方法吗？这是因为，如果我们将结构体的属性创建为变量，但结构体本身是常量，则我们无法更改属性 - Swift 需要能够在属性更改时销毁并重新创建整个结构体，而这对于 Swift 来说是不可能的常量结构。类不需要mutating关键字，因为即使类实例被标记为常量，Swift仍然可以修改变量属性。 我知道这一切听起来都非常理论化，但这里有一个转折点：现在 User 是一个类，属性本身并没有改变，所以 @State没有注意到任何事情并且无法重新加载视图。是的，类内的值 正在发生变化，但 @State 不会监视这些值，所以实际上发生的情况是我们类中的值正在更改，但视图不会重新加载以反映该更改。 我们可以通过一个小改动来解决这个问题：在类前之前添加一行@Observable。 现在我们的代码将再次工作。要了解原因，让我们探索一下 @Observable 实际上做了什么…… 与 @Observable 共享 SwiftUI 状态如果您将 @State 与结构一起使用，则当值更改时，您的 SwiftUI 视图将自动更新，但如果您将 @State 与类一起使用，则必须使用 @Observable 我们详细地看一下这个代码 12345@Observableclass User &#123; var firstName = &quot;Bilbo&quot; var lastName = &quot;Baggins&quot;&#125; 以 @Observable 开头，这告诉 SwiftUI 监视类中每个单独的属性的更改，并在属性发生更改时重新加载依赖于该属性的任何视图。实际上，Swift在背后为我们做了大量的工作： @Observable 行是一个 宏，这是 Swift 悄悄重写我们的方法添加额外功能的代码。现在我们已经导入了它所来自的框架，Xcode 可以做一些非常巧妙的事情：如果您右键单击代码中的 @Observable，您可以选择 Expand Macro 来查看到底重写了什么正在发生 – Xcode 将向您显示正在生成的所有隐藏代码。 我不打算在这里写出整个宏扩展，因为它太多了，但我确实想指出三件事： 我们的两个属性被标记为@ObservationTracked，这意味着 Swift 和 SwiftUI 正在监视它们的更改。 如果右键单击 @ObservationTracked，您也可以展开该宏 – 是的，它’ ;是宏中的宏。该宏的作用是跟踪任何属性的读取或写入，以便 SwiftUI 只能更新绝对需要刷新的视图。 我们的类符合Observable 协议。这很重要，因为 SwiftUI 的某些部分认为这意味着“可以监视此类的更改。” 这三者都很重要，但最重要的是中间的一个：iOS 会跟踪每个从 @Observed 对象读取属性的 SwiftUI 视图，这样当属性更改时，它可以智能地更新依赖于它的所有视图，同时保持其他视图不变。 使用结构时，@State 属性包装器会保持值处于活动状态并监视它的更改。另一方面，当使用 类 时，@State 只是为了保持对象的活动状态 – 所有的变化都在监视更新视图由 @Observable 负责。 显示和隐藏视图在 SwiftUI 中显示视图的方式有多种，最基本的一种是工作表：在工作表之上呈现的新视图我们现有的。在 iOS 上，这会自动为我们提供一个类似卡片的演示，其中当前视图稍微滑向远处，新视图以动画方式显示在顶部。 工作表的工作方式与提醒非常相似，因为我们不会直接使用 mySheet.present() 或类似代码来呈现它们。相反，我们定义了应显示工作表的条件，当这些条件为 true 或 false 时，将分别显示或消除工作表。 让我们从一个简单的示例开始，该示例将使用工作表显示另一个视图的一个视图。首先，我们创建要在工作表中显示的视图，如下所示： 12345struct SecondView: View &#123; var body: some View &#123; Text(&quot;Second View&quot;) &#125;&#125; 接下来，创建初始视图，并通过一个按钮来调用上面这个视图： 123456789101112struct ContentView: View &#123; @State private var showingSheet = false var body: some View &#123; Button(&quot;Show Sheet&quot;) &#123; showingSheet.toggle() &#125; .sheet(isPresented: $showingSheet) &#123; SecondView() &#125; &#125;&#125; 如果你现在运行该程序，你会看到你可以点击按钮让我们的第二个视图从底部向上滑动，然后你可以将其向下拖动以将其关闭。 我们也可以为第二个视图添加一些参数，并在初始视图中传入参数，比如添加一个名字。 12345678910111213141516171819202122struct SecondView: View &#123; let name: String var body: some View &#123; Text(&quot;Hello, \\(name)!&quot;) &#125;&#125;struct ContentView: View &#123; @State private var showingSheet = false var body: some View &#123; Button(&quot;Show Sheet&quot;) &#123; showingSheet.toggle() &#125; .sheet(isPresented: $showingSheet) &#123; SecondView(name: &quot;@twostraws&quot;) &#125; .fullScreenCover(isPresented: $showingSheet, content: &#123; SecondView(name: &quot;Sage&quot;) &#125;) //如果想要全屏显示这个工作表可以用这个修饰符 &#125;&#125; 现在工作表将显示“你好，@twostraws”。 接下来我们学习如何清除这个第二个视图（除了向下滑动关闭，我们可以通过编程来实现）。 我们需要另一个属性包装器@Environment，它允许我们创建存储外部提供给我们的值的属性。用户处于浅色模式还是深色模式？他们是否要求使用更小或更大的字体？他们在哪个时区？所有这些以及更多都是来自外部环境的值。 要尝试关闭第二个视图，请将此属性添加到 SecondView，这会根据环境中的值创建一个名为 dismiss 的属性： 1@Environment(\\.dismiss) var dismiss 现在用此按钮替换 SecondView 中的文本视图： 123Button(&quot;Dismiss&quot;) &#123; dismiss()&#125; 点击该按钮后，您现在应该发现可以通过按下按钮来显示和隐藏工作表。 使用 onDelete() 删除项目SwiftUI 为我们提供了 onDelete() 修饰符，用于控制如何从集合中删除对象。实际上，这几乎专门与 List 和 ForEach 一起使用：我们创建使用 ForEach 显示的行列表，然后将 onDelete() 附加到该 ForEach 以便用户可以删除他们不需要的行。 首先，让我们构建一个可以使用的示例：一个显示数字的列表，每次点击按钮时都会出现一个新数字。 12345678910111213141516171819struct ContentView: View &#123; @State private var numbers = [Int]() @State private var currentNumber = 1 var body: some View &#123; VStack &#123; List &#123; ForEach(numbers, id: \\.self) &#123; Text(&quot;Row \\($0)&quot;) &#125; &#125; Button(&quot;Add Number&quot;) &#123; numbers.append(currentNumber) currentNumber += 1 &#125; &#125; &#125;&#125; 经过前面学习，现在也可以不用ForEach来实现。 123List(numbers, id: \\.self) &#123; Text(&quot;Row \\($0)&quot;)&#125; 但是在这一节中，我们要学习的onDelete()修饰符，仅存在于ForEach上，所以我们必须使用ForEach来构建这个列表。 接下来我们要实现一个接收 IndexSet 类型的单个参数的方法。这有点像一组整数，只不过它是经过排序的，并且它只是告诉我们 ForEach 中应删除的所有项目的位置。 因为我们的 ForEach 完全是从单个数组创建的，所以我们实际上可以将该索引集直接传递到我们的 numbers 数组 – 它有一个特殊的remove(atOffsets:) 接受索引集的方法。 最后，我们可以告诉 SwiftUI 在想要从 ForEach 中删除数据时调用该方法 1234ForEach(numbers, id: \\.self) &#123; Text(&quot;Row \\($0)&quot;)&#125;.onDelete(perform: removeRows) 现在继续运行您的应用程序，然后添加一些数字。准备好后，从右向左滑动列表中的任意行，您应该会发现出现一个删除按钮。您可以点击它，也可以使用 iOS 的滑动删除功能，通过进一步滑动来删除。 考虑到这很容易，我认为结果非常好。但 SwiftUI 还有另一个技巧：我们可以在导航栏中添加一个“编辑&#x2F;完成”按钮，让用户更轻松地删除几行。 首先，将 VStack 包裹在 NavigationStack 中，然后将此修饰符添加到 VStack： 123.toolbar &#123; EditButton()&#125; 这实际上就是所需的一切 - 如果您运行该应用程序，您会看到可以添加一些数字，然后点击“编辑”开始删除这些行。准备好后，点击“完成”退出编辑模式。考虑到只需要很少的代码，还不错！ 使用 UserDefaults 存储用户设置多数用户几乎期望应用存储他们的数据，以便他们可以创建更多定制的体验，iOS 提供了几种读取和写入用户数据的方法。 存储少量数据的一种常见方法称为UserDefaults，它非常适合简单的用户偏好。 “少量”没有附加具体数字，但您在 UserDefaults 中存储的所有内容都会在您的应用启动时自动加载 - 如果您在其中存储大量内容，您的应用启动速度将会减慢。为了至少给您一个想法，您的目标应该是在其中存储不超过 512KB。 UserDefaults 非常适合存储用户上次启动应用程序的时间、他们上次阅读的新闻报道或其他被动收集的信息等信息。更好的是，SwiftUI 通常可以将 UserDefaults 包装在一个名为 @AppStorage 的漂亮而简单的属性包装器中 - 它现在只支持功能的子集，但它确实可以有帮助。 聊够了——让我们看一些代码。这是一个带有按钮的视图，显示点击计数，以及每次点击按钮时计数的增量： 由于这显然是一个非常重要的应用程序，因此我们希望保存用户点击的次数，以便他们将来返回该应用程序时可以从上次中断的地方继续。 为了实现这一点，我们需要在按钮的操作闭包内写入UserDefaults。因此，请在 tapCount +&#x3D; 1 行之后添加以下内容： 12345678910struct ContentView: View &#123; @State private var tapCount = 0 var body: some View &#123; Button(&quot;Tap count: \\(tapCount)&quot;) &#123; tapCount += 1 UserDefaults.standard.set(tapCount, forKey: &quot;Tap&quot;) &#125; &#125;&#125; 仅在那一行代码中，您就可以看到三件事正在发生： 我们需要使用UserDefaults.standard。这是附加到我们的应用程序的 UserDefaults 的内置实例，但在更高级的应用程序中，您可以创建自己的实例。例如，如果您想在多个应用扩展之间共享默认值，您可以创建自己的 UserDefaults 实例。 有一个set()方法可以接受任何类型的数据 - 整数、布尔值、字符串等等。 我们将一个字符串名称附加到该数据上，在我们的例子中它是键“Tap”。这个键区分大小写，就像常规的 Swift 字符串一样，这很重要 – 我们需要使用相同的键从 UserDefaults 中读回数据。 说到读回数据，而不是从将 tapCount 设置为 0 开始，我们应该让它从 UserDefaults 读回值，如下所示： 1@State private var tapCount = UserDefaults.standard.integer(forKey: &quot;Tap&quot;) 请注意它如何使用完全相同的键名称，这确保它读取相同的整数值。 继续尝试该应用程序，看看您的想法 - 您应该能够点击按钮几次，返回 Xcode，再次运行该应用程序，并准确地看到您离开时的数字。 有两件事你在代码中看不到，但都很重要。首先，如果我们没有设置“Tap”键会发生什么？应用程序第一次运行时就会出现这种情况，但正如您刚刚看到的那样，它工作正常 - 如果找不到密钥，它只会发回 0。 有时使用像 0 这样的默认值会很有帮助，但有时可能会令人困惑。例如，对于布尔值，如果 boolean(forKey:) 找不到您要求的密钥，您将返回 false，但该 false 是您自己设置的值，还是意味着根本没有值？ 其次，iOS 需要一点时间将数据写入永久存储 - 才能将更改实际保存到设备中。他们不会立即写入更新，因为您可能会连续进行多次更新，因此他们会等待一段时间，然后立即写出所有更改。另一个数字我们不知道需要多长时间，但应该需要几秒钟。 因此，如果您点击按钮然后从 Xcode 快速重新启动应用程序，您会发现最近的点击计数未保存。曾经有一种方法可以强制立即写入更新，但此时它毫无价值 - 即使用户在做出选择后立即开始终止您的应用程序，您的默认数据也会立即写入，因此不会丢失任何内容。 现在，我提到 SwiftUI 提供了一个 @AppStorage 围绕 UserDefaults 的属性包装器，在像这样的简单情况下它确实很有帮助。它的作用是让我们有效地完全忽略 UserDefaults，只使用 @AppStorage 而不是 @State，如下所示： 123456789struct ContentView: View &#123; @AppStorage(&quot;tapCount&quot;) private var tapCount = 0 var body: some View &#123; Button(&quot;Tap count: \\(tapCount)&quot;) &#123; tapCount += 1 &#125; &#125;&#125; 再次，我想指出三件事： 我们对UserDefaults系统的访问是通过@AppStorage属性包装器进行的。其工作原理类似于 @State：当值更改时，它将重新调用 body 属性，以便我们的 UI 反映新数据。 我们附加一个字符串名称，这是我们要存储数据的 UserDefaults 键。我使用了“tapCount”，但它可以是任何东西 - 它不需要与属性名称匹配。 属性的其余部分被声明为正常，包括提供默认值 0。如果内部没有保存现有值，则将使用该值。UserDefaults。 显然使用@AppStorage 比 UserDefaults 更容易：它是一行代码而不是两行，而且这也意味着我们不必重复每次的键名。然而，目前至少 @AppStorage 并不能让存储复杂的对象（例如 Swift 结构）变得容易 - 也许是因为 Apple 希望我们记住，在其中存储大量数据是一个坏主意！ 重要提示：当您向 App Store 提交应用时，Apple 会要求您告知他们为何使用 UserDefaults。没什么好担心的，他们只是想确保开发者不会尝试跨应用识别用户。这同样也适用于属性包装器@AppStorage。 使用 Codable 归档 Swift 对象@AppStorage 非常适合存储整数和布尔值等简单设置，但当涉及复杂数据（例如自定义 Swift 类型）时，我们需要做更多的工作。这是我们需要直接探索 UserDefaults 本身的地方，而不是通过 @AppStorage 属性包装器。 这是一个我们可以使用的简单User数据结构： 1234struct User &#123; let firstName: String let lastName: String&#125; 它有两个字符串，但它们并不特殊 - 它们只是文本片段。对于整数（普通的旧数字）、布尔值（true 或 false）和 Double（普通的旧数字，只是其中有一个点）也是如此。即使是这些值的数组和字典也很容易想到：有一个字符串，然后是另一个字符串，然后是第三个字符串，依此类推。 在处理此类数据时，Swift 为我们提供了一个出色的协议，名为 Codable：专门用于归档的协议 和取消归档数据，这是“将对象转换为纯文本并再次转换回来”的一种奇特方式。 我们将在未来的项目中考虑更多Codable，但现在我们将使其尽可能简单：我们想要归档自定义类型因此我们可以将其放入 UserDefaults 中，然后当它从 中返回out 时将其取消存档5&gt;.UserDefaults 当使用仅具有简单属性（字符串、整数、布尔值、字符串数组等）的类型时，我们需要做的唯一一件事就是为支持归档和取消归档添加一致性Codable，像这样： 1234struct User: Codable &#123; let firstName: String let lastName: String&#125; Swift 会自动为我们生成一些代码，这些代码将根据需要为我们归档和取消归档 User 实例，但我们仍然需要告诉 Swift 何时归档以及如何处理数据。 这部分流程由名为 JSONEncoder 的新类型提供支持。它的工作是获取符合 Codable 的内容并以 JavaScript 对象表示法 (JSON) 发回该对象 - 名称暗示它特定于 JavaScript，但在实践中我们都使用它，因为它太快了而且简单。 Codable 协议不要求我们使用 JSON，事实上其他格式也是可用的，但它是迄今为止最常见的格式。在这种情况下，我们实际上并不关心使用什么类型的数据，因为它只是存储在UserDefaults. 要将 user 数据转换为 JSON 数据，我们需要调用 上的 encode() 方法。这可能会引发错误，因此应该使用 或 调用它以巧妙地处理错误。例如，如果我们有一个属性来存储 实例，如下所示：JSONEncodertrytry?User 1@State private var user = User(firstName: &quot;Taylor&quot;, lastName: &quot;Swift&quot;) 然后我们可以创建一个按钮来存档用户并将其保存到UserDefaults，如下所示： 1234567Button(&quot;Save User&quot;) &#123; let encoder = JSONEncoder() if let data = try? encoder.encode(user) &#123; UserDefaults.standard.set(data, forKey: &quot;UserData&quot;) &#125;&#125; 直接访问 UserDefaults 而不是通过@AppStorage ，因为 @AppStorage 属性包装器在这里不起作用. 该data常量是一种新的数据类型，其名称可能会令人困惑，Data。它旨在存储您能想到的任何类型的数据，例如字符串、图像、zip 文件等。不过，在这里，我们所关心的是它是我们可以直接写入UserDefaults的数据类型之一。 当我们以另一种方式返回时 - 当我们有 JSON 数据并且希望将其转换为 Swift Codable 类型时 - 我们应该使用 JSONDecoder 而不是 JSONEncoder()，但过程大致相同。 项目概述到此结束，因此请继续将您的项目重置为初始状态，准备好进行构建。","categories":[{"name":"技术","slug":"技术","permalink":"https://blog.five2fire.top/categories/%E6%8A%80%E6%9C%AF/"}],"tags":[{"name":"编程","slug":"编程","permalink":"https://blog.five2fire.top/tags/%E7%BC%96%E7%A8%8B/"},{"name":"Swift","slug":"Swift","permalink":"https://blog.five2fire.top/tags/Swift/"},{"name":"Hacking with Swift","slug":"Hacking-with-Swift","permalink":"https://blog.five2fire.top/tags/Hacking-with-Swift/"}]},{"title":"【Hacking With Swift】project6_Animation","slug":"project6-Animation","date":"2024-06-21T02:03:54.000Z","updated":"2025-01-02T02:17:10.822Z","comments":true,"path":"article/57245.html","permalink":"https://blog.five2fire.top/article/57245.html","excerpt":"","text":"英文原博博主是 Paul Hudson @twostraws 本文是学习Swift过程中翻译该网站的内容: https://www.hackingwithswift.com/这个项目主要是学习一些简单的SwiftUI中的动画，包括隐式动画（implicit animations），显式动画以及绑定动画。 隐式动画隐式动画通过.animation()的modifier指定，每当视图里某个隐式动画的参数改变时，SwiftUI会动画化呈现旧值到新值的变化。这些参数包括尺寸，偏移量，颜色，缩放值，等等。这些修饰器包括scaleEffect,aniamtion,blur,opacity等等。 下面是给一个圆形按钮添加隐式动画的例子 123456789101112@State private var animationAmount = 1.0Button(&quot;Tap Me&quot;) &#123; // do nothing&#125;.padding(50).background(.red).foregroundStyle(.white).clipShape(.circle).scaleEffect(animationAmount).blur(radius: (animationAmount - 1) * 3).animation(.default, value: animationAmount) 自定义动画上面用到的animation修饰器，里面的参数使用了.defalut。我们也可以使用其他的参数来自定义动画。 可以分别尝试以下的一些例子，在Xcode的预览中，查看效果 123456789101112131415161718192021222324Button(&quot;Tap Me&quot;) &#123; //animationAmount += 1&#125;.padding(50).background(.red).foregroundColor(.white).clipShape(Circle())//.scaleEffect(animationAmount).overlay(Circle() .stroke(.red) .scaleEffect(animationAmount) .opacity(2 - animationAmount) .animation(.easeInOut(duration: 1).repeatForever(autoreverses: false), value: animationAmount) //使用repeatforever制作连续动画 .onAppear&#123; animationAmount = 2 &#125;).animation(.interpolatingSpring(stiffness: 50, damping: 1), value: animationAmount) //弹簧动画，快速放大然后反弹.animation(.default, value: animationAmount).animation(.easeOut, value: animationAmount).blur(radius: (animationAmount - 1 ) * 3).animation(.easeInOut(duration: 2), value: animationAmount) //持续两秒的缓入缓出动画.animation(.easeOut(duration: 2).delay(1), value: animationAmount) //点击按钮现在将等待一秒钟，然后再执行两秒钟的动画。 需要注意的是，要把.animation放在修饰器最后，这样那些缩放，尺寸变化等动画才能够生效。 动画绑定我们可以将隐式动画中的参数与其他控件绑定，比如和步进器stepper绑定，这样每次点击Stepper的按钮时候，添加了动画的按钮会根据变化的值去调整当前状态，这个过程将会以动画形式呈现。 123456789101112131415161718print(animationAmount)return VStack &#123; Stepper(&quot;Scale amount&quot;, value: $animationAmount.animation(.easeOut(duration: 1) .repeatCount(3, autoreverses: true)), in: 1...10, step: 1) Spacer() Button(&quot;Tap Me&quot;) &#123; animationAmount += 1 &#125; .padding(40) .background(.red) .foregroundStyle(.white) .clipShape(.circle) .scaleEffect(animationAmount) &#125; 创建显式动画我们现在能够通过将animation()修饰符附加到视图来创建隐式动画，以及它如何让我们通过将animation()修饰符添加到绑定来创建动画绑定更改，除此之外，我们还可以通过withAnimation()闭包来创建显式动画。 首先还是创建一个简单的按钮，并为他添加一个3D旋转的修饰符rotation3DEffect()： 12345678910var body: some View &#123; Button(&quot;Tap Me&quot;) &#123; // do nothing &#125; .padding(50) .background(.red) .foregroundStyle(.white) .clipShape(.circle) .rotation3DEffect(.degrees(animationAmount), axis: (x: 0, y: 1, z: 0))&#125; 我们现在希望给Button添加一个动作，来修改animationAmount这个参数。如果直接编写animationAmount += 360，那么更改将立即发生，因为按钮没有附加动画修改器。这就是显式动画的用武之地：如果我们使用withAnimation()闭包，那么 SwiftUI 将确保由新状态引起的任何变化都将自动进行动画处理。 1234567891011121314151617181920212223242526var body: some View &#123; Button(&quot;Tap Me&quot;) &#123; withAnimation &#123; animationAmount += 360 &#125;// withAnimation(.spring(duration: 2, bounce: 0.5)) &#123;// animationAmount += 360// &#125; // do nothing &#125; .padding(50) .background(.red) .foregroundStyle(.white) .clipShape(.circle) .rotation3DEffect(.degrees(animationAmount), axis: (x: 1, y: 1, z: 1))&#125;```withAnimation()可以给一个动画参数，使用你可以在 SwiftUI 的其他地方使用的所有相同的动画。例如，我们可以使用withAnimation()如下调用使我们的旋转效果使用弹簧动画：```swiftwithAnimation(.interpolatingSpring(stiffness: 5, damping: 1)) &#123; animationAmount += 360&#125;// or withAnimation(.spring(duration: 1, bounce: 0.5)) &#123; animationAmount += 360 &#125; 控制动画堆栈我们之前研究过修饰符位置以及顺序的重要性，比如下面两组代码表现出来的样式就是不同的。 123456Button(&quot;Tap Me&quot;) &#123; // do nothing&#125;.background(.blue).frame(width: 200, height: 200).foregroundStyle(.white) 123456Button(&quot;Tap Me&quot;) &#123; // do nothing&#125;.frame(width: 200, height: 200) .background(.blue).foregroundStyle(.white) 这是因为如果我们在调整框架之前给背景着色，那么只有原始空间被着色，而不是扩展的空间。如果你还记得，其根本原因是 SwiftUI 使用修饰符包裹视图的方式，允许我们多次应用相同的修饰符——我们重复background()和padding()多次创建条纹边框效果。 这其实告诉我们，修饰符的顺序很重要，因为 SwiftUI 按照修饰符的应用顺序包装视图。 我们为按钮添加一些修饰器，让他根据某些状态显示不同的颜色 运行下面代码，你会看到点击按钮会使其颜色在蓝色和红色之间变化，这个过程是连续的，而不是由红色直接切换到蓝色。 123456Button(&quot;Tap Me&quot;) &#123; enabled.toggle()&#125;.frame(width: 200, height: 200).background(enabled ? .blue : .red).animation(nil, value: enabled) 运行下面代码，你会看到点击按钮会使其颜色在蓝色和红色之间变化的同时，形状也随之发生改变，并且被我们附加了一个跳动的特效。 12345678910111213@State private var animationAmount = 0.0@State private var enabled = falsevar body: some View &#123; Button(&quot;Tap Me&quot;) &#123; enabled.toggle() &#125; .frame(width: 200, height: 200) .background(enabled ? .blue : .red) .animation(.default, value: enabled) .foregroundStyle(.white) .clipShape(.rect(cornerRadius: enabled ? 60 : 0)) .animation(.spring(duration: 1, bounce: 0.6), value: enabled) 你会看到，如果我们应用多个animation()修改器，每个修改器都会控制它之前的所有内容，直到下一个动画。这允许我们以各种不同的方式为状态变化设置动画，而不是对所有属性都使用同一种动画。 比如对于上面的代码，如果你只希望形状上的变化使用动画，而希望颜色直接变化，可以把第一个.animation中的.deault改为nil，这样，颜色变化的动画就被完全禁用掉了，而下一个形状变化的动画不受影响。 12345678910111213@State private var animationAmount = 0.0@State private var enabled = falsevar body: some View &#123; Button(&quot;Tap Me&quot;) &#123; enabled.toggle() &#125; .frame(width: 200, height: 200) .background(enabled ? .blue : .red) .animation(nil, value: enabled) .foregroundStyle(.white) .clipShape(.rect(cornerRadius: enabled ? 60 : 0)) .animation(.spring(duration: 1, bounce: 0.6), value: enabled) 动画手势SwiftUI 允许我们将手势附加到任何视图，并且这些手势的效果也可以是动画的。我们可以使用一系列手势，例如点击手势让任何视图响应点击，拖动手势响应我们在视图上拖动手指，等等。 稍后我们会更详细地研究手势，但现在让我们尝试一些相对简单的事情：一张我们可以在屏幕上拖动的卡片，但当我们放手时它会弹回到原来的位置。 首先在屏幕中央绘制一个类似卡片的视图。 1234567struct ContentView: View &#123; var body: some View &#123; LinearGradient(colors: [.yellow, .red], startPoint: .topLeading, endPoint: .bottomTrailing) .frame(width: 300, height: 200) .clipShape(.rect(cornerRadius: 10)) &#125;&#125; 想要根据手指的位置在屏幕上移动它，需要存储拖动量，并用.offset()修饰符来移动，它让我们可以调整视图的 X 和 Y 坐标，而无需移动它周围的其他视图。如果愿意，你可以传入离散的 X 和 Y 坐标， offset()也可以直接采用CGSize。 这些创建完后，我们就要做最重要的手势部分了——创建一个DragGesture并将其附加到卡片上。拖动手势有两个对我们有用的额外修饰符：onChanged()让我们在用户移动手指时运行闭包，onEnded()让我们在用户将手指离开屏幕时运行闭包，从而结束拖动。 现在，你的代码应该是这样的,如果使用隐式表达，后面需要加上.animation的修饰符。 12345678910111213141516171819struct ContentView: View &#123; @State private var dragAmount = CGSize.zero var body: some View &#123; LinearGradient(colors: [.yellow, .red], startPoint: .topLeading, endPoint: .bottomTrailing) .frame(width: 300, height: 200) .clipShape(.rect(cornerRadius: 10)) .offset(dragAmount) .gesture( DragGesture() .onChanged &#123; dragAmount = $0.translation &#125; //拖拽的时候是没有动画的 .onEnded &#123; _ in withAnimation(.bouncy) &#123; dragAmount = .zero &#125; //只有释放的时候有动画，显式动画 &#125; ) //.animation(.bouncy, value: dragAmount) &#125;&#125; 试着预览一下，看看效果如何吧。 下面我们将偏移动画与拖动手势和一点延迟相结合，我们就可以创建非常有趣的动画而无需大量代码。 1234567891011121314151617181920212223242526struct ContentView: View &#123; let letters = Array(&quot;Hello SwiftUI&quot;) @State private var enabled = false @State private var dragAmount = CGSize.zero var body: some View &#123; HStack(spacing: 0) &#123; ForEach(0..&lt;letters.count, id: \\.self) &#123; num in Text(String(letters[num])) .padding(5) .font(.title) .background(enabled ? .blue : .red) .offset(dragAmount) .animation(.linear.delay(Double(num) / 20), value: dragAmount) &#125; &#125; .gesture( DragGesture() .onChanged &#123; dragAmount = $0.translation &#125; .onEnded &#123; _ in dragAmount = .zero enabled.toggle() &#125; ) &#125;&#125; 拖拽的时候，字母会跟着轨迹蛇形游动，并在释放的时候变换颜色。 使用transitions显示或隐藏视图SwiftUI 最强大的功能之一是能够自定义视图显示和隐藏的方式。之前您已经了解了我们如何使用常规if条件来有条件地包含视图，这意味着当该条件发生变化时，我们可以在我们的视图层次结构中插入或删除视图。 Transitions 控制这种插入和移除是如何发生的，我们可以使用内置的 transitions，以不同的方式组合它们，甚至创建完全自定义的 transitions。 我们设置一个按钮和一个矩形，并让矩形只有在满足某个条件时才会出现，然后用按钮控制它的出现和消失。 12345678910111213141516171819202122struct ContentView: View &#123; @State private var isShowingRed = false //定义矩形是否出现的状态 var body: some View &#123; VStack &#123; Button(&quot;Tap Me&quot;) &#123; //isShowingRed.toggle() withAnimation &#123; isShowingRed.toggle() //使用按钮切换矩形显示状态 &#125; // do nothing &#125; if isShowingRed &#123; //显示条件 Rectangle() .fill(.red) .frame(width: 200, height: 200) //.transition(.scale) //.transition(.asymmetric(insertion: .scale, removal: .opacity)) &#125; &#125; &#125;&#125; 使用transition可以通过不同参数来控制变换的样式。我们可以让矩形按比例放大和缩小 ，也可以尝试其他一些过渡。一个有用的是.asymmetric，它让我们可以在显示视图时使用一种转换，而在视图消失时使用另一种转换 （见上方代码注释部分）。 使用ViewModifier构建自定义转换为 SwiftUI 创建全新的过渡是可能的——而且实际上非常容易——允许我们使用完全自定义的动画添加和删除视图。 这个功能是通过.modifier转换实现的，它接受我们想要的任何视图修饰符。问题是我们需要能够实例化修饰符，这意味着它需要是我们自己创建的。 为了尝试这一点，我们可以编写一个视图修改器，让我们模仿 Keynote 中的 Pivot 动画——它会导致一张新幻灯片从其左上角向内旋转。在 SwiftUI 中，这意味着创建一个视图修改器，使我们的视图从一个角向内旋转，而不会脱离它应该位于的边界。SwiftUI 实际上为我们提供了修改器来做到这一点：rotationEffect()让我们在 2D 空间中旋转视图, 和clipped()停止在其矩形空间之外绘制视图。 rotationEffect()类似于rotation3DEffect()，只是它始终围绕 Z 轴旋转。然而，它也让我们能够控制旋转的锚点——视图的哪一部分应该固定在适当的位置作为旋转的中心。SwiftUI 为我们提供了UnitPoint一种用于控制锚点的类型，它让我们可以为旋转指定一个精确的 X&#x2F;Y 点，或者使用许多内置选项中的一个—— &#96;&#96;.topLeading、.bottomTrailing、.center&#96;等等。 让我们通过创建一个结构将所有这些放入代码中，该CornerRotateModifier结构具有一个锚点来控制旋转应该发生的位置，以及一个数量来控制应该应用多少旋转： 12345678910struct CornerRotateModifier: ViewModifier &#123; let amount: Double let anchor: UnitPoint func body(content: Content) -&gt; some View &#123; content .rotationEffect(.degrees(amount), anchor: anchor) .clipped() &#125;&#125; 添加clipped()意味着当视图旋转时，位于其自然矩形之外的部分不会被绘制。 我们可以直接使用.modifier转换来尝试，但它有点笨拙。一个更好的主意是将其包装在 AnyTransition的扩展名中，使其在其顶部前角从 -90 旋转到 0： 12345678extension AnyTransition &#123; static var pivot: AnyTransition &#123; .modifier( active: CornerRotateModifier(amount: -90, anchor: .topLeading), identity: CornerRotateModifier(amount: 0, anchor: .topLeading) ) &#125;&#125; 例如，我们可以使用onTapGesture()修改器在屏幕上创建一个红色矩形枢轴，如下所示： 1234567891011121314151617181920212223struct ContentView: View &#123; @State private var isShowingRed = false var body: some View &#123; ZStack &#123; Rectangle() .fill(.blue) .frame(width: 200, height: 200) if isShowingRed &#123; Rectangle() .fill(.red) .frame(width: 200, height: 200) .transition(.pivot) &#125; &#125; .onTapGesture &#123; withAnimation &#123; isShowingRed.toggle() &#125; &#125; &#125;&#125;","categories":[{"name":"技术","slug":"技术","permalink":"https://blog.five2fire.top/categories/%E6%8A%80%E6%9C%AF/"}],"tags":[{"name":"编程","slug":"编程","permalink":"https://blog.five2fire.top/tags/%E7%BC%96%E7%A8%8B/"},{"name":"Swift","slug":"Swift","permalink":"https://blog.five2fire.top/tags/Swift/"},{"name":"Hacking with Swift","slug":"Hacking-with-Swift","permalink":"https://blog.five2fire.top/tags/Hacking-with-Swift/"}]},{"title":"【Hacking With Swift】project5_WordScramble","slug":"project5-wordscramble","date":"2024-06-14T13:35:23.000Z","updated":"2025-01-02T02:17:10.822Z","comments":true,"path":"article/41438.html","permalink":"https://blog.five2fire.top/article/41438.html","excerpt":"","text":"英文原博博主是 Paul Hudson @twostraws 本文是学习Swift过程中翻译该网站的内容: https://www.hackingwithswift.com/ 简介该项目会创建这样一个游戏，先向玩家展示一个随机的八个字母的单词，并要求他们将其拼成单词。例如，如果起始词是“alarming”，他们可能拼写为“alarm”、“ring”、“main”等。 在这个过程中，我们会遇到如何处理List，如何处理String，如何读取文件（使用Bundle），以及如何处理错误（fatalError()）等问题。 这是最后一个简单项目，往后就要有更多的挑战了！ 更好地使用ListList和Form几乎相同，实际上Form是一种特殊类型的List。你可以在List中添加静态Text视图，也可以通过ForEach动态地创建视图，当然也可以将二者结合。 1234567891011121314151617181920212223List &#123; Text(&quot;Hello World&quot;) Text(&quot;Hello World&quot;) Text(&quot;Hello World&quot;)&#125;List &#123; ForEach(0..&lt;5) &#123; Text(&quot;Dynamic row \\($0)&quot;) &#125;&#125;List &#123; Text(&quot;Static row 1&quot;) Text(&quot;Static row 2&quot;) ForEach(0..&lt;5) &#123; Text(&quot;Dynamic row \\($0)&quot;) &#125; Text(&quot;Static row 3&quot;) Text(&quot;Static row 4&quot;)&#125; 对于List内的视图，也可以用VStack，Section等将视图结合起来。 1234567891011121314151617List &#123; Section(&quot;Section 1&quot;) &#123; Text(&quot;Static row 1&quot;) Text(&quot;Static row 2&quot;) &#125; Section(&quot;Section 2&quot;) &#123; ForEach(0..&lt;5) &#123; Text(&quot;Dynamic row \\($0)&quot;) &#125; &#125; Section(&quot;Section 3&quot;) &#123; Text(&quot;Static row 3&quot;) Text(&quot;Static row 4&quot;) &#125;&#125; 对于列表的外观，可以使用.listStyle(.grouped)来修饰。如果整个列表都是由动态视图组成的，也可以不用ForEach，而是直接在List后编写与ForEach类似的代码。 123List(0..&lt;5) &#123; Text(&quot;Dynamic row \\($0)&quot;)&#125; 如果想动态地引用数组中的数据并展示在List中，可以使用id: /.self 12345678910111213141516171819struct ContentView: View &#123; let people = [&quot;Finn&quot;, &quot;Leia&quot;, &quot;Luke&quot;, &quot;Rey&quot;] var body: some View &#123; List(people, id: \\.self) &#123; Text($0) &#125; &#125;&#125;//同样可以混合动态视图和静态视图List &#123; Text(&quot;Static Row&quot;) ForEach(people, id: \\.self) &#123; Text($0) &#125; Text(&quot;Static Row&quot;)&#125; 加载URL或本地资源使用Bundle.main.url()可以读取主应用程序包中文件的URL。如果文件存在，它将被发回给我们，否则我们会返回nil，所以这是一个可选的URL。读取之后，我们使用String(contentOf：xxx)来处理。 1234567if let fileURL = Bundle.main.url(forResource: &quot;some-file&quot;, withExtension: &quot;txt&quot;) &#123; // we found the file in our bundle!&#125;if let fileContents = try? String(contentsOf: fileURL) &#123; // we loaded the file into a string!&#125; 处理字符串Strings这里直接介绍一些函数或参数的作用 123456789101112```randomElement()```用于从数组中随即返回一个项目。```trimmingCharacters(in:)```要求 Swift 从字符串的开头和结尾删除某些类型的字符，可以用来删除字符串中的空格或者换行符。最后还有一个提供检查单词拼写错误的功能```UITextChecker```。具体的用法是```swiftlet word = &quot;swift&quot;let checker = UITextChecker()let range = NSRange(location: 0, length: word.utf16.count)let misspelledRange = checker.rangeOfMisspelledWord(in: word, range: range, startingAt: 0, wrap: false, language: &quot;en&quot;)let allGood = misspelledRange.location == NSNotFound 由于Swift和Objective-C存储字母的方式不太一样，这里let range = NSRange(location: 0, length: word.utf16.count)我们要创建一个OC字符串范围，并在checker中使用。UITextChecker()同样也返回一个特殊值NSNotFound 正式构建这个游戏在开篇提到的简介中，需要展示文本，也需要用户输入文本并将符合一定条件（不为空，拼写正确，并且使用给定的字母组合出）的单词显示出来。这需要我们构建一下几个函数: func startGame()用于开始新游戏，给出一个新的随机单词 func addNewWord()用于用户输入单词后，将该单词添加至待显示的列表中 func isOriginal(word: String)用于判断单词是否重复 func isPossible(word: String)用于判断用户输入的单词是否是从给定的随记单词中选定字母的 func isReal(word: String)用于判断单词拼写的是否正确（是否是一个单词） func wordError(title: String, message: String)用于处理错误情况。 具体代码如下： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364func addNewWord() &#123; // lowercase and trim the word, to make sure we don&#x27;t add duplicate words with case differences let answer = newWord.lowercased().trimmingCharacters(in: .whitespacesAndNewlines) // exit if the remaining string is empty guard answer.count &gt; 0 else &#123; return &#125; // extra validation to come usedWords.insert(answer, at: 0) newWord = &quot;&quot;&#125;func startGame() &#123; // 1. Find the URL for start.txt in our app bundle if let startWordsURL = Bundle.main.url(forResource: &quot;start&quot;, withExtension: &quot;txt&quot;) &#123; // 2. Load start.txt into a string if let startWords = try? String(contentsOf: startWordsURL) &#123; // 3. Split the string up into an array of strings, splitting on line breaks let allWords = startWords.components(separatedBy: &quot;\\n&quot;) // 4. Pick one random word, or use &quot;silkworm&quot; as a sensible default rootWord = allWords.randomElement() ?? &quot;silkworm&quot; // If we are here everything has worked, so we can exit return &#125; &#125; // If were are *here* then there was a problem – trigger a crash and report the error fatalError(&quot;Could not load start.txt from bundle.&quot;)&#125;func isOriginal(word: String) -&gt; Bool &#123; !usedWords.contains(word)&#125;func isPossible(word: String) -&gt; Bool &#123; var tempWord = rootWord for letter in word &#123; if let pos = tempWord.firstIndex(of: letter) &#123; tempWord.remove(at: pos) &#125; else &#123; return false &#125; &#125; return true&#125;func isReal(word: String) -&gt; Bool &#123; let checker = UITextChecker() let range = NSRange(location: 0, length: word.utf16.count) let misspelledRange = checker.rangeOfMisspelledWord(in: word, range: range, startingAt: 0, wrap: false, language: &quot;en&quot;) return misspelledRange.location == NSNotFound&#125;func wordError(title: String, message: String) &#123; errorTitle = title errorMessage = message showingError = true&#125; 最后使用以下代码来判断用户输入是否符合要求，错误将显示对应的提示框。 1234567891011121314guard isOriginal(word: answer) else &#123; wordError(title: &quot;Word used already&quot;, message: &quot;Be more original&quot;) return&#125;guard isPossible(word: answer) else &#123; wordError(title: &quot;Word not possible&quot;, message: &quot;You can&#x27;t spell that word from &#x27;\\(rootWord)&#x27;!&quot;) return&#125;guard isReal(word: answer) else &#123; wordError(title: &quot;Word not recognized&quot;, message: &quot;You can&#x27;t just make them up, you know!&quot;) return&#125; 最终所有代码如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120import SwiftUIstruct ContentView: View &#123; @State private var usedWords = [String]() @State private var rootWord = &quot;&quot; @State private var newWord = &quot;&quot; //alarm @State private var errorTitle = &quot;&quot; @State private var errorMessage = &quot;&quot; @State private var showingError = false var body: some View &#123; NavigationStack&#123; List&#123; Section &#123; TextField(&quot;Enter your word&quot;, text: $newWord) .textInputAutocapitalization(.never) &#125; Section &#123; ForEach(usedWords, id: \\.self)&#123; word in HStack&#123; Image(systemName: &quot;\\(word.count).circle&quot;) Text(word) &#125; &#125; &#125; &#125; .navigationTitle(rootWord) .onSubmit(addNewWord) .onAppear(perform:startGame) .alert(errorTitle, isPresented: $showingError) &#123; Button(&quot;OK&quot;) &#123; &#125; &#125; message: &#123; Text(errorMessage) &#125; &#125; &#125; func startGame() &#123; if let startWordURL = Bundle.main.url(forResource: &quot;start&quot;, withExtension: &quot;txt&quot;) &#123; if let startWords = try? String(contentsOf: startWordURL) &#123; let allWords = startWords.components(separatedBy: &quot;\\n&quot;) rootWord = allWords.randomElement() ?? &quot;silkworm&quot; return &#125; &#125; fatalError(&quot;Could not load start.txt from bundle.&quot;) &#125; func addNewWord() &#123; let answer = newWord.lowercased().trimmingCharacters(in: .whitespacesAndNewlines) guard answer.count &gt; 0 else &#123;return&#125; guard isOriginal(word: answer) else &#123; wordError(title: &quot;Word used already&quot;, message: &quot;Be more original&quot;) return &#125; guard isPossible(word: answer) else &#123; wordError(title: &quot;Word not possible&quot;, message: &quot;You can&#x27;t spell that word from &#x27;\\(rootWord)&#x27;!&quot;) return &#125; guard isReal(word: answer) else &#123; wordError(title: &quot;Word not recognized&quot;, message: &quot;You can&#x27;t just make them up, you know!&quot;) return &#125; withAnimation &#123; usedWords.insert(answer, at: 0) &#125; newWord = &quot;&quot; &#125; func isOriginal(word: String) -&gt; Bool &#123; !usedWords.contains(word) &#125; func isPossible(word: String) -&gt; Bool &#123; var tempWord = rootWord for letter in word &#123; if let pos = tempWord.firstIndex(of: letter) &#123; tempWord.remove(at: pos) &#125;else &#123; return false &#125; &#125; return true &#125; func isReal(word: String) -&gt; Bool&#123; let checker = UITextChecker() let range = NSRange(location: 0, length: word.utf16.count) let misspelledRange = checker.rangeOfMisspelledWord(in: word, range: range, startingAt: 0, wrap: false, language: &quot;en&quot;) return misspelledRange.location == NSNotFound &#125; func wordError(title: String, message: String) &#123; errorTitle = title errorMessage = message showingError = true &#125; &#125;#Preview &#123; ContentView()&#125;","categories":[{"name":"技术","slug":"技术","permalink":"https://blog.five2fire.top/categories/%E6%8A%80%E6%9C%AF/"}],"tags":[{"name":"编程","slug":"编程","permalink":"https://blog.five2fire.top/tags/%E7%BC%96%E7%A8%8B/"},{"name":"Swift","slug":"Swift","permalink":"https://blog.five2fire.top/tags/Swift/"},{"name":"Hacking with Swift","slug":"Hacking-with-Swift","permalink":"https://blog.five2fire.top/tags/Hacking-with-Swift/"}]},{"title":"【Hacking With Swift】Project4_BetterRest","slug":"Project4-BetterRest","date":"2024-06-06T12:56:13.000Z","updated":"2025-01-02T02:17:10.816Z","comments":true,"path":"article/5898.html","permalink":"https://blog.five2fire.top/article/5898.html","excerpt":"","text":"英文原博博主是 Paul Hudson @twostraws 本文是学习Swift过程中翻译该网站的内容: https://www.hackingwithswift.com/ 简介该项目主要用于了解IOS中一项很强大的功能——机器学习。 运用机器学习，分析数据。从而通过每天摄入咖啡量，希望醒来的时刻以及所需睡眠量，来计算出何时应该上床睡觉了。 在这个过程中，我们将遇到 Stepper、DatePicker、DateFormatter等内容。 在程序中，需要引导用户输入一天摄入的咖啡量、需要睡眠的时长以及希望何时醒来这三个变量，并存储下来。将这三个变量输入进训练好的模型进行预测，预测得出建议上床睡觉的时间，将这个时间显示给用户。 使用Stepper输入数字我们用Stepper控件输入需要睡眠的时长，创建一个sleepAmount变量 1@State private var sleepAmount = 8.0 并与一个Stepper显示的值绑定。 1Stepper(&quot;\\(sleepAmount) hours&quot;, value: $sleepAmount) 可以使用in关键字来限制Stepper的输入范围，并且设定每一次点击数字的增减量（步长）。另外由于sleepAmount是个浮点数，如果不想后面显示一大串小数，比如8.0000000，可以使用.formatted()来美化。整体代码如下： 12Stepper(&quot;\\(sleepAmount.formatted()) hours&quot;,value: $sleepAmount, in: 4...12, step: 0.25) 使用DatePicker选择日期和时间SwiftUI提供了一个专用的日期时间选择器控件，DatePicker。同样也有一个专门处理日期的类型——Date。 可以这样使用Date类以及DatePicker控件： 1@State private var wakeUp = Date.now 1DatePicker(&quot;Please enter a date&quot;, selection: $wakeUp) “Please enter a date”是这个DatePicker的标签，也可以直接删除他，但是删除了之后控件左侧会出现大量空白，导致观感很差，这时候可以用.labelHidden()将标签隐藏掉。 12DatePicker(&quot;Please enter a date&quot;, selection: $wakeUp) .labelsHidden() .hourAndMinute```来控制。123```swiftDatePicker(&quot;Please enter a time&quot;, selection: $wakeUp, displayedComponents: .hourAndMinute) 与Stepper类似，也可以使用in关键字来控制可选日期的范围，这时候需要借助Date类来创建范围，比如下面这样。 123456789func exampleDates() &#123; // create a second Date instance set to one day in seconds from now let tomorrow = Date.now.addingTimeInterval(86400) // create a range from those two let range = Date.now...tomorrowDatePicker(&quot;Please enter a date&quot;, selection: $wakeUp, in: Date.now...)&#125; 关于SwiftUI中日期的处理上面提到，Swift提供了一个Date类专门用于处理日期，但是如果只想获取Date中的某一部分，比如hour或是minute，就需要借助另一个工具——DateComponents。 例如，如果我们想要一个代表今天早上 8 点的日期，我们可以编写如下代码： 1234var components = DateComponents()components.hour = 8components.minute = 0let date = Calendar.current.date(from: components) ?? Date.now //如果失败就返回当前日期 我们也可以返回一个DateComponents实例，然后从实例中提取我们想要的部分，当然，可以限制返回的这个实例只包含小时和分钟，这样就可以对应上DatePicker中的日期了。 123let components = Calendar.current.dateComponents([.hour, .minute], from: someDate)let hour = components.hour ?? 0let minute = components.minute ?? 0 最后是如何格式化日期还有时间，有两种方法：一种使用format参数，一种使用.formatted()。例如 123Text(Date.now, format: .dateTime.hour().minute()) //使用format参数，获取小时和分钟Text(Date.now, format: .dateTime.day().month().year()) //使用format参数，获取年月日Text(Date.now.formatted(date: .long, time: .shortened)) //使用.formatted()，让日期和时间按照系统中内置的几种方式显示 使用Create ML训练模型使用Create ML训练模型的步骤： 左上角Xcode菜单——Open Developer Tool —— Create ML 点击new document，会打开非常多的模板，在这个项目中我们选择Tabular Regression 点击下一步，会要求输入项目名称，我们输入BetterRest。然后选择一个位置点击保存。 界面中会出现一些需要配置的框图。我们需要添加训练数据，点击training Date下的Choose，选择一个csv文件。此时我们还没有选择我们的目标target。 点击下方的target，系统会从training data中解析出一些参数，我们选择actual sleep 同样的，在features里，选择其他的一些参数，这里是wake，estimatedsleep以及coffee。 在下方的parameters中，选择一个算法，我们这里使用默认的算法（自动选择）。 万事俱备了，接下来点击左上角的train按钮，你可以在training的tab页中查看进度，等待一段时间后，训练完成。 在evaluate的tab页中，可以查看最终的训练验证结果，里面给出了maximum error和root mean square error。 点击output tab页，可以看到这里已经生成了一个模型文件。点击get，将模型文件保存下来，这样我们在项目中可以使用它。 我们也可以切换算法，点击左侧窗口的模型源，然后选择复制，重新进行训练。 开始构建应用程序现在我们已经做好了准备，将前面提到的那些我们需要的组件放置在界面上。 最关键的步骤是，如何利用我们训练好的模型计算何时上床睡觉。 在IOS17后，我们需要先import CoreML，然后在函数中引入模型。在calculateBedtime函数中，我们要这样写 1234567891011121314151617181920212223242526272829303132func calculateBedtime() -&gt; String &#123; //let model = SleepCalculator() let model: SleepCalculator = &#123; do &#123; let config = MLModelConfiguration() return try SleepCalculator(configuration: config) &#125; catch &#123; //return &quot;Error&quot; //print(error) fatalError(&quot;Couldn&#x27;t create SleepCalculator&quot;) &#125; &#125;() let componenets = Calendar.current.dateComponents([.hour, .minute], from: wakeUp) let hour = (componenets.hour ?? 0) * 60 * 60 let minute = (componenets.minute ?? 0) * 60 do &#123; let prediction = try model.prediction(wake: Double(hour + minute), estimatedSleep: sleepAmount, coffee: Double(coffeeAmount)) let sleepTime = wakeUp - prediction.actualSleep let formatter = DateFormatter() formatter.timeStyle = .short return formatter.string(from: sleepTime) &#125; catch &#123; return &quot;Error&quot; &#125; &#125; 使用do&#x2F;catch代码块是因为在使用CoreML的时候会在加载模型以及使用模型预测的时候抛出错误，这样做是为了保证程序的安全不会出错。 模型返回的是一个Double数，拿wakeUp直接减去prediction.actualSleep就能够得到sleeptime了。注意这里wakeUP是一个Date值，Apple强大的API使我们可以直接拿这个Date值减去一个值然后得到一个新的Date。 最后我们创建一个提示框，用来显示我们的预测。创建提示框的标题，信息以及是否显示等变量。 123@State private var alertTitle = &quot;&quot;@State private var alertMessage = &quot;&quot;@State private var showingAlert = false 无论预测是否成功，我们都应该给用户提示，因此将下面的代码放入预测之后的catch代码块中 1showingAlert = true 如果预测成功，我们将提示的标题和内容改为 12alertTitle = &quot;Your ideal bedtime is…&quot;alertMessage = sleepTime.formatted(date: .omitted, time: .shortened) 如果预测失败，则 12alertTitle = &quot;Error&quot;alertMessage = &quot;Sorry, there was a problem calculating your bedtime.&quot; 最后，我们将下方的修饰符添加到VStack中，就完成了提示框部分的开发。 12345.alert(alertTitle, isPresented: $showingAlert) &#123; Button(&quot;OK&quot;) &#123; &#125;&#125; message: &#123; Text(alertMessage)&#125; 优化用户体验本项目中，我们用户选择希望醒来的时间的时候，由于我们给出了Date.now，所以是从现在的时间开始选择。但大多数人希望醒来的时间在早上6点和8点之间，因此我们可以创建一个默认的醒来时间供用户选择。 12345678var defaultWakeTime: Date &#123; var components = DateComponents() components.hour = 7 components.minute = 0 return Calendar.current.date(from: components) ?? .now&#125;@State private var wakeUp = defaultWakeTime 最后一行代码会出错，因为我们正在从另一个属性内部访问一个属性。可以将defaultWakeTime设置为一个静态变量，这样它不依赖于任何其他属性，而是属于结构本身，就不会报错了。 1static var defaultWakeTime: Date 这个项目就基本完成了！ 完整代码 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687import SwiftUIimport CoreMLstruct ContentView: View &#123; static var defaultWakeTime: Date &#123; var components = DateComponents() components.hour = 7 components.minute = 0 return Calendar.current.date(from: components) ?? .now &#125; @State private var sleepAmount = 8.0 @State private var wakeUp = defaultWakeTime @State private var coffeeAmount = 1 @State private var alertTitle = &quot;&quot; @State private var alertMessage = &quot;&quot; @State private var showingAlert = false var body: some View &#123; NavigationStack&#123; Form &#123; VStack(alignment: .leading)&#123; Text(&quot;When do you want to wake up?&quot;) .font(.headline) DatePicker(&quot;Please enter a time&quot;, selection: $wakeUp, displayedComponents: .hourAndMinute) .labelsHidden() Text(&quot;Desired amount of sleep&quot;) .font(.headline) Stepper(&quot;\\(sleepAmount.formatted()) hours&quot;, value: $sleepAmount, in: 4...12, step: 0.25) Text(&quot;Daily coffe intake&quot;) .font(.headline) Stepper(&quot;^[\\(coffeeAmount) cup](inflect: true)&quot;, value: $coffeeAmount, in: 1...10, step: 1) &#125; &#125; VStack&#123; &#125; VStack&#123; &#125; .alert(alertTitle, isPresented: $showingAlert) &#123; Button(&quot;OK&quot;) &#123; &#125; &#125; message: &#123; Text(alertMessage) &#125; .navigationTitle(&quot;BetterRest&quot;) .toolbar&#123; Button(&quot;Calculate&quot;, action: calculateBedtime) &#125; &#125; &#125; func calculateBedtime() &#123; do &#123; let config = MLModelConfiguration() let model = try SleepCalculator(configuration: config) let components = Calendar.current.dateComponents([.hour, .minute], from: wakeUp) let hour = (components.hour ?? 0) * 60 * 60 let minute = (components.minute ?? 0) * 60 let prediction = try model.prediction(wake: Int64(Double(hour + minute)), estimatedSleep: sleepAmount, coffee: Int64(Double(coffeeAmount))) let sleepTime = wakeUp - prediction.actualSleep alertTitle = &quot;Your ideal bedtime is…&quot; alertMessage = sleepTime.formatted(date: .omitted, time: .shortened) showingAlert = true &#125;catch &#123; alertTitle = &quot;Error&quot; alertMessage = &quot;Sorry, there was a problem calculating your bedtime.&quot; showingAlert = true &#125; &#125;&#125;#Preview &#123; ContentView()&#125;","categories":[{"name":"技术","slug":"技术","permalink":"https://blog.five2fire.top/categories/%E6%8A%80%E6%9C%AF/"}],"tags":[{"name":"编程","slug":"编程","permalink":"https://blog.five2fire.top/tags/%E7%BC%96%E7%A8%8B/"},{"name":"Swift","slug":"Swift","permalink":"https://blog.five2fire.top/tags/Swift/"},{"name":"Hacking with Swift","slug":"Hacking-with-Swift","permalink":"https://blog.five2fire.top/tags/Hacking-with-Swift/"}]},{"title":"【Hacking With Swift】Project3_ViewsAndModels","slug":"Project3_ViewsAndModels","date":"2024-06-03T11:20:55.000Z","updated":"2025-01-02T02:17:10.816Z","comments":true,"path":"article/41590.html","permalink":"https://blog.five2fire.top/article/41590.html","excerpt":"","text":"英文原博博主是 Paul Hudson @twostraws 本文是学习Swift过程中翻译该网站的内容: https://www.hackingwithswift.com/ 1.视图和修饰符的简介在这个项目中，我们将弄明白为什么Swift中使用结构体而不是用类来编程，以及为什么some View有那么多。 在项目结尾希望你能够彻底了解Swift是通过什么运转起来的。 2.为什么 SwiftUI 对视图使用结构体？一个是为了性能考虑，结构体的创建很简单，可以包含一个整数，也可以包含一个复杂结构。 另外，除了性能方面，还有一个很重要的原因，就是隔离。我们可以更改类中的值，这会导致混乱，但想要更改结构体中的值，需要使用特定的方法。 3.SwiftUI 主视图的背后是什么？在刚创建一个新项目的时候，会有以下默认代码，如果希望修改背景颜色，仅仅做出以下改变是不够的： 1234567struct ContentView: View &#123; var body: some View &#123; Text(&quot;Hello, world!&quot;) .padding() .background(.red) &#125;&#125; 因为这里的.background(.red)只作用于Text这么大小的视图，并不能应用于整个背景，事实上，整个视图除了这个Text视图外，并没有一个叫“背景”的视图，如果你想要填充背景，正确的解决方案就是让文本视图占用更多空间，可以使用frame()修饰符来做到这一点。 123Text(&quot;Hello, world!&quot;) .frame(maxWidth: .infinity, maxHeight: .infinity) .background(.red) 4.修饰顺序也很重要每个修饰符都创建一个应用了该修饰符的新结构，而不是仅仅在视图上设置一个属性。 使用修饰符的一个重要副作用是我们可以多次应用相同的效果：每个都只是添加到之前的任何内容上。 例如，SwiftUI 为我们提供了padding()修饰符，它在视图周围增加了一点空间，这样它就不会向上推到其他视图或屏幕边缘。如果我们应用 padding 然后是背景颜色，然后是更多的 padding 和不同的背景颜色，我们可以给视图多个边框，像这样： 123456789Text(&quot;Hello, world!&quot;) .padding() .background(.red) .padding() .background(.blue) .padding() .background(.green) .padding() .background(.yellow) 5.为什么 SwiftUI 使用“some View”作为它的视图类型？表示这个结构中包含不同种视图类型，如果只包含一种，比如Text类型，也可以使用Text作为视图类型，例如 12345struct ContentView: View &#123; var body: Text &#123; Text(&quot;Hello World&quot;) &#125;&#125; 这个也是完全合法的 6.条件修饰符使用三元运算符替代if语句，if语句在一些情况下效率比较低，使用三元运算符会大大简化代码。例如： 1234567891011struct ContentView: View &#123; @State private var useRedText = false var body: some View &#123; Button(&quot;Hello World&quot;) &#123; // flip the Boolean between true and false useRedText.toggle() &#125; .foregroundColor(useRedText ? .red : .blue) &#125;&#125; 因此，当useRedText为 true 时，修饰符有效地读取.foregroundColor(.red)，而当它为false时，修饰符变为.foregroundColor(.blue)。因为 SwiftUI 会监视我们@State属性的变化并重新调用我们的body属性，所以只要该属性发生变化，颜色就会立即更新。 7.环境修饰符许多修饰符可以应用于容器，这允许我们同时将相同的修饰符应用于多个视图。 例如，如果我们在一个 VStack中有四个文本视图，并希望为它们提供相同的字体修饰符，我们可以直接将修饰符应用于VStack并将该更改应用于所有四个文本视图： 1234567VStack &#123; Text(&quot;Gryffindor&quot;) Text(&quot;Hufflepuff&quot;) Text(&quot;Ravenclaw&quot;) Text(&quot;Slytherin&quot;)&#125;.font(.title) 这称为环境修改器，不同于应用于视图的常规修改器。 从编码的角度来看，这些修饰符的使用方式与常规修饰符完全相同。但是，它们的行为略有不同，因为如果这些子视图中的任何一个覆盖了相同的修饰符，则子视图的版本优先。 例如，这显示了我们的四个带有标题字体的文本视图，但其中一个标题较大： 12345678VStack &#123; Text(&quot;Gryffindor&quot;) .font(.largeTitle) Text(&quot;Hufflepuff&quot;) Text(&quot;Ravenclaw&quot;) Text(&quot;Slytherin&quot;)&#125;.font(.title) 那里有font()一个环境修饰符，这意味着 Gryffindor 文本视图可以用自定义字体覆盖它。 但是，这对VStack然后尝试在其中一个文本视图上禁用模糊应用了模糊效果： 12345678VStack &#123; Text(&quot;Gryffindor&quot;) .blur(radius: 0) Text(&quot;Hufflepuff&quot;) Text(&quot;Ravenclaw&quot;) Text(&quot;Slytherin&quot;)&#125;.blur(radius: 5) 这不会以相同的方式工作：blur()是常规修改器，因此应用于子视图的任何模糊都将添加到VStack模糊而不是替换它。 但我们没有办法提前知道哪些修改器是环境修改器，哪些是常规修改器，除非阅读每个修改器的单独文档并希望它被提及。尽管如此，有总比没有好。 8.视图作为属性有很多方法可以让 SwiftUI 中的复杂视图层次结构更容易使用，其中一种选择是使用属性——创建一个视图作为你自己视图的属性，然后在你的布局中使用该属性。 例如，我们可以像这样创建两个文本视图作为属性，然后在一个VStack中使用它们： 1234567891011struct ContentView: View &#123; let motto1 = Text(&quot;Draco dormiens&quot;) let motto2 = Text(&quot;nunquam titillandus&quot;) var body: some View &#123; VStack &#123; motto1 motto2 &#125; &#125;&#125; 你甚至可以在使用这些属性时直接将修饰符应用于它们，如下所示： 123456VStack &#123; motto1 .foregroundColor(.red) motto2 .foregroundColor(.blue)&#125; 将视图创建为属性有助于使你的body代码更清晰——它不仅有助于避免重复，而且还可以从body属性中获取更复杂的代码。 9.查看组成SwiftUI 让我们可以将复杂的视图分解成更小的视图，而不会对性能产生太大影响。这意味着我们可以将一个大视图拆分为多个较小的视图，而 SwiftUI 会负责为我们重新组装它们。 例如，在这个视图中，我们有一种特殊的方式来设置文本视图的样式——它们有一个大字体、一些填充、前景色和背景色，以及一个胶囊形状： 12345678910111213141516171819struct ContentView: View &#123; var body: some View &#123; VStack(spacing: 10) &#123; Text(&quot;First&quot;) .font(.largeTitle) .padding() .foregroundColor(.white) .background(.blue) .clipShape(Capsule()) Text(&quot;Second&quot;) .font(.largeTitle) .padding() .foregroundColor(.white) .background(.blue) .clipShape(Capsule()) &#125; &#125;&#125; 因为这两个文本视图除了文本之外是相同的，所以我们可以将它们包装在一个新的自定义视图中，如下所示： 123456789101112struct CapsuleText: View &#123; var text: String var body: some View &#123; Text(text) .font(.largeTitle) .padding() .foregroundColor(.white) .background(.blue) .clipShape(Capsule()) &#125;&#125; 然后我们可以在原始视图中使用该CapsuleText视图，如下所示： 12345678struct ContentView: View &#123; var body: some View &#123; VStack(spacing: 10) &#123; CapsuleText(text: &quot;First&quot;) CapsuleText(text: &quot;Second&quot;) &#125; &#125;&#125; 当然，我们也可以在视图中存储一些修饰符，在使用时自定义其他的。例如，如果我们从CapsuleText中删除foregroundColor()，那么我们可以在创建该视图的实例时应用自定义颜色，如下所示： 123456VStack(spacing: 10) &#123; CapsuleText(text: &quot;First&quot;) .foregroundColor(.white) CapsuleText(text: &quot;Second&quot;) .foregroundColor(.yellow)&#125; 不要担心这里的性能问题——以这种方式分解 SwiftUI 视图非常有效。 10.自定义修饰符要创建自定义修饰符，请创建一个符合ViewModifier协议的新结构。这只有一个要求，即一种被调用的方法body，它接受要处理的任何内容，并且必须返回some View。 例如： 12345678910struct Title: ViewModifier &#123; func body(content: Content) -&gt; some View &#123; content .font(.largeTitle) .foregroundColor(.white) .padding() .background(.blue) .clipShape(RoundedRectangle(cornerRadius: 10)) &#125;&#125; 我们现在可以将它与modifier()修饰符一起使用——是的，它是一个名为“modifier”的修饰符，但它允许我们将任何类型的修饰符应用于视图，如下所示： 12Text(&quot;Hello World&quot;) .modifier(Title()) 创建自定义View之后，创建扩展以View使其更易于使用 例如，我们可以将Title修饰符包装在这样的扩展中： 12345extension View &#123; func titleStyle() -&gt; some View &#123; modifier(Title()) &#125;&#125; 我们现在可以像这样使用修饰符： 12Text(&quot;Hello World&quot;) .titleStyle() 自定义修饰符可以做的不仅仅是应用其他现有修饰符——它们还可以根据需要创建新的视图结构。请记住，修饰符返回新对象而不是修改现有对象，因此我们可以创建一个将视图嵌入堆栈并添加另一个视图的对象： 1234567891011121314151617181920struct Watermark: ViewModifier &#123; var text: String func body(content: Content) -&gt; some View &#123; ZStack(alignment: .bottomTrailing) &#123; content Text(text) .font(.caption) .foregroundColor(.white) .padding(5) .background(.black) &#125; &#125;&#125;extension View &#123; func watermarked(with text: String) -&gt; some View &#123; modifier(Watermark(text: text)) &#125;&#125; 有了它，我们现在可以像这样向任何视图添加水印： 123Color.blue .frame(width: 300, height: 200) .watermarked(with: &quot;Hacking with Swift&quot;) 提示：通常人们想知道什么时候添加自定义视图修饰符比只添加一个新方法给View更好，实际上这归结为一个主要原因：自定义视图修饰符可以有自己的存储属性，而扩展View则不能。 11.定制容器利用泛型创建一些自定义容器，并在容器中加入任何自定义内容。 在 Swift 中，我们会这样写： 123456789struct GridStack&lt;Content: View&gt;: View &#123; //这一部分是Swift的一个高级特性，称为泛型。 let rows: Int let columns: Int let content: (Int, Int) -&gt; Content var body: some View &#123; // more to come &#125;&#125; 特别注意这一let content行——它定义了一个必须能够接受两个整数并返回某种我们可以显示的内容的闭包。拥有这一行所以才叫做定制容器。 在body中我们可以这么写 1234567891011var body: some View &#123; VStack &#123; ForEach(0..&lt;rows, id: \\.self) &#123; row in HStack &#123; ForEach(0..&lt;columns, id: \\.self) &#123; column in content(row, column) &#125; &#125; &#125; &#125;&#125; 现在我们有了一个自定义容器，我们可以像这样使用它编写一个视图： 1234567struct ContentView: View &#123; var body: some View &#123; GridStack(rows: 4, columns: 4) &#123; row, col in Text(&quot;R\\(row) C\\(col)&quot;) &#125; &#125;&#125;","categories":[{"name":"技术","slug":"技术","permalink":"https://blog.five2fire.top/categories/%E6%8A%80%E6%9C%AF/"}],"tags":[{"name":"编程","slug":"编程","permalink":"https://blog.five2fire.top/tags/%E7%BC%96%E7%A8%8B/"},{"name":"Swift","slug":"Swift","permalink":"https://blog.five2fire.top/tags/Swift/"},{"name":"Hacking with Swift","slug":"Hacking-with-Swift","permalink":"https://blog.five2fire.top/tags/Hacking-with-Swift/"}]},{"title":"【Hacking With Swift】Project2_GuessTheFlag","slug":"Project2_GuessTheFlag","date":"2024-06-01T10:54:12.000Z","updated":"2025-01-02T02:17:10.814Z","comments":true,"path":"article/2890.html","permalink":"https://blog.five2fire.top/article/2890.html","excerpt":"","text":"英文原博博主是 Paul Hudson @twostraws 本文是学习Swift过程中翻译该网站的内容: https://www.hackingwithswift.com/ 猜旗子.alert用法12345@State private var showingScore = false.alert(scoreTitle, isPresented: $showingScore) &#123; Button(&quot;Continue&quot;, action: func())&#125; 渐变色12345RadialGradient(stops: [ .init(color: Color(red: 0.1, green: 0.2, blue: 0.45), location: 0.3), .init(color: Color(red: 0.76, green: 0.15, blue: 0.26), location: 0.3), ], center: .top, startRadius: 200, endRadius: 400) .ignoresSafeArea() 按钮样式（图片）使用Button后带label，可以自定义按钮样式，label里可以添加各种视图 123456789Button&#123; flagTapped(number)&#125;label: &#123; // FlagImage(text: countries[number]) Image(countries[number]) .clipShape(.capsule) .shadow(radius: 5) &#125;","categories":[{"name":"技术","slug":"技术","permalink":"https://blog.five2fire.top/categories/%E6%8A%80%E6%9C%AF/"}],"tags":[{"name":"编程","slug":"编程","permalink":"https://blog.five2fire.top/tags/%E7%BC%96%E7%A8%8B/"},{"name":"Swift","slug":"Swift","permalink":"https://blog.five2fire.top/tags/Swift/"},{"name":"Hacking with Swift","slug":"Hacking-with-Swift","permalink":"https://blog.five2fire.top/tags/Hacking-with-Swift/"}]},{"title":"【Hacking With Swift】Project1_Wesplit_problems","slug":"Project1_Wesplit_problems","date":"2024-05-28T11:56:48.000Z","updated":"2025-01-02T02:17:10.813Z","comments":true,"path":"article/11442.html","permalink":"https://blog.five2fire.top/article/11442.html","excerpt":"","text":"英文原博博主是 Paul Hudson @twostraws 本文是学习Swift过程中翻译该网站的内容: https://www.hackingwithswift.com/ 代码对比 问题费率列表使用了@State private var而不是let@state中的S没有大写计算每人费用搞了个函数，但是没调用可以直接定义var的时候用闭包函数直接计算 12345678910var totalPerPerson: Double &#123; let peopleCount = Double(peoplecount + 2) let tipSelection = Double(tiprate) let tipValue = totalspend / 100 * tipSelection let grandTotal = totalspend + tipValue let amountPerPerson = grandTotal / peopleCount return amountPerPerson&#125; 计算时候没有统一类型Double类型与Int类型混一起计算导致错误，需要Double()一下 ContentView拼写错误没有加NavigationView之后都改成NavigationStack了 NavigationTitle加错地方了我一直以为是加载NavigationStack的｛｝外面，其实应该是加在里面。 另外发现，只要是NavigationStack里面，不管加在那个｛｝后，都不影响Title的位置。 TextFild格式完全错误需要多编程习惯规范。自动修改，改成了 1TextField(&quot;Amount&quot;, text: $totalspend) 这里会报错，因为把Double类型赋给String类型了，因为这里Text应该是String，但是totalspend这个变量是Double类型。应该是 1TextField(&quot;Amount&quot;, value: $totalspend) TextFild没有加格式接上一个问题，除了加value还应该加格式 1TextField(&quot;Amount&quot;, value: $totalspend, format: .currency(code: Locale.current.currency?.identifier ?? &quot;USD&quot;)) ForEach的语法使用有大问题正确的是 123ForEach([Array, id: \\.self]) &#123;value in func(value)&#125; Picker的用法12345Picker(&quot;文字&quot;, selection: $value) &#123; ForEach(2..&lt;10) &#123; Text(&quot;\\($0) people&quot;) &#125; &#125;.pickerStyle(.navigationLink)","categories":[{"name":"技术","slug":"技术","permalink":"https://blog.five2fire.top/categories/%E6%8A%80%E6%9C%AF/"}],"tags":[{"name":"编程","slug":"编程","permalink":"https://blog.five2fire.top/tags/%E7%BC%96%E7%A8%8B/"},{"name":"Swift","slug":"Swift","permalink":"https://blog.five2fire.top/tags/Swift/"},{"name":"Hacking with Swift","slug":"Hacking-with-Swift","permalink":"https://blog.five2fire.top/tags/Hacking-with-Swift/"}]},{"title":"Preparation for Hackingwithswift","slug":"hws_Day1-14","date":"2024-05-22T02:45:36.000Z","updated":"2025-01-02T02:17:10.821Z","comments":true,"path":"article/57078.html","permalink":"https://blog.five2fire.top/article/57078.html","excerpt":"","text":"简介这部分是Swift的基础知识，学习以为后续SwiftUI做准备 变量、常量、字符串和数字创建变量： 1var greeting = &quot;Hello, playground&quot; 创建常量： 1let character = &quot;Daphne&quot; 多行字符串： 12345let movie = &quot;&quot;&quot;asdasdasdasdsaasdasd&quot;&quot;&quot; 字符串拼接： 1234567let actor = &quot;Denzel Wash&quot;let message2 = &quot;dfd&quot; + String(number111) + &quot;123213&quot;let filename = &quot;this is a&quot;var addString = actor + &quot; 123&quot; + filenamelet luggageCode = &quot;1&quot; + &quot;2&quot; + &quot;3&quot; + &quot;4&quot; + &quot;5&quot;let result = &quot;⭐️&quot;var message = actor + &quot;sakjdhkd \\(name) asd &quot; 数字的几种表示形式： 12345let payAmount = 1_000_000_111var payMount = 10000payMount = 100_00_000payMount = 100_00_______000var count = 10 123```swiftlet name = &quot;Sage&quot;print(&quot;My name is \\(name)&quot;) 数组、字典、集合创建空变量时候，声明变量的数据类型 123var vaName = Int()//Double()……var vaName = [类型名]()var vaName = [类型名]() 创建数组 12var scores2 = [String]()var bettles = [&quot;John&quot;, &quot;Paul&quot;, &quot;George&quot;, &quot;Ringo&quot;] 数组加值 12var anArray = [&quot;23sdd&quot;]anArray.append(&quot;asd&quot;) 创建字典 1234var anEmpty = [String: Int]()var employee = [&quot;name&quot;: &quot;Sage&quot;, &quot;job&quot;: &quot;Product Manager&quot;, &quot;age&quot;: &quot;13&quot;] 字典读取值，没有值可以设置默认值 1print(employee[&quot;name&quot;, default: &quot;UnKnown&quot;]) 创建集合 123let friends = Set([&quot;a&quot;, &quot;b&quot;, &quot;c&quot;, &quot;d&quot;, &quot;e&quot;, &quot;f&quot;])var friendsSet = Set&lt;String&gt;()friendsSet.insert(&quot;asd&quot;) 创建变量的不同写法（swift强制检查类型） 123456789101112131415let surname: String = &quot;Lasso&quot;var score: Int = 0var scores: Double = 0let playerName: String = &quot;Roy&quot; //Stringvar luckyNumber: Int = 13 //Intlet pi: Double = 3.141 //Doublevar isAuthenticated: Bool = true//Boolvar albums: [String] = [&quot;Red&quot;, &quot;Fearless&quot;]//Arrayvar user: [String: String] = [&quot;id&quot;: &quot;@twostraws&quot;] //Dictionaryvar books: Set&lt;String&gt; = Set([&quot;The Bluest Eye&quot;, &quot;Foundation&quot;, &quot;Girl, Woman, Other&quot;]) //Setvar team1: [String] = [String]()var team2 = [String]()var team3: [String] = [] 枚举12345678910enum Weekday &#123; case monday case tuesday case wednesday case thursday case friday&#125;var day = Weekday.mondayday = .thursday If、switch 和三元运算符条件语句 1234567891011121314var isShownAlarm = trueif isShownAlarm &#123; print(&quot;show alarm&quot;)&#125;let myName = &quot;Sage&quot;let wifeName = &quot;Haiming&quot;if myName &lt;= wifeName &#123; print(&quot;i love \\(wifeName)&quot;)&#125;else&#123; print(&quot;\\(wifeName) loves me&quot;)&#125; 条件语句多重判断 1234567891011121314151617enum Transoption &#123; case plane case heli case bike case car case tabanche&#125;var transport = Transoption.planeif transport == .plane || transport == .heli&#123; print(&quot;lets fly&quot;)&#125;else if transport == . bike &#123; print(&quot;i want a bike road&quot;)&#125;else if transport == .car &#123; print(&quot;time to stuck&quot;)&#125;else &#123; print(&quot;now go to rent a tabanche&quot;)&#125; switch语句（配合枚举或具体值） 1234567891011121314151617enum Weather &#123; case sun, rain, wind, snow, unknown&#125;let forecast = Weather.windswitch forecast &#123;case .rain : print(&quot;1&quot;)case .snow : print(&quot;2&quot;)case .wind : print(&quot;3&quot;)case .sun: print(&quot;4&quot;)case .unknown: print(&quot;5&quot;)&#125; 1234567891011121314151617181920let day = 5print(&quot;My true love gave to me…&quot;)switch day &#123;case 5: print(&quot;5 golden rings&quot;) fallthroughcase 4: print(&quot;4 calling birds&quot;) fallthroughcase 3: print(&quot;3 French hens&quot;) fallthroughcase 2: print(&quot;2 turtle doves&quot;) fallthroughdefault: print(&quot;A partridge in a pear tree&quot;)&#125; 三元运算符 12let age = 17let canVote = age &gt;= 18 ? &quot;yes&quot; : &quot;No&quot; 循环、总结和检查点 3循环 12345let platforms = [&quot;iOS&quot;, &quot;macOS&quot;, &quot;tvOS&quot;, &quot;watchOS&quot;]for os in platforms &#123; print(&quot;Swift works great on \\(os).&quot;)&#125; 循环嵌套 123456789for i in 1...12 &#123; print(&quot;The \\(i) times table:&quot;) for j in 1...12 &#123; print(&quot; \\(j) x \\(i) is \\(j * i)&quot;) &#125; print()&#125; while 循环、break和continue语句 1234567891011let id = 20var result = Int()while result != id &#123; print(&quot;\\(result)&quot;) result = Int.random(in: 1...20) if result &lt; 5 &#123; break &#125;else &#123; continue &#125;&#125; 函数、参数和返回值基本用法 12345678func showWelcome() &#123; print(&quot;Welcome to my app!&quot;) print(&quot;By default This prints out a conversion&quot;) print(&quot;chart from centimeters to inches, but you&quot;) print(&quot;can also set a custom range if you want.&quot;)&#125;showWelcome() 带参数 12345678func mulNumbers(number: Int) &#123; for i in 1...9 &#123; print(&quot;\\(i) * \\(number) = \\(number * i)&quot;) &#125;&#125;for i in 1...9 &#123; mulNumbers(number: i)&#125; 带返回值（一行的函数可以省略return） 123456func rollDice(number: Int) -&gt; Int &#123; return Int.random(in: 1...number) //&quot;return can be deleted&quot;&#125;let result = rollDice(number: 6)print(result) 双参数 12345func isSameString(string1: String, string2: String) -&gt; Bool &#123; let temp1 = string1.sorted() let temp2 = string2.sorted() return temp1 == temp2&#125; 参数附上默认值 123456isSameString3(string1: &quot;afrsdf&quot;, string2: &quot;frsfad&quot;)func calRectangle(a: Double, b: Double) -&gt; Double &#123; sqrt(a * a + b * b)&#125;calRectangle(a: 3.0, b: 4.0) 以元组的形式返回多个值 123456789func getUserName() -&gt; (firstname: String, lastname: String) &#123; (firstname: &quot;Zhang&quot;, lastname: &quot;Sage&quot;)&#125;func getUserName2() -&gt; (firstname: String, lastname: String) &#123; (&quot;Zhang&quot;, &quot;Sage&quot;)&#125;let user = getUserName2()let (a, _) = getUserName()print(&quot;Name is \\(a)&quot;) 外参 12345func printTimesTables(giveanumber number: Int = 4) &#123; for i in 1...9 &#123; print(&quot;\\(i) x \\(number) is \\(i * number)&quot;) &#125;&#125; 函数的参数中引用函数 1234567891011121314151617func doImportantWork(first: () -&gt; Void, second: () -&gt; Void, third: () -&gt; Void) &#123; print(&quot;About to start first work&quot;) first() print(&quot;About to start second work&quot;) second() print(&quot;About to start third work&quot;) third() print(&quot;Done!&quot;)&#125;doImportantWork &#123; print(&quot;This is the first work&quot;)&#125; second: &#123; print(&quot;This is the second work&quot;)&#125; third: &#123; print(&quot;This is the third work&quot;)&#125; 结构体、计算属性和属性观察器创建结构体（含有函数） 123456789101112struct Album &#123; let title: String let artist: String let year: Int func printSummary() &#123; print(&quot;\\(title) (\\(year)) by \\(artist)&quot;) &#125;&#125;let red = Album(title: &quot;Red&quot;, artist: &quot;Taylor Swift&quot;, year: 2012)//print(red.title)//red.printSummary() 修改结构体中的变量（需要用mutating关键字） 12345678910111213struct Employee &#123; let name: String var vacationRemaining: Int mutating func takeVacation(days: Int) &#123; if vacationRemaining &gt; days &#123; vacationRemaining -= days print(&quot;blablabla&quot;) &#125;else &#123; print(&quot;aaaaaabla&quot;) &#125; &#125;&#125; 动态计算属性值 12345678910111213141516171819202122struct Employee2 &#123; let name: String var vacationAllocated = 14 var vacationTaken = 0 var vacationRemaining: Int &#123; get &#123; vacationAllocated - vacationTaken &#125; set &#123; vacationAllocated = vacationTaken + newValue &#125; &#125;&#125;var archer = Employee2(name: &quot;sage&quot;)print(archer.vacationAllocated)archer.vacationTaken += 4print(archer.vacationRemaining)print(archer.vacationAllocated)archer.vacationRemaining = 5print(archer.vacationAllocated) 属性观察器（属性变化时做相关操作） 1234567891011121314struct Game &#123; var score = 0&#123; didSet &#123; print(&quot;score now is \\(score)&quot;) &#125; &#125;&#125;var game = Game()game.score += 10//print(&quot;score now is \\(game.score)&quot;)game.score -= 3//print(&quot;score now is \\(game.score)&quot;)game.score += 1//print(&quot;score now is \\(game.score)&quot;) 结构体初始化 1234567891011struct Player &#123; let name : String let number : Int init(name: String) &#123; self.name = name// self.number = number number = Int.random(in: 1...99) &#125;&#125;let player1 = Player(name: &quot;Sage&quot;) 使用访问控制限制对结构体内部数据的访问 123456789101112131415161718192021struct BankAccount &#123; private var funds = 0 // var funds = 0 mutating func deposit(amout: Int) &#123; funds += amout &#125; mutating func withdraw(amout: Int) -&gt; Bool&#123; if funds &gt;= amout &#123; funds -= amout return true &#125;else &#123; return false &#125; &#125;&#125;var account = BankAccount()account.deposit(amout: 100)let success = account.withdraw(amout: 200) 静态属性和方法 1234567891011121314151617181920212223242526struct School &#123; static var studentCount = 0 static func add(student: String) &#123; print(&quot;\\(student) joined the school&quot;) studentCount += 1 &#125;&#125;School.add(student: &quot;Sage&quot;)struct AppDate &#123; static let version = &quot;1.2.3&quot; static let saveFilename = &quot;Setting.json&quot; static let homeURL = &quot;fivetofire.com&quot;&#125;print(AppDate.version)struct Userinfo &#123; let username: String let password: String static let example = Userinfo(username: &quot;cfederighi&quot;, password: &quot;hairforceone&quot;)&#125;print(Userinfo.example) //创建SwiftUI的预览示例 类、继承和检查点 7创建类（和结构一样） 12345678910class Game &#123; var score = 0 &#123; didSet &#123; print(&quot;Score is now \\(score)&quot;) &#125; &#125;&#125;var newGame = Game()newGame.score += 10 类的继承 12345678910111213141516171819202122232425262728293031//类的继承class Employee &#123; let hours: Int func printSummary() &#123; print(&quot;i work \\(hours) hours a day.&quot;) &#125; init(hours: Int) &#123; self.hours = hours &#125;&#125;class Developer: Employee &#123; func work() &#123; print(&quot;i&#x27;m writing code for \\(hours) hours.&quot;) &#125; override func printSummary() &#123; print(&quot;I&#x27;m a developer who will sometimes work \\(hours) hours a day, but other times spend hours arguing about whether code should be indented using tabs or spaces.&quot;) &#125;&#125;class Manager: Employee &#123; func work() &#123; print(&quot;I&#x27;m going to meetings for \\(hours) hours. &quot;) &#125;&#125;let robert = Developer(hours: 8)let joseph = Manager(hours: 10)robert.work()joseph.work() 为类添加初始化程序 1234567class Vehicle &#123; let isElectric: Bool init(isElectric: Bool) &#123; self.isElectric = isElectric &#125;&#125; 子类会继承父类的属性 12345678910111213141516171819202122class Vehicle &#123; let isElectric: Bool init(isElectric: Bool) &#123; self.isElectric = isElectric &#125;&#125;class Car: Vehicle &#123; let isConvertible : Bool init(isElectric: Bool, isConvertible: Bool) &#123; self.isConvertible = isConvertible super.init(isElectric: isElectric) &#125;&#125;class Car2: Vehicle &#123; func work() &#123; print(&quot;I&#x27;m going to meetings for hours. &quot;) &#125;&#125;let ccc = Car2(isElectric: true)let teslaX = Car(isElectric: true, isConvertible: false) 复制类 1234567891011121314151617181920struct User &#123;class User &#123; var username = &quot;Anonymous&quot; func copy() -&gt; User &#123; let user = User() user.username = username return user &#125;&#125;var user1 = User()var user2 = user1user2.username = &quot;Sage&quot;print(user1.username)print(user2.username)var user3 = user2.copy()user3.username = &quot;Haiming&quot;print(user3.username)print(user2.username) 反初始化器（这个里面有个作用域的概念很关键） 1234567891011121314151617181920212223242526class User2 &#123; let id: Int init(id: Int) &#123; self.id = id &#125; deinit &#123; print(&quot;im dead !&quot;) &#125;&#125;for i in 1...3 &#123; let user = User2(id: i)// print(&quot;User \\(user.id): I&#x27;m in control!&quot;)&#125;var users = [User2]() for i in 1...3 &#123; let user = User2(id: i)//循环中的作用域，只在一次迭代中生效 print(&quot;User \\(user.id): I&#x27;m in control!&quot;) users.append(user)&#125;print(&quot;Loop is finished!&quot;)users.removeAll()print(&quot;Array is clear!&quot;) 协议、扩展和检查点 8协议的定义，符合该协议的结构都必须包含协议中定义好的变量或函数 1234567protocol Vehicle &#123; func estimateTime(for distance: Int) -&gt; Int func travel(distance: Int) var name: String &#123; get &#125; var currentPassengers: Int &#123; get set &#125;&#125; 扩展的定义（注意，mutating的关键字表示，有变量被修改了） 1234567891011121314151617var quote = &quot; The truth is rarely pure and never simple &quot;let trimmed = quote.trimmingCharacters(in: .whitespacesAndNewlines)extension String &#123; func trimmed() -&gt; String &#123; self.trimmingCharacters(in: .whitespacesAndNewlines) &#125; mutating func trim() &#123; self = self.trimmed() &#125; var lines: [String] &#123; self.components(separatedBy: .newlines) &#125;&#125;quote.trim()let lyrics = &quot;&quot;&quot; 可以使用拓展给结构初始化 12345678910111213141516struct Book &#123; let title: String let pageCount: Int let readingHours: Int&#125;extension Book &#123; init(title: String, pageCount: Int) &#123; self.title = title self.pageCount = pageCount self.readingHours = pageCount / 50 &#125;&#125;let lotr = Book(title: &quot;Lord of the Rings&quot;, pageCount: 1178, readingHours: 1)let asdas = Book(title: &quot;sdfsdf&quot;, pageCount: 2000)print(lotr.readingHours)print(asdas.readingHours) 给自定义协议做拓展 1234567891011121314151617//自定义协议拓展protocol Person &#123; var name : String &#123; get &#125; func sayHello()&#125;extension Person &#123; func sayHello() &#123; print(&quot;hi, im \\(name)&quot;) &#125;&#125;struct Employee: Person &#123; let name : String&#125;let Sage = Employee(name: &quot;Sage&quot;)Sage.sayHello() 可选、零合并和检查点 9可选值是什么，可选值就是nil，表示不存在，nil不是空值 123456let opposites = [ &quot;Mario&quot;: &quot;Wario&quot;, &quot;Luigi&quot;: &quot;Waluigi&quot;]let peachOpposite : String? = opposites[&quot;Peach&quot;] 可选值的解包 123456789101112131415161718192021222324252627var number: Int? = nilprint(square(number: number ?? 4))// if let 解包if let number = number&#123; print(square(number: number))&#125;// guard解包func printSquare(of number: Int?) &#123; guard let number = number else &#123; print(&quot;Missing input&quot;) return &#125; print(&quot;\\(number) x \\(number) is \\(number * number)&quot;)&#125;printSquare(of: Int(&quot;123&quot;))// ??解包，其实上面已经展示了let captains = [ &quot;Enterprise&quot;: &quot;Picard&quot;, &quot;Voyager&quot;: &quot;Janeway&quot;, &quot;Defiant&quot;: &quot;Sisko&quot;]let new = captains[&quot;Serenity&quot;] ?? &quot;N/A&quot; //相当于给一个默认值 使用可选链处理多个可选值 1234567891011121314151617181920struct Book &#123; let title: String let author: String?&#125;var book: Book? = nillet author = book?.author?.first?.uppercased() ?? &quot;A&quot;print(author)enum UserError: Error &#123; case badID, networkFailed&#125;func getUser(id: Int) throws -&gt; String &#123; throw UserError.networkFailed&#125;let user = (try? getUser(id: 23)) ?? &quot;Anonymous&quot;print(user) Checkpoint 1您的目标是编写一个 Swift 游乐场： 创建一个保持任意摄氏度温度的常数。将其乘以 9、除以 5，然后加 32，转换为华氏度。为用户打印结果，显示摄氏度和华氏度值。 123let temproche = 27.4let huashidu = temproche * 9 / 5.0 + 32print(&quot;摄氏度\\(temproche)℃ 是华氏度的\\(huashidu)℉&quot;) Checkpoint 512345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152// Zhang&#x27;s codelet luckyNumbers = [7, 4, 38, 21, 16, 15, 12, 33, 31, 49]func fillterOdd(array: [Int]) -&gt; [Int] &#123; var tempArray = [Int]() for number in array &#123; if !number.isMultiple(of: 2) &#123; tempArray.append(number) &#125; &#125; return tempArray&#125;func sortArray(array: [Int]) -&gt; [Int] &#123; return array.sorted &#123; $0 &lt; $1 &#125;&#125;func intToString(array: [Int]) -&gt; [String] &#123; let tempArray = array var resultArray = [String]() for item in tempArray &#123; var appendString = String(item) + &quot;is a lucky number&quot; resultArray.append(appendString) &#125; return resultArray&#125;func resultFunction(array: [Int], function1: ([Int]) -&gt; [Int], function2: ([Int]) -&gt; [Int], function3: ([Int]) -&gt; [String]) -&gt; [String]&#123;// print(&quot;guolv oushu&quot;) let t1 = function1(array)// print(&quot;paixu&quot;) let t2 = function2(t1)// print(&quot;yingshe&quot;) let reslut = function3(t2) return reslut&#125;let finalResult = resultFunction(array: luckyNumbers, function1: fillterOdd, function2: sortArray, function3: intToString)var a = intToString(array: sortArray(array: fillterOdd(array: luckyNumbers)))// other&#x27;s codelet filterNumber = luckyNumbers.filter &#123; !($0.isMultiple(of: 2)) &#125;.sorted().map &#123; String($0) &#125;for i in filterNumber &#123; print(&quot;\\(i) is a lucky number&quot;)&#125; checkpoint 6创建一个结构来存储有关汽车的信息，包括其型号、座位数和当前档位，然后添加一个升档或降档的方法。考虑一下变量和访问控制：哪些数据应该是变量而不是常量，哪些数据应该公开？换档方法是否应该以某种方式验证其输入？ 12345678910111213141516struct Car &#123; private var dangwei = 0 let chexing = &quot;bentian&quot; let zuoweishu = 5 mutating func changeDangwei() &#123; dangwei += 1 print(&quot;dangwei now is \\(dangwei)&quot;) &#125;&#125;var car1 = Car()car1.changeDangwei()car1.changeDangwei()//print(car1.dangwei)print(car1.zuoweishu) 检查点712345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758class Animal &#123; var legs = 4 func talk() &#123; print(&quot;Animal talk&quot;) &#125;&#125;class Dog: Animal &#123; override func talk() &#123; print(&quot;dog bark&quot;) &#125;&#125;class Corgi: Dog &#123; override func talk() &#123; print(&quot;Corgi bark&quot;) &#125;&#125;class Poodle: Dog &#123; override func talk() &#123; print(&quot;Poodle bark&quot;) &#125;&#125;class Cat: Animal &#123; var isTame : Bool override func talk() &#123; print(&quot;Cat miaowu&quot;) &#125; init(isTame: Bool) &#123; self.isTame = isTame &#125;&#125;class Persian: Cat &#123; override func talk() &#123; print(&quot;Persian miawo&quot;) &#125;&#125;class Lion: Cat &#123; override func talk() &#123; print(&quot;Lion miawo&quot;) &#125;&#125;let a = Animal()let b = Corgi()let c = Poodle()let d = Persian(isTame: true)let e = Lion(isTame: false)a.talk()b.talk()c.talk()d.talk()e.talk()print(a.legs, b.legs, c.legs, d.legs, e.legs) 检查点812345678910111213141516171819202122232425262728293031323334353637383940414243444546protocol Struction &#123; var roomAmout: Int &#123; get &#125; var structValue: Int &#123; get &#125; var zhongjieName: String &#123;get set &#125; func printStateInfo() -&gt; Void&#125;struct House: Struction &#123; var roomAmout = 4 var structValue: Int var zhongjieName: String func printStateInfo() &#123; print(&quot;This is a house&quot;) &#125; init(roomAmout: Int, structValue: Int, zhongjieName: String) &#123; self.roomAmout = roomAmout self.structValue = structValue self.zhongjieName = zhongjieName &#125;&#125;struct Office: Struction &#123; var roomAmout = 10 var structValue: Int var zhongjieName: String func printStateInfo() &#123; print(&quot;This is an office&quot;) &#125; init(roomAmout: Int, structValue: Int, zhongjieName: String) &#123; self.roomAmout = roomAmout self.structValue = structValue self.zhongjieName = zhongjieName &#125;&#125;extension Struction &#123; func soldOut() &#123; print(&quot;Have been sold out&quot;) &#125;&#125;var ahouse = House(roomAmout: 3, structValue: 100_000_000, zhongjieName: &quot;Liheng&quot;)let anofice = Office(roomAmout: 20, structValue: 234000321, zhongjieName: &quot;Anonymous&quot;)ahouse.printStateInfo()anofice.printStateInfo()ahouse.soldOut()//print(ahouse.zhongjieName) 检查点 912func randomInt(numbers : [Int]?) -&gt; Int &#123; numbers?.randomElement() ?? Int.random(in: 1...100) &#125;print(randomInt(numbers: [2, 3, 5, 3, 2, 4]))","categories":[{"name":"技术","slug":"技术","permalink":"https://blog.five2fire.top/categories/%E6%8A%80%E6%9C%AF/"}],"tags":[{"name":"编程","slug":"编程","permalink":"https://blog.five2fire.top/tags/%E7%BC%96%E7%A8%8B/"},{"name":"Swift","slug":"Swift","permalink":"https://blog.five2fire.top/tags/Swift/"},{"name":"Hacking with Swift","slug":"Hacking-with-Swift","permalink":"https://blog.five2fire.top/tags/Hacking-with-Swift/"}]},{"title":"《积极心理课》彭凯平","slug":"彭凯平《积极心理学》","date":"2024-03-07T12:34:15.000Z","updated":"2025-01-02T02:17:10.825Z","comments":true,"path":"article/47367.html","permalink":"https://blog.five2fire.top/article/47367.html","excerpt":"","text":"清华大学积极心理学课程笔记人类的本能是消极的？人类进化本能让人更容易关注消极情绪积极心理学是一种理性的选择，而不是感性的享受，不是鸡汤。积极是动词，需要付出行动。积极心理学是中国传统文化的智慧。 积极心理学与幸福的关系幸福学科是个跨学科科学积极心理学教授如何获得幸福的状态，帮助人去创造幸福感受幸福等。 ACE的能力培养：审美感，创造力，同理心。 积极心理学发源积极心理学的四位奠基者马丁塞利格曼、克里斯托弗彼得森、爱德迪纳、米哈里契克森米哈伊（Flow） 流派：行为主义心理学、精神分析心理学、人本主义心理学、弗洛伊德（原生家庭等因素） 马斯洛：需求的六个层次（1-4是基础需求） 生理需求 安全需求 爱和归属 尊重 文化 自我实现 幸福生活的四种积极体验 活出爱的感受（不是男女之间的爱，那是性 活出愉悦的感受 活出有用的感受（自我效能from班杜拉 活出意义感独乐乐不如众乐乐（关系的重要性向上正向的积极循环：向积极的方向努力能够获得积极的结果。 ACE幸福模型积极心理学的4个核心观点：行动、利他、关系、心流Flow积极心理学——21世纪的“阳明心学” 人人可为圣贤 致良知 知行合一积极天性假说人类特有的四大积极天性：同理心、自控心、道德感、理智。 Aesthetic审美感 感知美与欣赏之心 沉浸与关注能力 成就与成长之心Creative创造力 认知与思维 自我效能感 好奇心与创新Empathic同理心 沟通与合作 感恩与利他 慧眼与禅心 如何摆脱固定型思维成长型思维，相信一切都是可以改变的。如何培养成长型思维体会发现记录成功的经历、寻找激励的榜样、珍惜激励你的同伴 如何缓解职场焦虑培养长期思维、形成闭环思维为什么你害怕做决定？最后悔的事是那些可以做而没有做的事情——想好的事情就去做认知失调（做的事情发现没有想象中的好）做出选择本身就是一个积极的行动 人生没有标准答案 1.排出优先项2.培养说不的能力3.认识到没有最好的结果 多做虚拟向下比较和少做虚拟向上比较。和自己混得不好的时候比； 重新定义成功：拥有身心的自由、具备成长型思维、实现人生意义 内卷环境如何缓解焦虑：提升自己独特的优势、丰富社交网络、成为复合型人才 创造力的源头好奇心的来源和本质：兴趣思考关注和沉迷 培养好奇心的方法：利用信息缺口激发好奇心积极尝试新鲜事物容忍失败的经验在愉悦状态下探索世界 创造力的要素6P：人、产品、过程、地域环境、说服力、潜能 大脑的两套思维系统：快与慢不可不知的认知误区 想得太快（思维敏捷） 想得太多 从众心理 一根筋（信念执着） 为什么会有这几种误区 快思维——直觉：基于经验、感觉、阅历等做判断 慢思维——理性：基于逻辑、思维、批判、证据与自省等做判断 常见的理性思维： 审辩思维（与批判思维有些不同） 辩证性思维：塞翁失马，否极泰来 直觉思维：黄金直觉，需要积累大量的经验，相信内心判断，不断验证每次判断的结果 如何处理感性与理性的冲突提升理性的方法交不三不四的友读云天雾罩的书上莫名其妙的课 感性与理性的冲突感性与理性是相辅相成的，不应强行分开 人类的进化，选择的是先有感性再有理性 理性让我们选择积极方向，感性让我们收获幸福体验 超越自我认识的偏差自我认识的误区 达克效应 自我投射（聚光灯效应） 属于你的6大美德和24项优势 人类三大优势： 身体优势 智能优势 道德优势 找到自我优势的方法 进行积极心理学测试 寻找自己热衷的事 评估自己擅长的事 提高自我效能感，实现自我超越自我效能：源自“我能行”的力量不同的人对自己能力的评价是不一样的。 自我效能感是对自己能力的认可 提升自我效能感（成功是成功之母，多一些正反馈。成功让自己更有信心。） 活出成功的样子，给自己成功的印象 和成功人士相处（近朱者赤） 多去想象自己可能的成功 用心记录自己的成绩 增强执行力 自尊心：一种适度的自我评价自尊心是对自己的评价，自尊心高有一种积极的保护作用 恐惧管理理论， 低自尊的伤害——自卑，对风险排斥，甚至自我伤害。 低自尊的补偿：缺什么就炫耀什么 坦然接受自己 自我超越：学会掌控自我随心所欲不逾矩 自控力是人类文明的基础。（《棉花糖实验》，延迟满足） 培养自控力的方法 主动尝试自我挑战 保证身心健康（早睡早起） 充分利用自我奖惩机制 培养良好的行为习惯（21天养成一个习惯） 【同理心】沟通的三大原则同理心定义： 同理心分为两种：认知同理心（知道别人的想法和倾向）和情绪同理心（能够理解别人的感受） 沟通、信任、合作。 沟通是一种体验、同理心有助于沟通。 沟通的社会原则 数量对等 质量对等 相关联原则（相关交换，不要鸡同鸭讲） 亲密关系中的沟通方法避免以下四种说话方式 批判（互相指责互相苛刻） 鄙视（瞧不起对方） 辩解（不承担责任，永远觉得是对方的问题） 冷战（不说话，不沟通，不交流） 促进夫妻感情的方法 积极回应对方的沟通需求 古特曼比例（5：1，5句好话+1句批评建议，打一下，揉五下） 非暴力沟通前面说的四种说话方式都是暴力沟通 非暴力沟通方式： 就事论事（谈事实，不要谈观点&#x2F;看法） 多谈感情（感受），少谈认知（观点） 多谈“我”，少谈“你” 谈具体的行动 非语言沟通的四种方式 姿态与手势 适应性动作（顺应自己内心的感受，×男儿有泪不轻弹） 面部表情 控制性的沟通（比如一言不发 【信任】囚徒困境中的信任启示信任是一种社会交流成本，信任是一种积极心理资源， 信任他人，信任自己是一个产生积极回报，带来幸福的生活智慧和技巧。 信任与风险相关、信任与利益相连、信任与信息不对称相关 如何提高人与人之间的信任：充分透明的沟通 为什么人离不开合作沟通是合作的基础，信任是合作的保障。 合作是天性 影响合作的因素： 时间压力（紧张压力大时倾向于合作） 情绪状态（轻松愉悦时倾向于合作） 奖励机制（使用奖励去促进合作，影响团队绩效） 价值观念（集体主义还是个人主义） 社会关系的性质（平等的关系中合作更多） 【情商】最高级的情商——感恩和利他感恩：人类美德之巅感恩是对我们所拥有的事物的欣赏 感恩之心不是愧疚之心、交换之心，感恩是幸福的。报恩有可能是不开心的（父母让你生小孩那是让你报恩，是一种道德绑架） 感恩的积极效用： 生活更幸福 行动更积极 工作更高效 身心更健康 培养感恩之心的方法： 回忆 记录 行动 利他：助人确实为乐无我：超越个人功利的考量 助人为乐，帮助别人不一定非得要牺牲 为什么要助人为乐 社会交换理论，帮助别人可能也会获得回报（互惠互利） 人天生的恻隐之心（同理心） 社会规范奖励 帮助别人也是帮助自己，助人可以为乐","categories":[{"name":"学习","slug":"学习","permalink":"https://blog.five2fire.top/categories/%E5%AD%A6%E4%B9%A0/"}],"tags":[{"name":"心理学","slug":"心理学","permalink":"https://blog.five2fire.top/tags/%E5%BF%83%E7%90%86%E5%AD%A6/"}]},{"title":"给产品经理讲技术笔记","slug":"给产品经理讲技术笔记","date":"2024-03-07T09:32:14.000Z","updated":"2025-01-02T02:17:10.826Z","comments":true,"path":"article/14194.html","permalink":"https://blog.five2fire.top/article/14194.html","excerpt":"","text":"Web前端技术AJAX这种只让部分页面刷新的技术叫作AJAX（汉语读音为“阿贾克斯”或“额寨克思”），它是“Asynchronous JavaScript And XML”的首字母缩写，翻译为“异步JavaScript和XML”。 AJAX可以发起网络请求，无需刷新即可动态操作网页。 总结：AJAX是一项用于异步拉取数据并展示在当前页面的技术，这对需要延迟加载数据和触发式加载数据的页面有很大益处。绝大多数网页为了加速响应，都会用到这项技术。 DOMHTML文档中的层次分明的结构组织，就是DOM，是网页的框架。 操纵DOM本身是一件效率非常低的事情。一个网页往往很复杂，浏览器构造出来的DOM树往往很庞大。 虚拟DOM可以从整体上大大提高了JavaScript操纵DOM树的效率。 静态网页与动态网页静态网页无须经过后台程序的处理。动态网页要经过后台程序的处理，我们常见的ASP、JSP、PHP都是后台处理程序。 总结：（1）静态网页和动态网页都是网页。（2）静态网页不需要后台程序干预处理，直接由服务器返回。实现为静态网页后，一般不需要维护，因为数据不需要更新。（3）动态网页一般需要由程序来处理（ASP、JSP、PHP、Python、Ruby等），并由数据库提供数据支撑。（4）不要以URL的形式来判断一个网页是静态的还是动态的，而应该看页面的属性（产品经理最好具备一些调试技巧和经验）。（5）动态网页更灵活。 URL结构一个标准的 URL 地址由protocol、hostname、port、path、parameters、query 几部分组成。 再长的URL也是由这几个关键部分组成的，只要读者能分割出上面介绍的几个主要部件，就能看出各部分的意义。 表单表单在很早的 HTML 版本中就已经存在，它是用户输入和网页之间数据交互的一个界面，在HTML中用&lt;form&gt;标签标记。 1234567&lt;html lang=&quot;en&quot;&gt;&lt;form name=&quot;input&quot;action=&quot;http://www.***.com/index.html&quot;method=&quot;GET&quot;&gt;&lt;input type=&quot;text&quot; name=&quot;user&quot;/&gt;&lt;input type=&quot;submit&quot; value=&quot;Submit&quot;/&gt;&lt;/form&gt;&lt;/html&gt; 效果如下： 总结：表单是用户和服务器数据交互的用户界面，一切向服务器提交的数据都是由其中的几个简单的标签组成的。 H5缓存技术Application Cache技术通过缓存资源到本地，避免了每次打开网页都会从服务器拉取大量数据的过程，取而代之的只是一个轻量级的更新检查请求，这样，开发者的服务器带宽就被大大地释放出来 在Chrome中使用F12开启开发者模式DevTools： 如果读者在浏览某些网站时按“F12”键启动开发者工具，会在Console这个Tab下收到网站开发者的留言，不过这些留言大多是一些招聘信息，因为这样做针对性很强，这些信息几乎只有开发工程师才能看到。 恐龙小游戏： 当没有网络时，浏览器也就没有什么作用了，用户会很无聊，于是Chrome 免费送了一款小游戏，给用户消磨时间。触发方法：先断开网络，然后在Chrome里随便打开一个网址，读者会看到如图1-3所示的小恐龙，再按“空格”键，游戏就开始了。如果是在手机版浏览器上，就直接单击小恐龙开始游戏。 变色的标题栏： 在Android版的Chrome浏览器里访问某些网站时，读者会发现标题栏和状态栏的颜色变成了该网站的主题色。这其实是Chrome的一个特性，只要开发者在网页的header里设置了themecolor的属性，Android版的Chrome就会选择当前网页的theme-color表示的颜色作为标题栏和状态栏的背景色。 指定搜索引擎： 如果读者想在淘宝搜索某件商品，或者想在知乎搜索某个问题，可以在Chrome的地址栏里直接输入淘宝或者知乎的域名，然后按“Tab”键，Chrome的地址栏就显示“用××搜索”，我们紧接着输入想搜索的内容，按回车键，结果就直接显示出来了，如图1-4所示。 计算器： 临时要做一些简单的计算，又不想打开计算机里的计算器程序，则可以直接在 Chrome 的地址栏里进行计算。例如，在地址栏输入“1+1&#x3D;×”，地址栏下方就会显示计算结果。 执行 JavaScript 语句： 同样在地址栏里，使用“javascript:××”就能执行相应的JavaScript语句，读者可以尝试在地址栏里输入如下代码：javascript:alert（”hello guoguo”）;注意要手动输入，若采用复制&#x2F;粘贴的方式，Chrome会默认清理“javascript:”这个前缀，输入后就会看到一个显示“hello guoguo”的对话框。 将网页存为PDF文件： 有时我们需要将一个页面保存下来，除了用Evernote等工具，还可以在Chrome里直接将该网页存成PDF，只需按“Ctrl+P”组合键唤起“打印网页”对话框，然后在目标打印机的选项中选择“另存为PDF”选项。 UA:UserAgent“UA”是“UserAgent”（用户代理）的简写，一般用来区分不同的浏览器。 Chrome的UA Mozilla&#x2F;5.0（Windows; U; Windows NT 5.1; en-US）AppleWebKit&#x2F;525.13（KHTML,like Gecko）Chrome&#x2F;0.2.149.29Safari&#x2F;525.13 URL编码中文会被编码，如“%e5%82%bb%e5%91%80”，这就是URL中的中文被编码后的结果。 简单理解HTML、CSS和JavaScriptHTML、CSS、JavaScript共同构建了读者看到的所有网页展示和交互。 HTML（HyperText Markup Language）是超文本标记语言 。 CSS（Cascading Style Sheets）是级联样式表 ，外观。 JavaScript 是一种脚本语言 ，主要用于前端页面的DOM处理。 当前互联网上的任何一个网页都是由它们三个构建起来的，虽然简单，但不可不知。 跨域与同源同源就是同域，“跨域”也可以说成“跨源”。不同源，就不能修改另一个页面，更不能获取与另一个页面相关的内容。只有同源的页面才可以相互访问。 浏览器提供了原生的同源机制来保证不同域下的网站互相隔离，正是这种机制的存在，保证了Web生态下各个网站不乱套。 什么是同源呢？只要两个页面的协议、主机名、端口一样，就是同源的，否则就是非同源的。同源要同时满足3个特征，例如http://www.a.com/index.html 和 http://www.b.com/index.html 不同源，因为主机名不同，一个为a.com，另一个为b.com。http://www.a.com/index.html 和 https://www.a.com/index.html 不同源，因为协议不同，一个为HTTP，另一个为HTTPS。https://www.a.com:80/index.html 和 https://www.a.com:81/index.html 不同源，因为端口号不同，一个为80，另一个为81。 合理的跨域沟通的方法有以下几种：（1）JSONP（2）iframe document.domain（3）iframe location.hash（4）HTML 5 PostMessage Cookie和广告联盟Cookie 是浏览器每次向网站服务器请求数据时携带的一些额外信息，这些信息一般非常少（最多4KB），主要就是为了解决服务器“记性不好”的问题。 HTTP Header是什么HTTP 协议的 Header 是一块数据区域，分为请求头和响应头两种类型，客户端向服务区发送请求时带的是请求头，而服务器响应客户端数据时带的是响应头。请求头里主要是客户端的一些基础信息，UA（user-agent）就是其中的一部分，而响应头里是响应数据的一些信息，以及服务器要求客户端如何处理这些响应数据的指令。请求头里面的关键信息如下：（1）accept，表示当前浏览器可以接受的文件类型，假设这里有image&#x2F;webp，表示当前浏览器可以支持webp格式的图片，那么当服务器给当前浏览器下发webp的图片时，可以更省流量。（2）accept-encoding，表示当前浏览器可以接受的数据编码，如果服务器吐出的数据不是浏览器可接受的编码，就会产生乱码。（3）accept-language，表示当前使用的浏览语言。（4）Cookie，很多和用户相关的信息都存在 Cookie 里，用户在向服务器发送请求数据时会带上。例如，用户在一个网站上登录了一次之后，下次访问时就不用再登录了，就是因为登录成功的 token 放在了Cookie 中，而且随着每次请求发送给服务器，服务器就知道当前用户已登录。（5）user-agent，表示浏览器的版本信息。当服务器收到浏览器的这个请求后，会经过一系列处理，返回一个数据包给浏览器，而响应头里就会描述这个数据包的基本信息。 响应头里的关键信息有：（1）content-encoding，表示返回内容的压缩编码类型，如“Content-Encoding:gzip”表示这次回包是以gzip格式压缩编码的，这种压缩格式可以减少流量的消耗。（2）content-length，表示这次回包的数据大小，如果数据大小不匹配，要当作异常处理。（3）content-type，表示数据的格式，它是一个 HTML页面，同时页面的编码格式是 UTF-8，按照这些信息，可以正常地解析出内容。content-type 为不同的值时，浏览器会做不同的操作，如果content-type是application&#x2F;octet-stream，表示数据是一个二进制流，此时浏览器会走下载文件的逻辑，而不是打开一个页面。（4）set-cookie，服务器通知浏览器设置一个Cookie；通过HTTP的Header，可以识别出用户的一些详细信息，方便做更定制化的需求，如果读者想探索自己发出的请求中头里面有些什么，可以这样做：打开Chrome浏览器并按“F12”键，唤起Chrome开发者工具，选择network这个Tab，浏览器发出的每个请求的详情都会在这里显示。 HTTP中的GET和POST通常认为GET 就是拉取服务器的数据，POST 就是向服务器提交数据，但实际上两者并没有这种明确的界限 WebSocket将更新逻辑从HTTP迁移到WebSocket是很简单的，只需要实现WebSocket的几个接口，就能在支持的浏览器上使用WebSocket的双工特性。如果读者想做一个实时性很强的网页，或者想向网页及时推送一些信息，尽量选择WebSocket。 直出总结一下：浏览器直接输出渲染好数据的HTML页面，简称“直出”。直出没什么神秘的，只不过需要Node.js的支持，服务器和前端都用JavaScript语言编写，相当于在服务器上也运行一个浏览器，它把渲染好的内容直接输出给客户端的浏览器。 WEB应用要理解单页Web应用，需要和非单页Web应用，也就是多页Web应用做对比。 这种包含多个页面，通过链接切换的网站，就是多页Web应用。 单页的 Web 应用会在用户单击链接之后直接和服务器联系（不会告诉浏览器页面切换了），拉取数据。虽然看起来与多页Web应用没什么区别，但技术上的区别很大 单页Web应用，更像是一个原生的Android或者iOS应用，只不过现在浏览器成了一个操作系统。 单页 Web 应用如何能在一个页面里把多个页面才能做的事情做完呢？这就需要以下两个必备技术： （1）AJAX。作者之前介绍过，有了它，前端的 JavaScript 代码就可以拉取服务器上的数据了。（2）页面历史栈。前面介绍过，单页 Web 应用只有一个页面，也就是只有一个URL，那么用户想前进或者后退该怎么办呢？这就依赖单页Web页面自己的处理了。 锚点与网页内跳转锚点定义位置，用#号完成对锚点位置的跳转，无论是在输入的URL中还是网页中，各种位置跳转的需求都可以这样简单完成。这个锚点的跳转仅仅是浏览器的操作行为，并不会发起任何网络请求和服务器交互。 适配手机屏幕总结一下，viewport是一块区域，手机上的浏览器为了适配桌面上的网页，把它设置成宽980像素，但是这样的网页要正确地显示出来必须经过缩放或者用滚动条，所以开发者在写前端网页的时候，会用一个width&#x3D;device-width的viewport，这样CSS里看到的屏幕总宽度在320像素左右，1像素代表的物理像素数会自动根据屏幕密度进行换算。这样就完成了设计师的目标：标注80像素的按钮，在不同的手机上，看起来一样大。","categories":[{"name":"产品","slug":"产品","permalink":"https://blog.five2fire.top/categories/%E4%BA%A7%E5%93%81/"}],"tags":[{"name":"产品经验","slug":"产品经验","permalink":"https://blog.five2fire.top/tags/%E4%BA%A7%E5%93%81%E7%BB%8F%E9%AA%8C/"}]},{"title":"如何执行PDCA循环","slug":"如何执行PDCA循环","date":"2024-03-06T01:24:37.000Z","updated":"2025-01-02T02:17:10.824Z","comments":true,"path":"article/46973.html","permalink":"https://blog.five2fire.top/article/46973.html","excerpt":"","text":"什么是PDCAPDCA，是质量管理的四个阶段：Plan—Do—Check—Act。 1. P (Plan) 计划，包括方针和目标的确定，以及活动规划的制定。 2. D (Do) 执行，根据已知的信息，设计具体的方法、方案和计划布局；再根据设计和布局，进行具体运作，实现计划中的内容。 3. C (Check) 检查，总结执行计划的结果，分清哪些对了，哪些错了，明确效果，找出问题。 4. A (Act）处理，对总结检查的结果进行处理，对成功的经验加以肯定，并予以标准化；对于失败的教训也要总结，引起重视。 以上四个过程不是运行一次就结束，而是周而复始的进行，一个循环完了，解决一些问题，未解决的问题进入下一个循环，这样阶梯式上升的。 PDCA循环的应用非常广泛，它几乎可以运用于我们所做的每件事情中。 用于个人：PDCA循环可用于自我管理，比如工作日常、月度计划、习惯养成等等。 用于企业：PDCA循环可以发现、改善各种管理问题，可以应用于各个领域，大到企业的策略管理、环境污染管理，小到部门的项目管理、教育训练等等。 01 工作日常之PDCA（以新媒体运营为例）P：每天进办公室后的第一件事是给今天的工作做个计划（P）： 当天有哪几项任务需要做？最好按重要紧急程度做个排序 哪些任务需要和哪些部门&#x2F;同事进行协作？ 预计每项任务的耗时多少？ 罗列潜在问题并给出备选方案 D：根据制定的计划实施（D）当天的工作事项 撰写并发布2篇知乎问答 撰写并编排发布1篇微信公众号 与设计师沟通公众号封面图需求 协助同事完成评审任务 C：检查（C）在处理本项工作的过程中发现的问题、潜在风险、工作中应注意的情况 从后台查看公众号文章、知乎问答的数据，评估分析内容好在哪里，不足点又有哪些？ 今天与设计师沟通需求为何推进不下去，最大的阻碍是什么？ A：总结当天的工作得失 记录当天工作亮点、工作心得、每天心得感受 提出改进方法：当天工作教训、建议，要对所做的不满意的事情，提出改善的方法，潜在风险及其规避措施，完成下一步的几点行动措施。 02 月度计划之PDCAP：学习思维导图绘制，主要目标是掌握思维导图绘制技巧。比如在做读书笔记，能够按照自己的思路清晰绘制全书思维导图，提升自己视觉化表达的能力。 使用工具：MindMaster。 D：按照计划学习思维导图的绘制 学习MindMaster视频教程（64节），通过朋友圈打卡记录达成进度； 绘制30份思维导图并发布在MindMaster思维导图社区。 时间分配：每天至少学习3小节视频教程，并绘制1份思维导图。 C：记录目标计划和实际结果之间的差距。在每个差距下面，做“鱼骨式追问”↓↓↓ 为什么初始状态改变了？ 为什么初始状态认知不准确？（影响因素） 为什么行为没有执行？（原因） 为什么目标未达成?（原因） 每一层追问必须填写一个答案和一个解决方案。就是如果你做了什么事儿，这事儿就不会发生了。为什么不行？怎么就又行了？怎么才能行？也许未来这么做就可能行？ A：计划本身可能也存在问题，所以我们要给出自己时间修正问题 追问是为了得出行为的解决方案和计划的修正方案。如果不能用一句话描述的话，就要拆分子目标，从子目标倒推。 当所有的答案都会出现否定，出现资源不足，都不能实现的时候，就要试着写出试行的实现方法。在下一轮的行为中去试，把所有的解决方案都写下后，重点标记，纳入下一次计划的执行行为当中，进入下一个PDCA循环。","categories":[{"name":"产品","slug":"产品","permalink":"https://blog.five2fire.top/categories/%E4%BA%A7%E5%93%81/"}],"tags":[{"name":"产品经验","slug":"产品经验","permalink":"https://blog.five2fire.top/tags/%E4%BA%A7%E5%93%81%E7%BB%8F%E9%AA%8C/"}]},{"title":"parsec通过公网IPV6实现远程连接","slug":"parsec远程连接教程","date":"2024-03-04T09:17:34.000Z","updated":"2025-01-02T02:17:10.821Z","comments":true,"path":"article/58214.html","permalink":"https://blog.five2fire.top/article/58214.html","excerpt":"没有IPv4的公网IP就只好用IPv6咯~","text":"parsec通过公网IPV6实现远程连接检查设备是否开启ipv6协议在windows-网络和 Internet-网络连接里，右键你的网络，查看以太网属性，看IPv6是否勾选，如果否，勾选上并双击进入设置自动获取IP和DNS。 首先看自己的电脑是否是公网ipv6方法1打开下面这个测试链接 http://test-ipv6.com/ 如果是10&#x2F;10，表示你的设备已经接入ipv6网络了，这时候查看网页中显示的公网IPV6地址： 你的公网 IPv6 地址是 240e:3b7:xxxxxxxxxx 如果是240x开头的，即是公网ip（不同运行商x可能会不同，电信是240e，联通是2408，移动是2409） 如果是ff08开头的，或者其他ffxx开头的，就是局域网IPv6，需要去路由器或者光猫的管理页面设置IPv6。 方法2windows用户，win+r并输入CMD打开命令行，输入ipconfig可以查看ip。 mac用户，打开终端输入ifconfig可以查看ip。 路由器光猫开启IPv6小米路由器（上级是光猫并开启了IPv6） 登录管理页面后在【常用设置】-【网络设置】-【IPv6设置】 选择上网方式为Native，自动配置DNS 光猫开启IPv6现在各大运营商的光猫都默认开启了ipv6，如果没开启，咨询网络售后人员开启。 以电信天翼网关为例，进入管理页面后，在【高级设置】-【网关信息】中，确认WAN IPv6为240x开头即可。","categories":[{"name":"技术","slug":"技术","permalink":"https://blog.five2fire.top/categories/%E6%8A%80%E6%9C%AF/"}],"tags":[{"name":"远程","slug":"远程","permalink":"https://blog.five2fire.top/tags/%E8%BF%9C%E7%A8%8B/"}]},{"title":"非常好眼镜，使我身体旋转","slug":"Vision Pro体验感受","date":"2024-03-04T02:50:40.000Z","updated":"2025-01-02T02:17:10.821Z","comments":true,"path":"article/61888.html","permalink":"https://blog.five2fire.top/article/61888.html","excerpt":"","text":"非常好眼镜，使我身体旋转⭐综合评分：8.5分 周末去少数派后海汇店参加了得物主办的Vison Pro线下体验活动，下面从几个方面评价一下Apple这款新产品。 佩戴体验 在我体验的20min里，基本没有因为重量分散注意力，可能是因为加了顶部支撑带的缘故，未加支撑带的小伙伴反映戴久了还是能感受到重量的。 戴上了之后第一时间发现下方缝隙漏光。 另外由于不是定制镜片，需要佩戴隐形眼镜体验，不知道是因为初戴隐形眼镜不适应，还是因为眼镜有些散光，还是双重镜片的影响，眼前画面出现明显重影。 交互设计 打开设备之后进入设置流程，需要先举起双手然后看向双手，在盯住原点之后捏合大拇指和食指完成确认操作。 在校准过程中，我特意飞快移动眼睛聚焦点并配合手指捏合选择，在2s之内迅速完成6个目标点的选中，体验十分丝滑。 盯住原点的时候有明显的交互显示，捏合点击时也有动态效果。 全程采用眼动+手指捏合操作，也包括捏合之后的左右拖拽（移动），前后拖动（放大缩小）。 关闭操作都比较隐蔽，通常是后退功能，并没有mac或windows窗口那样的关闭按钮，有些不太适应，只能从下方一个圆点关闭，并且有些全屏应用没有这个关闭圆点，只能通过旋钮呼出菜单。应用间切换通过头显上的旋钮更加方便，但频繁切换有些累胳膊。 玩切水果或音游的时候，识别不是很灵敏，工作人员回复可能是因为衣服袖子太粗影响到了识别。 键盘打字也需要眼睛盯着字母后捏手指，真正办公的话还是很不方便的。如果能够像ios键盘那样滑动选中，就比较酷了，按理说通过眼动轨迹是能够做出来的，期待之后的交互优化。 影音体验 图像质量没的说，比我印象里以前玩过的VR设备都要好，真的就像是把一块高清4K屏幕放到空中，在看电影或图片的时候更能体会到。 蝴蝶+恐龙的展示应用体验拉满，大恐龙凑到脸上的时候真的被吓到了，凑近了能够看到恐龙头上细微的纹理，非常棒的体验。 剧院模式下观看全景影像，能够置身其中，甚至弯腰从裆下往后看都能看到倒着的世界！ 另外配合空间音频，播放视频的时候也能根据需要，将视频放到想要的地方。 综合体验评价 确实是让人眼前一亮的产品，但是应用太少，能体验的东西也不是很多。 非常适合游戏和影音场景，但是办公场景目前看来不太方便，而且续航不会太久，目前反馈是2小时左右，好在能换电池。 只有捏手指选中这一个交互，我没有体验到手势识别或是动作识别的交互，也许没有。但可以预见的是未来必定会添加更多的手部交互进去（考虑到手表的捏手指和握拳的交互都比这个多了……），使用起来的体验应该比现在刚发售会好得多！ 有些能理解那些退款的人，应用太少，目前还不太实用，纯玩游戏看电影的话价格还是有些贵了，不如现有的一些VR设备更有性价比，反正我是买不起！！！","categories":[{"name":"生活","slug":"生活","permalink":"https://blog.five2fire.top/categories/%E7%94%9F%E6%B4%BB/"}],"tags":[{"name":"Apple","slug":"Apple","permalink":"https://blog.five2fire.top/tags/Apple/"},{"name":"评测","slug":"评测","permalink":"https://blog.five2fire.top/tags/%E8%AF%84%E6%B5%8B/"}]},{"title":"产品经理方法论","slug":"产品经理方法论","date":"2023-12-18T05:57:49.000Z","updated":"2025-01-02T02:17:10.823Z","comments":true,"path":"article/12775.html","permalink":"https://blog.five2fire.top/article/12775.html","excerpt":"","text":"产品愿景和战略规划 制定明确的产品愿景，包括产品的长期目标和愿景陈述。 确定产品的使命和核心价值主张。 定义产品的目标受众和市场定位。 分析市场、行业和用户趋势，以制定战略规划。 研究市场规模、增长率和趋势，了解市场机会和威胁。 分析行业竞争格局和竞争对手的产品特点。 考虑技术发展和社会趋势的影响，识别产品发展的机会和挑战。 确定产品的核心竞争优势和差异化战略。 评估产品在市场上的独特性和竞争优势。 确定产品的差异化特点和价值主张。 制定战略计划，包括市场推广、渠道策略和竞争策略。 用户洞察和需求分析 进行用户调研和用户访谈，以了解用户需求和痛点。 设计调研问卷或访谈指南，以收集用户反馈和见解。 进行用户访谈，与目标用户进行深入交流，了解他们的需求、偏好和挑战。 分析用户调研数据，提取关键洞察和需求模式。 分析竞争对手的产品特性和市场表现。 研究竞争对手的产品，分析其特点、功能和用户体验。 比较竞争对手的产品与自己产品的差异和优势。 分析竞争对手的市场表现，包括用户增长、用户满意度和市场份额。 制定用户故事、需求规格和产品需求文档。 根据用户调研和竞争分析的结果，编写用户故事，描述用户的需求和使用场景。 撰写需求规格和产品需求文档，明确产品功能和特性的详细描述。 与设计和开发团队合作，确保需求的准确传达和理解。 产品设计和体验 与设计团队合作，制定产品界面和用户体验设计方案。 理解用户需求和产品目标，与设计团队共同制定产品界面和用户体验设计方案。 使用用户研究和用户调研数据，指导设计团队进行界面设计和交互设计。 确保产品设计符合用户期望和行业最佳实践，提供良好的用户体验。 确保产品设计符合用户期望和行业最佳实践。 进行用户测试和反馈收集，以评估产品设计的可用性和用户满意度。 分析用户反馈和测试结果，识别设计上的问题和改进机会。 与设计团队合作，进行产品迭代和优化，以提升用户体验和界面设计。 进行用户测试和反馈收集，以不断改进产品设计和体验。 设计用户测试计划和场景，招募用户参与测试。 进行用户测试，观察用户在使用产品时的行为和反馈。 收集用户反馈和意见，分析数据并提取有价值的见解。 基于用户测试和反馈，提出产品设计改进的建议，并与设计团队合作实施改进措施。 敏捷开发和迭代优化 制定产品路线图和发布计划，以支持敏捷开发和迭代优化。 确定产品的长期发展方向和关键里程碑，制定产品路线图。 根据产品路线图，制定发布计划，确定每个迭代的目标和交付内容。 进行敏捷团队会议，包括冲刺计划会议、每日站会和冲刺回顾会议。 在冲刺计划会议上，与开发团队共同确定下一个冲刺的目标和任务。 在每日站会上，与团队成员分享进展、讨论问题和协调工作。 在冲刺回顾会议上，评估冲刺成果，收集反馈和教训，以改进下一轮迭代。 收集用户反馈和数据，用于指导下一轮迭代和优化。 设计和实施用户反馈渠道，如用户调查、用户测试和用户反馈收集工具。 分析用户反馈和使用数据，了解用户需求和产品问题。 根据用户反馈和数据分析结果，制定下一轮迭代的优先事项和改进计划。 项目管理和协调能力 制定项目计划和里程碑，确保产品按时交付。 确定项目的关键目标和交付时间表，制定详细的项目计划。 确定项目的里程碑和关键里程碑，以跟踪项目进展。 监控项目进度和里程碑的完成情况，及时调整计划和资源分配。 协调开发团队、设计团队和其他相关团队，以推动项目进展。 与开发团队、设计团队和其他相关团队进行有效的沟通和协调。 确保团队成员理解和履行其角色和职责，推动项目进展。 解决团队之间的合作问题和冲突，确保团队协同工作。 解决项目中的问题和风险，确保项目顺利进行。 识别和评估项目中的问题和风险，制定相应的解决方案。 协调团队成员解决问题，确保项目进展不受阻碍。 管理项目变更和风险，及时采取措施以最小化对项目的影响。 数据分析和决策 收集和分析用户行为数据，以识别用户趋势和行为模式。 确定需要收集的用户行为数据，如用户访问量、使用时间、转化率等。 使用分析工具和技术，如Google Analytics、用户行为分析等，收集和整理数据。 分析数据，识别用户的偏好、需求和行为模式，为产品决策提供依据。 制定数据驱动的产品决策，包括功能优先级和产品调整。 基于数据分析的结果，确定产品的关键功能和优先级。 根据用户反馈和数据指标，评估产品的性能和用户满意度，并做出相应调整。 使用数据来支持和解释产品决策，确保决策的合理性和有效性。 使用A&#x2F;B测试和实验来验证产品假设和决策。 设计和实施A&#x2F;B测试和实验，以验证产品功能、界面或其他方面的假设。 分析测试结果，比较不同版本的性能和用户反馈。 根据测试结果，确定产品的最佳实践和改进方向，以优化产品的性能和用户体验。 沟通和影响力 与团队成员、高管、客户和利益相关者进行沟通，以分享产品愿景和项目进展。 定期与团队成员开展沟通，包括团队会议、进度更新和问题讨论。 向高管汇报产品进展和关键决策，确保他们了解产品的发展方向。 与客户和利益相关者保持沟通，了解他们的需求和反馈。 利用演讲、文档和演示来影响他人对产品决策的支持。 准备并进行有效的演讲，传达产品愿景、策略和价值主张。 撰写清晰、详细的文档，以便他人理解产品需求和决策依据。 利用演示和原型展示产品设计和功能，以获得他人的支持和反馈。 处理利益相关者的反馈和问题，以建立良好的合作关系。 倾听利益相关者的意见和反馈，对待他们的问题和关切予以认真回应。 解释产品决策的背景和理由，以增加他们对决策的理解和认同。 建立良好的合作关系，与利益相关者合作解决问题，并寻求共同的利益和目标。 技术理解和商业意识 与工程团队合作，理解技术挑战和解决方案。 与工程团队密切合作，理解产品的技术需求和挑战。 学习和了解相关的技术概念、工具和平台，以便更好地与工程团队沟通和合作。 就技术决策提供建议和反馈，以确保产品的技术可行性和可实施性。 理解产品对业务的影响，包括收入、成本、市场份额和用户增长。 分析产品对业务的贡献和影响，包括收入增长、成本节约、市场份额扩大等。 了解产品在市场中的定位和竞争力，以评估其潜在商业价值。 与业务团队合作，确保产品与公司的战略目标和商业模式相一致。 分析竞争对手和市场变化，以调整产品策略和规划。 研究竞争对手的产品特点、市场表现和战略动向。 分析市场趋势和变化，以及用户需求的演变。 根据竞争和市场情况，调整产品策略、定位和规划，以保持竞争优势和满足市场需求。","categories":[{"name":"产品","slug":"产品","permalink":"https://blog.five2fire.top/categories/%E4%BA%A7%E5%93%81/"}],"tags":[{"name":"产品经验","slug":"产品经验","permalink":"https://blog.five2fire.top/tags/%E4%BA%A7%E5%93%81%E7%BB%8F%E9%AA%8C/"}]},{"title":"《自控力》读书笔记","slug":"《自控力》读书笔记","date":"2023-11-30T04:29:04.000Z","updated":"2025-01-02T02:17:10.823Z","comments":true,"path":"article/1191.html","permalink":"https://blog.five2fire.top/article/1191.html","excerpt":"","text":"自控力01什么是意志力摘抄 意志力就是驾驭“我要做”、“我不要”和“我想要”这三种力量。 核心思想：意志力实际上是“我要做”、“我不要”和“我想要”这三种力量。它们协同努力，让我们变成更好的自己。 深入剖析 更难的事是什么？想象你正面临一个意志力的挑战。更难的事是什么？为什么它如此困难？ 认清两个自我。你的意志力挑战是，如何描述相抗衡的两个自我？冲动的你想要什么？明智的你又想要什么？ 意志力实验 意志力实验：回忆一下你的决定 请至少选一天，把你作的决定都记下来。在这一天结束的时候，回想你作的决定，分析哪些有利于你实现目标，哪些会消磨你的意志。坚持记录你的决定，还有助于减少在注意力分散时作决定，同时增强你的意志力。 意志力实验：5分钟训练大脑冥想 1.原地不动，安静坐好。 坐在椅子上，双脚平放在地上，或盘腿坐在垫子上。背挺直，双手放在膝盖上。冥想时一定不能烦躁，这是自控力的基本保证。如果你想挠痒的话，可以调整一下胳膊的位置，腿交叉或伸直，看自己是否有冲动但能克制。简单的静坐对于意志力的冥想训练至关重要。你将学会，不再屈服于大脑和身体产生的冲动。 2.注意你的呼吸。 闭上眼睛。要是怕睡着，你可以盯着某处看，比如盯着一面白墙，但不要看家庭购物频道。注意你的呼吸。吸气时在脑海中默念“吸”，呼气时在脑海中默念“呼”。当你发现自己有点走神的时候，重新将注意力集中到呼吸上。这种反复的注意力训练，能让前额皮质开启高速模式，让大脑中处理压力和冲动的区域更加稳定。 3.感受呼吸，弄清自己是怎么走神的。 几分钟后，你就可以不再默念“呼”、“吸”了。试着专注于呼吸本身。你会注意到空气从鼻子和嘴巴进入和呼出的感觉，感觉到吸气时胸腹部的扩张和呼气时胸腹部的收缩。不再默念“呼”、“吸”后，你可能更容易走神。像之前一样，当你发现自己在想别的事情时，重新将注意力集中到呼吸上。如果你觉得很难重新集中注意力，就在心里多默念几遍“呼”和“吸”。这部分的训练能锻炼你的自我意识和自控能力。 每天都做，宁短不拖。再短也要做 02意志力的本能摘抄 三思而后行 放弃对意志力的完美控制。即便你增强了自己的意志力，你也不可能完全控制自己想什么、感觉什么、说什么或者做什么。你需要明智地使用意志力的能量。 核心思想：意志力是种生理本能，它和压力一样，通过不断进化来保护我们不受自身伤害。 深入剖析 什么是威胁？对你的意志力挑战来说，什么是需要克制的内在冲动？ 压力和自控。试着找出持续一整天或一整周的压力，看看它对你的自控力产生怎样的影响。你有过强烈的欲望吗？你发脾气了吗？你把要做的事拖到了明天吗？ 意志力实验 意志力实验：通过呼吸实现自控 快速提高意志力的方法：将呼吸频率降低到每分钟4-6次，也就是每次呼吸用10-15秒时间，比平常呼吸要慢一些。 意志力实验：5分钟给意志力加油 以下是一些你在5分钟“绿色锻炼”中可以尝试的活动： 走出办公室，找到最近的一片绿色空间。 用iPod播放一首你最喜欢的歌曲，在附近街区慢跑。 和你的宠物狗在室外玩耍（你可以追着玩具跑）。 在自家花园里找点事情做。 出去呼吸新鲜空气，做些简单的伸展活动。 在后院里和孩子做游戏。 意志力实验：呼噜呼噜睡个觉 意志力实验：放松能让你恢复意志力储备 想要激发这种放松反应，你需要躺下来，用枕头垫着膝盖，腿稍稍抬起（或者，你可以选择任何一个你觉得舒服的姿势）。闭上眼睛，做几次深呼吸，感觉你的腹部有起伏。如果你觉得身体某处很紧张，你可以有意识地挤压或收缩肌肉，然后就不要再去管它了。 03 累到无力抵抗摘抄 意志力是有限的 一个重要的意志力规则：如果你觉得自己没有时间和精力去处理“我想要”做的事，那就把它安排在你意志力最强的时候做。 资源不足时，大脑会选择满足当下的需求；资源充足时，大脑则会转向选择长期的投资。 控制自己以前不会去控制的小事，以此来训练自控力肌肉 在一些小事上持续自控会提高整体的意志力 不是为了让你在规定期限前完成任务、用左手开门或不说脏话，而是让你养成习惯、关注自己正在做的事情、选择更难的而不是最简单的事。通过每一次意志力练习，大脑开始习惯于三思而后行。 核心思想：自控力就像肌肉一样有极限。自控力用得太多会疲惫，但坚持训练能增强自控力。 深入剖析 意志力的上下波动。本周，记录你的自控力，特别注意什么时候你的意志力最强，什么时候你最容易放弃。 你的疲惫感是真的吗？下次你觉得自己太“疲惫”而无法自控的时候，看看自己能不能挺过第一波疲惫的感觉，向前迈出一步。 意志力实验 意志力实验：意志力饮食方案 低血糖食品包括瘦肉蛋白、坚果和豆类、粗纤维谷类和麦片、大多数的水果和蔬菜。 只要是看起来处于自然状态的食物，以及没有大量添加糖类、脂肪和化学物品的食物都行。 意志力实验：锻炼意志力 增强“我不要”的力量：不随便发誓（或者不说某些口头禅）、坐下的时候不跷脚、用不常用的手进行日常活动，比如吃饭和开门。 增强“我想要”的力量：每天都做一些事（但不是你已经在做的事），用来养成习惯或不再找借口。你可以给母亲打电话、冥想5分钟，或是每天在家里找出一件需要扔掉或再利用的东西。 增强自我监控能力：认真记录一件你平常不关注的事，可以是你的支出、饮食，也可以是你花在上网和看电视上的时间。你不需要太先进的工具，铅笔和纸就够了。但如果你需要一些激励的话，“量化自我”运动（www.quantifiedself.com）已经把“自我记录”变成了一门科学和一种艺术。 意志力实验：你的“我想要”的力量是什么？ 当你的意志力告急时，你可以挖掘你的“我想要”的力量，让自己恢复能量。面对你最大的意志力挑战时，你可以考虑以下动机。 1.如果挑战成功，你会收获什么？你个人会有什么回报？你会更健康、更幸福、更自由、更有钱，还是会更成功？ 2.如果挑战成功，还有谁会获益？肯定有人依赖于你，你的选择会影响到他们。你的行为会如何影响你的家人、朋友、同事、雇主或雇员、街坊邻居？你的成功会怎样帮到他们？ 3.如果你现在愿意做困难的事，那么一段时间后，这个挑战将会变容易。你能想象出，如果你在这个挑战中取得进步，你的生活会是什么样子，你自己会变成什么样子吗？如果你知道你还有更大的进步空间，现在的不适是不是变得值得了呢？ 04 容忍罪恶摘抄 当说到孰是孰非时，我们都能毫不费力地作出符合道德标准的选择。我们只想让自己感觉良好，而这就为自己的胡作非为开了绿灯。 因为我们很容易认为，纵容自己就是对美德最好的奖励。我们忘记了自己真正的目标，向诱惑屈服了。 为了避免“道德许可”的陷阱，我们要把真正的道德困境和普通的困难区分开来。 想要做到始终如一，我们就需要认同目标本身，而不是我们做善事时的光环。 核心思想：当我们将意志力挑战看成衡量道德水平的标准时，善行就会允许我们做坏事。为了能更好地自控，我们需要忘掉美德，关注目标和价值观。 深入剖析 善与恶：当你的意志力挑战成功时，你会不会告诉自己你很“好”，然后允许自己做一些“坏”事？ 你是否在向明天赊账？你是不是告诉自己明天会弥补今天的过错？如果是这样的话，你是否真的弥补上了？光环效应：你是不是只看到了坏东西好的一面，如折扣省钱、零脂肪、保护环境？ 你觉得自己是谁？当你想到你的意志力挑战时，你觉得哪部分的你才是“真实”的你？是想追求目标的你，还是需要被控制的你？ 意志力实验 明天和今天毫无区别。当你想改变行为的时候，试着减少行为的变化性，而不是减少某种行为。 取消许可，牢记理由。下一回，当你发现自己在用曾经的善行为放纵辩护的时候，停下来想一想你做“好”事的原因，而不是你应不应该得到奖励。 05 误把渴望当幸福摘抄 多巴胺会促使人们期待得到奖励，但不能感觉到获得奖励时的快乐 如果奖励迟迟没有到来的话，奖励的承诺（和一想到要停下来就不断增长的焦虑）足以让我们一直上瘾 欲望是大脑的行动战略。正如我们看到的，它可能对自控构成威胁，也可能是意志力的来源。当多巴胺让我们屈服于诱惑的时候，我们必须区分渴望和快乐。我们也可以利用多巴胺和奖励的承诺来激励自己和他人。最后，欲望没有绝对的好坏之分，重要的是欲望将我们引向哪个方向，以及我们是否足够明智，知道什么时候该听从欲望的声音。 核心思想：我们的大脑错把奖励的承诺当做快乐的保证，所以，我们会从不可能带来满足的事物中寻找满足感。 深入剖析 深入剖析：是什么让你的多巴胺神经元不停燃烧？ 你知道什么会刺激你的多巴胺分泌？食物？酒精？购物？Facebook？还是其他东西？这一周，试着观察是什么吸引了你的注意力。是什么给了你奖励的承诺，强迫你去寻求满足感？是什么让你像巴甫洛夫的狗一样垂涎欲滴，或是像奥尔兹和米尔纳的小白鼠一样欲罢不能？ 深入剖析：谁在控制你的多巴胺神经元？ 让我们来观察一下，零售商和营销人员究竟是如何刺激奖励承诺的。把逛商店或看广告当做一种游戏。你闻到了什么？看到了什么？听到了什么？当你知道这些暗示都是经过精心设计，专门要诱惑你上钩的时候，你就能看清它们到底是什么，也就能成功抵御它们了。 深入剖析：欲望的压力 大部分人会更关注对快乐的承诺，而不关注多巴胺刺激欲望时感觉到的不快乐。这一周，看看你能否发现渴望会引发压力和焦虑。如果你屈服于诱惑的话，你觉得这是自己对奖励承诺的反应？还是在缓解焦虑？ 意志力实验 测试奖励的承诺。 做那些大脑告诉你你会快乐、但似乎无法让你满足的事，比如吃零食、购物、电视以及与网络相关的、浪费时间的事，注意观察自己放纵时的感受。现实和大脑的承诺相符吗？ 为了你的“我愿意”挑战分泌多巴胺 如果有什么事让你觉得很不愉快，所以你总是拖延着不去做，你能不能把它和能让多巴胺神经元燃烧的事联系在一起，从而促使自己去做呢？ 06 那又如何摘抄 为什么压力会勾起欲望？ 因为这是大脑援救任务的一部分 压力把我们引向了错误的方向，让我们失去了理性，被本能支配了。这就是压力和多巴胺“强强联手”的力量。我们一次又一次地败下阵来，采用那些不起作用的应对策略，而我们简单的大脑还固执地认为那就是获得幸福的正确途径。 有没有什么东西能提醒面对压力的你，到底什么才能让你感到更快乐？在你感到压力之前，你能不能先想出一些鼓励自己的方法？ “那又如何”效应：为什么罪恶感不起作用？ 无论是什么样的意志力挑战，模式都是一样的。屈服会让你对自己失望，会让你想做一些改善心情的事。那么，最廉价、最快捷的改善心情的方法是什么？往往是做导致你情绪低落的事。 关键是，导致更多堕落的行为并不是第一次的放弃，而是第一次放弃后产生的羞耻感、罪恶感、失控感和绝望感。 自我批评会降低积极性和自控力，而且也是最容易导致抑郁的因素。它不仅耗尽了“我要做”的力量，还耗尽了“我想要”的力量。相反，自我同情则会提升积极性和自控力，比如，在压力和挫折面前支持自己、对自己好一些 出人意料的是，增强责任感的不是罪恶感，而是自我谅解。研究人员发现，在个人挫折面前，持自我同情态度的人比持自我批评的态度的人更愿意承担责任。他们也更愿意接受别人的反馈和建议，更可能从这种经历中学到东西。 我们都倾向于相信自我怀疑和自我批评，但这并不会让我们离目标更近。实际上，我们可以尝试从良师益友的角度来看待问题。他们都信任你、想要你变得更好、愿意在你失意的时候鼓励你，你也可以这么做。 下定决心会让我们立刻有了放松感和控制感。我们不再觉得自己是个犯错的人，只觉得自己能变成一个完全不同的人。 不幸的是，就像奖励的承诺和缓解压力的承诺一样，改变的承诺也很少能朝我们希望的方向发展。不切实际的乐观可能给我们一时的快乐，但接下来我们就会感到失落。 深入剖析 缓解压力的承诺 当你感到压力、焦虑或心情低落的时候，你会怎么做呢？你生气时会不会更容易受到诱惑？你是不是会更难集中注意力，或更容易拖延呢？情绪低落是如何影响你的意志力挑战的？ 是什么吓到了你？ 这一周，请注意观察什么事情会引发你大脑里的“恐惧管理”。 看看商家怎么利用你的恐惧宣传他们的产品。它们和你的意志力挑战有关系吗？ 别人还可能怎么利用你的恐惧，让你产生对安慰的渴望？ 遇到挫折时 这一周，请特别留意你是如何应对意志力失效的。你会责备自己，告诉自己你永远不会改变吗？你会觉得这样的挫折暴露了你的问题——懒惰、愚蠢、贪婪或无能吗？你会感到绝望、罪恶、羞愧、愤怒或不知所措吗？你会以挫折为借口，更加放纵自己吗？ 决定改善心情 请花一点时间，仔细想一想你改变自己的动力和期望。你只有在情绪低落时才会有动力改变吗？想象成功改变生活时的快乐，是不是你作出改变的唯一动力？你会通过幻想未来的自己来改善现在的心情，而不是采取实际行动改善自己的行为吗？ 意志力实验 尝试一种有效的解压方法 最有效的解压方法包括：锻炼或参加体育活动、祈祷或参加宗教活动、阅读、听音乐、与家人朋友相处、按摩、外出散步、冥想或做瑜伽，以及培养有创意的爱好。 最没效果的缓解压力的方法则包括：赌博、购物、抽烟、喝酒、暴饮暴食、玩游戏、上网、花两小时以上看电视或电影。 失败的时候，请原谅自己 每个人都会犯错误，都会遭遇挫折。既然失败无法避免，更重要的就是我们如何应对失败。想象一个你屈服于诱惑或拖延的情况，试验从以下三个角度思考这次失败。当你遭遇挫折时，你也可以用同样的角度思考，使自己避免再次陷入罪恶感、羞愧感和屈服的泥淖。 1.你感觉如何？当你想到挫折时，花一点时间关注并描述你此刻的感觉。你现在情绪如何？你有什么感觉？你是否记得自己失败后的第一感觉？你会怎样描述那种感觉？注意一下那种感觉是不是自我责备。如果是的话，你对自己说了什么？自知的视角让你看清自己的感受，而且不会急于逃避。 2.你只是个凡人。每个人都会遇到意志力挑战，每个人都有失去自控的时候。这只是人性的组成部分，挫折并不意味着你本身有问题。想一想这些说法是不是真的。你能想象你尊敬、关心的其他人也经历过同样的抗争和挫折吗？这个视角会让自我批评和自我怀疑的声音变得不那么尖锐。 3.你会跟朋友说什么？想一想，如果你的好朋友经历了同样的挫折，你会怎么安慰他？你会说哪些鼓励的话？你会如何鼓励他继续追求自己的目标？这个视角会为你指明重归正途之路。 乐观的悲观主义者更可能成功 预测你什么时候、会怎样受到诱惑和违背承诺，想象一个不让自己放弃抗争的具体方法。 07 及时享乐的经济学摘抄 经济学家称之为“延迟折扣”。也就是说，等待奖励的时间越长，奖励对你来说价值越低。很小的延迟就能大幅降低你感知到的价值。 像对待另一个人一样，逐步预测并约束那个自我 我们会把未来的自己想象成完全不同的一个人——这是个令人费解但却不难预测的错误。我们把未来的自己理想化了，希望未来的自己可以做到现在的自己做不了的事。 这种错误的想象让我们像对待陌生人一样对待未来的自己。 我们会给未来的自己增加负担，就好像那时的自己是个陌生人一样。 如果我们真的指望未来的自己能这么崇高，我们确实可以相信，未来的自己能做好所有的事。但更典型的情况是，当我们到了未来，理想中“未来的自己”却不见了，最后作决定的还是毫无改变的曾经的自己。即便我们现在已经失去了自控力，我们仍然愚蠢地希望未来的自己不会面临冲突。 为什么我们会把未来的自己视为另一个人呢？原因在于，我们不知道未来自己的想法和感受。当我们想到未来的自己时，我们的欲望不会像现在一样紧迫，情绪不会像现在一样真切。直到我们真的需要选择的时候，我们才会知道当下的想法和感受。 当我们思考未来时，我们能预测到未来的自己和想象中有什么不同。未来的奖励似乎并不那么有诱惑力，所以我们选择了即时的满足感。我们无法预测自己会怎么受到诱惑、怎么被分散注意力，所以我们无法坚定自己的目标。如果我们想作出更明智的决定，就要更好地理解和支持未来的自己。我们还需要记住，为现在的行为承担后果的，看似是未来的自己，实际上还是我们自己。未来的自己会对我们现在的付出感激不尽。 深入剖析 你给未来的奖励打了几折？ 对你的意志力挑战来说，当你屈服于诱惑或拖延的时候，你是把哪些未来的奖励出售了？放弃抗争的即时回报是什么？长期的代价是什么？这是公平交易吗？如果理性的你说“不，那是个叫人讨厌的买卖”，那么，请你试着去捕捉自己改变选择的时刻。是什么想法和感觉让你出售了未来？ 你在等待未来的自己吗？ 你是否在推迟重要的变化或任务，等待自控力更强的未来的自己出现？你是不是乐观地让自己承担过多的责任，最后却被不可能的任务打倒了？你今天有没有不去做什么事，因为明天你会更想去做那件事？ 为了你自己好，你是不是太“高瞻远瞩”了？ 你是否有过这样的感觉：因为总有更多的事情要做，似乎没办法放下工作休息一下？你是否对花钱产生了太多的罪恶感和焦虑感，以至于除了购买生活必需品，你觉得自己很难再去买别的东西？你有没有回头看过，自己是怎样花费时间和金钱的？你会不会希望当时你能更关注即时的快乐，而不是总去推迟享受？如果是这样的话，试一试本章提到的意志力实验，把它们当做放纵自己的方法。 意志力实验 等待10分钟 想获得一个冷静明智的头脑，我们就需要在所有诱惑面前安排10分钟的等待时间。如果10分钟后你仍旧想要，你就可以拥有它。但在10分钟之内，你一定要时刻想着长远的奖励，以此抵抗诱惑。如果可以的话，你也可以创造一些物理上（或视觉上）的距离。 如果你的意志力挑战需要“我要做”的力量，你仍旧可以使用这个“10分钟法则”，以此来克服诱惑和拖延。你可以把法则改成“坚持做10分钟，然后就可以放弃”。当10分钟结束后，你就可以允许自己停下来。不过你会发现，只要一开始，你就会想继续做下去。 降低你的折扣率 1.当你受到诱惑要做与长期利益相悖的事时，请想象一下，这个选择就意味着，你为了即时的满足感放弃了更好的长期奖励。 2.想象你已经得到了长期的奖励。想象未来的你正在享受自控的成果。 3.然后扪心自问：你愿意放弃它，来换取正在诱惑你的短暂快感吗？ 对未来的自己作预先承诺 这一周，为未来某一刻的自己作出承诺。从以下策略中挑选一个，在你的意志力挑战中用上它。 1.作好拒绝诱惑的准备。在未来的自我被诱惑蒙蔽之前，提前作出选择。 2.让改变偏好变得更难。就像科尔蒂斯“破釜沉舟”一样，不要让自己轻易屈服于诱惑。 3.激励未来的自己。如果你在用胡萝卜或大棒督促自己获得健康和快乐，那么你不用觉得羞愧。 遇见未来的自己 把自己送到未来，帮助自己作出更明智的选择。下面三种方法能让未来变得真实可信，让你认识未来的自己。 1.创造一个未来的记忆。 2.给未来的自己发条信息。 3.想象一下未来的自己。 08 为什么意志力会传染？摘抄 实际在很大程度上，那些我们通常认为受自控力影响的行为，也会受社会控制力的影响。 我们发现了三种形式，这三种形式都会使我们的社会脑（social brain）出现意志力失效。 第一种形式是无意识的模仿。 大脑让我们误入迷途的第二种形式是传染情绪。 最后，当我们看到别人屈服于诱惑时，我们的大脑也可能受到诱惑。 研究发现，我们很容易感染别人的目标，从而改变自己的行为。 行为就是这样传染的。和地理上的亲近程度比起来，社会关系上的亲密程度更重要。 我们的大脑会把别人的目标、信念和行为整合到自己的决策中。当我们跟别人在一起时，或者只是简单地想到他们时，在我们的脑海里，别人就会成为另一个“自我”，并且和“自我”比赛自控。反之亦然：我们的行为也影响了其他无数人，我们做的每个选择对别人来说也是一种鼓舞或诱惑。 深入剖析 你的社交 在你的社交圈中，有没有其他人有和你一样的意志力挑战？ 回想一下，你有没有从朋友或家人身上学到过某种习惯？ 和某些人在一起的时候，你会不会更容易放纵自己？ 在你的社交圈中，最近有没有其他人也在尝试应对这个意志力问题？ 你在模仿谁？ 这一周，仔细观察你是否在模仿别人的行为，尤其是和你的意志力挑战有关的行为。同样放纵自己的行为是不是维持关系的社会黏合剂？当看到周围的人在做同样的事时，你会不会变本加厉地去做这件事？ 你最可能被谁感染？ 花一点时间去想一想，谁是和你关系密切的人。你和谁在一起的时间最长？你最尊重谁？你觉得谁和自己最像？谁的意见对你来说最重要？你最信任谁，最关心谁？你能不能想到哪些行为（无论是有益的还是有害的）是你从他们身上学来的，或是他们从你身上学到的？ 可别人都这么做！ 质疑它的最好方法就是找到一群人，他们正在做你渴望做到的事。 置身于和你共享承诺与目标的人们当中，会让你觉得自己的目标才是社会规范。 意志力实验 增强你的免疫系统 当你面对别人的目标时，增强免疫系统的最佳途径就是：在每天刚开始的时候花几分钟想想自己的目标，想想你会怎么受到诱惑，想要改变自己的目标。这就像疫苗一样，能保护你不受别人的感染。回想自己的目标能强化这个目标，避免你感染他人的目标。 自豪的力量 想象一下你在意志力挑战中取得成功后会多么自豪。这样，你就能充分利用“被认可”这个人类的基本需求。 当你作出一个让自己感到自豪的选择时，你可以更新Facebook的个人状态，或是在Twitter上发布信息。如果你不喜欢高科技产品，你也可以和人们面对面地分享自己的故事。 把它变成集体项目 你无须单独面对你的意志力挑战。有没有朋友、家人或同事可以和你一起实现意志力目标？你们不必有相同的目标，只需要相互记录和鼓励。 09 “我不要”力量的局限性摘抄 越是不让我们想一件事，我们就会越去想它 当人们试着不去想某件事时，反而会比没有控制自己的思维时想得更多，比自己有意去想的时候还要多。这个效应在人处于紧张、疲劳或烦乱状态时最为严重。韦格纳把这个效应称为“讽刺性反弹” 一旦允许研究对象把压抑的想法表达出来，这个想法就不太容易被激活了，因此进入意识的可能性也变小了。这件事说起来有点矛盾——允许你去想一件事，反而会减少你想起它的可能性。 研究显示，越是压抑消极情绪，人越可能变得抑郁。 如果想让自己远离精神痛苦，人们就需要与这些想法和平相处，而不是把它们推到一边。 越想通过抑制想法来抵抗诱惑，受到的不良影响就越大 试着控制自己的思想和感受，反而会对我们原先的目标产生反面效果。但是我们大多数人在犯下这个战略性错误后，并不会在反省失败时认识到这一点。我们反倒会认为是自己自制力不够，从而会定下更多“下次一定要控制住自己”的目标。为了让我们的头脑远离有害的思想和感受，我们努力去摆脱它们，但往往事倍功半。相反，如果我们想要获得心灵的平静和足够的自控力，我们就需要认识到，控制自己的思想是件不可能的事。我们能做的就是，选择自己相信什么，选择自己要做什么。 深入剖析 讽刺性反弹调查 你是否想忘记某些东西？如果是，请检验一下讽刺性反弹理论。压抑有用吗？试图忘记某些东西是否让它回来时变得更强烈？ 你最渴望什么？ 你是否曾经被禁止做什么事呢？被禁止做某件事会消除你对它的欲望，还是会激起你更大的渴望？ 意志力实验 忠于你的感受，但别相信你所有的想法 遇到烦恼的时候，不妨尝试一下戈尔丁教给患者的方法。关注自己的想法，而不是试着转移注意力。 这些想法会像脑海里的歌曲一样突然出现。它们不知从何而来，但一旦出现就无法摆脱。 接下来，把注意力转移到你的身体感受上 一旦观察到这些想法和感觉，就把注意力转移到呼吸上。 不要停下呼吸，想象这些浮云不断消散或飘过。把呼吸想象成一阵风，它毫不费力地将这些浮云吹散、吹走。你无须让这些想法离开，只需保持呼吸的感觉。 直面自身欲望，但不要付诸行动 1.承认自己脑海中的欲望，以及渴望某种事物的感觉。 2.不要马上试着转移注意力或与之争论。接受这种想法或感觉，提醒自己“白熊”现象和“反弹”理论。 3.退一步考虑，意识到这种想法和感觉并不受你控制，但你可以选择是否将这些想法付诸实践。 4.记住你的目标，提醒自己预先作出的承诺。正如那些学生会提醒自己，他们答应过不偷吃巧克力。 把“我不要”变成“我想要” 除了“我不要”，你还能做什么来满足同样的需求？ 如果没有了坏习惯，你还能做些什么？ 可以通过重新定义“我不要”的挑战，把它变成“我想要”的挑战吗？ 如果你关注自己想做什么，而不是自己不想做什么，你就可以避免“反弹”效应带来的危害。 驾驭冲动 无论你对什么上瘾，“驾驭冲动”的技巧都能帮你抵抗诱惑，而不是屈服于它。当冲动占据你的头脑时，花至少一分钟去感觉自己的身体。你的冲动是什么样的？ 保持这个状态至少一分钟。看看这些感觉在强度或特性上有什么变化。 如果你在最初几次尝试中失败了，别灰心，这并不意味着这种方法是无效的。","categories":[{"name":"书影音","slug":"书影音","permalink":"https://blog.five2fire.top/categories/%E4%B9%A6%E5%BD%B1%E9%9F%B3/"}],"tags":[{"name":"自律","slug":"自律","permalink":"https://blog.five2fire.top/tags/%E8%87%AA%E5%BE%8B/"},{"name":"读书笔记","slug":"读书笔记","permalink":"https://blog.five2fire.top/tags/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"}]},{"title":"Hexo解决bamboo主题移动端部分情况下无法滚屏的问题","slug":"Hexo解决bamboo主题移动端部分情况下无法滚屏的问题","date":"2023-10-18T08:42:59.000Z","updated":"2025-01-02T02:17:10.809Z","comments":true,"path":"article/64467.html","permalink":"https://blog.five2fire.top/article/64467.html","excerpt":"","text":"背景自己的博客之前一直是用的比较简单的pure主题，最近选了一个比较好看，内容也很丰富的bamboo主题，真的不错。但是修改了一些基础配置，在手机上预览的时候才发现一些情况下没办法滚动，也就是手指上滑屏幕没反应。 想到应该是前端问题，而且主题是完全开源的，所以就尝试着分析代码自己来解决这个问题。 问题具体表现博客里使用菜单功能之后，可以从菜单进入到首页、归档、标签、分类等特定页面的，在web端这些操作都没问题，但是在移动端（或者在谷歌浏览器里把窗口调小），如果从菜单进入其他页面后，就无法滚动了。 但是如果在新打开的页面里，手动展开菜单，再点击旁边区域收起菜单，就能够正常滚动了。 解决过程修改Header.ejs文件第一时间想到的是这个菜单控件虽然在打开新页面时候看不见了，实际上还停留在顶部图层。这么想，是因为我在Axure画图里，可以把一些控件隐藏掉，再通过一些按钮或是其他交互把它显示出来。但是隐藏的控件是不会影响其他控件的操作的，只有在显示的时候才会有效果，所以这个想法不太实际。 到作者的演示界面发现是不存在这个问题的，于是在谷歌浏览器里F12，对比了一下两个页面有何区别。 出bug的代码： 1234&lt;a href=&quot;/archives&quot; class=&quot;drawer-menu-item-link&quot; data-pjax-state=&quot;&quot;&gt; &lt;i aria-hidden=&quot;true&quot; class=&quot;fas fa-archive&quot;&gt;&lt;/i&gt; &lt;span class=&quot;name&quot;&gt;归档&lt;/span&gt; &lt;/a&gt; 作者展示页面的 1234&lt;a href=&quot;/archives&quot; class=&quot;drawer-menu-item-link&quot; data-pjax-state=&quot;&quot;&gt; &lt;i aria-hidden=&quot;true&quot; class=&quot;fa fa-archive&quot;&gt;&lt;/i&gt; &lt;span class=&quot;name&quot;&gt;归档&lt;/span&gt; &lt;/a&gt; 可以看到只是class=&quot;fa fa-archive和class=&quot;fas fa-archive的区别。我就去找这个menu-item对应的文件，在header.ejs里找到了这么一段 12345678910111213141516171819202122232425262728293031323334&lt;% if(theme.menu) &#123; %&gt; &lt;% Object.keys(theme.menu).forEach(function(key) &#123; %&gt; &lt;li class=&quot;menu-item&quot; style=&quot;position: relative;&quot;&gt; &lt;% if(!theme.menu[key].children) &#123; %&gt; &lt;a href=&quot;&lt;%- url_for(theme.menu[key].url) %&gt;&quot; class=&quot;menu-item-link&quot; title=&quot;&lt;%- (config.language === &#x27;zh-CN&#x27; &amp;&amp; menuMap.has(key)) ? menuMap.get(key) : key %&gt;&quot;&gt; &lt;% if (theme.menu[key].icon &amp;&amp; theme.menu[key].icon.length &gt; 0) &#123; %&gt; &lt;i class=&quot;&lt;%- theme.menu[key].icon %&gt;&quot; aria-hidden=&quot;true&quot;&gt;&lt;/i&gt; &lt;% &#125; %&gt; &lt;span class=&quot;name&quot;&gt;&lt;%- (config.language === &#x27;zh-CN&#x27; &amp;&amp; menuMap.has(key)) ? menuMap.get(key) : key %&gt;&lt;/span&gt; &lt;/a&gt; &lt;% &#125; else &#123; %&gt; &lt;a href=&quot;javascript:;&quot; class=&quot;menu-item-link&quot; title=&quot;&lt;%- (config.language === &#x27;zh-CN&#x27; &amp;&amp; menuMap.has(key)) ? menuMap.get(key) : key %&gt;&quot;&gt; &lt;% if (theme.menu[key].icon &amp;&amp; theme.menu[key].icon.length &gt; 0) &#123; %&gt; &lt;i class=&quot;&lt;%- theme.menu[key].icon %&gt;&quot;&gt;&lt;/i&gt; &lt;% &#125; %&gt; &lt;span class=&quot;name&quot;&gt;&lt;%- (config.language === &#x27;zh-CN&#x27; &amp;&amp; menuMap.has(key)) ? menuMap.get(key) : key %&gt;&lt;/span&gt; &lt;i class=&quot;fas fa-chevron-down arrow&quot; aria-hidden=&quot;true&quot;&gt;&lt;/i&gt; &lt;/a&gt; &lt;ul class=&quot;sub-menu&quot;&gt; &lt;% for(let childrenLink of theme.menu[key].children)&#123; %&gt; &lt;li&gt; &lt;a href=&quot;&lt;%- url_for(childrenLink.url)%&gt;&quot;&gt; &lt;% if (childrenLink.icon &amp;&amp; childrenLink.icon.length &gt; 0) &#123; %&gt; &lt;i class=&quot;&lt;%- childrenLink.icon %&gt;&quot; style=&quot;margin-top: -20px;&quot;&gt;&lt;/i&gt; &lt;% &#125; %&gt; &lt;span&gt;&lt;%- childrenLink.name %&gt;&lt;/span&gt; &lt;/a&gt; &lt;/li&gt; &lt;% &#125; %&gt; &lt;/ul&gt; &lt;% &#125; %&gt; &lt;/li&gt; &lt;% &#125;); %&gt;&lt;% &#125;%&gt; 想当然地把class=&quot;fas fa-chevron-down arrow里的s，去掉了，也不知道是不是对应的这里，反正没有解决问题。 修改drawer.ejs文件menu的上层是个drawer，所以下一步是从这里着手。在网上搜了前端的有关滚动的知识，发现是由overflow参数确定的，并且在drawer.ejs中找到了防止页面滚动的代码。 123456showDialogDrawer() &#123; this.visible = true; // 防止页面滚动，只能让弹框滚动 this.top = $(document).scrollTop() body.style.cssText = &#x27;width: 100%; height: 100%;overflow: hidden;&#x27;;&#125; 把body.style.cssText这一行注释掉，问题似乎就解决了。 但是这只是表面上解决了，实际上，“防止页面滚动，只能让弹框滚动”是非常合理的交互逻辑，这里屏蔽掉之后，打开菜单时再滚动，菜单后面的页面也会滚动了，所以到此还是不能认为解决了BUG。 再进一步至此我觉得已经不是我能解决的玄学问题了，因为我看到刚下这个主题的时候，预览是没有问题的，但是修改了config里面的一些配置后就出现这个问题了，所以我打算把代码版本还原到没问题的版本，再一点点修改配置，看看到底是哪个环节出了问题。 经过控制变量法耗时足足五分钟发现，是全文搜索这个控件的问题，只要关闭了这个控件就会导致最开始提到的问题。 OK，问题这下算是解决了。再进一步是找出为什么关闭了就会出现这个问题。而且全文搜索目前也没有作用。这两个问题之后可以试着一起解决，下次再重新记录一下过程。","categories":[{"name":"技术","slug":"技术","permalink":"https://blog.five2fire.top/categories/%E6%8A%80%E6%9C%AF/"}],"tags":[{"name":"编程","slug":"编程","permalink":"https://blog.five2fire.top/tags/%E7%BC%96%E7%A8%8B/"},{"name":"Hexo","slug":"Hexo","permalink":"https://blog.five2fire.top/tags/Hexo/"}]},{"title":"写在十一旅游回来之后","slug":"十一旅游回来之后","date":"2023-10-10T09:36:55.000Z","updated":"2025-01-02T02:17:10.824Z","comments":true,"path":"article/12325.html","permalink":"https://blog.five2fire.top/article/12325.html","excerpt":"","text":"写在十一旅游回来之后旅游之前9月29号放国庆假，我们是9月中旬十几号才定的要去云南。一方面是女朋友的加班时间没有确定，最主要的还是我没有太大的意愿出去玩。那段时间整个人都处于一个什么事情都不想做的阶段，情绪低落，无欲无求，对生活没有期待，对一切事情都很麻木，而且会很在意收入支出，觉得出去一趟花费很多，再对比自己可怜的月薪，更不愿意出去了。 但想到女朋友平时工作单休，基本没有什么休息的时间，难得十一能够放至少7天的假，她平时都很少抱怨休息时间太少，这次十一又很想出去玩，毕竟我们确实一年顶多出去玩个一两次次（五一十一过年三次机会吧），所以最终还是答应一起去云南。 十一放假的前几天，她去上班，本来说好的我在家看攻略，也没有好好做，而是出去打麻将了。说来也奇怪，明明有4天时间，感觉自己也没有做什么一眨眼就过去了。平时工作也有这样的感觉，随便写写文档，摸摸鱼，一天就过去了，但是自己觉得一事无成，所以才会看不到未来，丧失对生活希望。不过好在云南这种热门旅游景点，网上的攻略一大堆，而且也就那么些个景点，挑几个想去的直接去就行了，所以最后整个旅行过程并没有因为我没做攻略而有耽误，反倒觉得因为我的一些态度，让这个过程没那么完美，或者说让女朋友很扫兴，这个后面会提到。 云南行小结 云南之旅一共走了三个地方，昆明——大理——丽江。 昆明：昆明老街，滇池，湿地公园（网红划船地）。昆明只是中转站，只是因为昆明机场比较大飞昆明便宜所以先去昆明。在昆明老街吃的午饭，两个人点了三大盘菜，浪费了好多，在一些热门打卡地拍了照就前往滇池了。滇池很大，配合西山的断壁还是很壮观的，可惜当时正是感冒比较重的时候，没有什么心情欣赏，而且从码头北面一直走到海埂公园正门真的挺累的。幸好路边小电动多，骑到旁边的湿地公园也挺快的。由于没有提前详细看攻略，到那边网红树林划船的票已经卖光了，只是在那个树林旁边拍了会照片就赶往火车站前往大理。 我们是住在大理古城的，大理古城里全是商业化卖东西的地方，街道旁是各种商铺吃的，巷子里是各种民宿。逛古城的时还路过有一家鲜花饼店，鲜花饼很好吃，一块钱一个也很大，我们一人吃了一个。后面在丽江尝的几家鲜花饼印象里都没那家好吃，所以也就没有买了寄回去，也算是一点小遗憾。从大理古城去的喜洲古镇，仍然是商业街……再往外是稻田，许多攻略都会提到在这里打卡，对于我一个从小在农村长大的人来说，属实没什么意思，还踩了一脚的泥。简单逛了一会就往洱海出发了。洱海比滇池大得多的感觉，而且配上蓝天白云和风，真的很美，风景宜人，我俩骑着电动车沿着洱海周围的路走了一二十公里到才村码头，一路上只偶尔拍了一些照片，主要还是感受自然风光。我并没有多少拍照的兴趣，而且也并不是很理解有一些地方看上去很普通，就因为后期修图搞成一些网红打卡点，就有很多人聚集在那里拍照，给女朋友拍照也没有很认真地学习过构图等技巧，导致拍出来的很多她都不满意，她对我拍照技术的不认可也更加剧了我对拍照打卡这件事的抵触，更频繁地催促她一起前往下一个地方。第二天女朋友租了套民族服装拍照，化妆三十分钟又一边吸二手烟一边等了二三十分钟终于等来了摄影师，299的套餐摄影师敷衍地选了教堂一处景点迅速拍完了30张底片就让我们自己出去拍了。最后拍完就赶往丽江。 丽江是真的好玩，丽江古城虽然也比较商业化，但是穿城而过的流水，让它更像是一个古镇。虽然由于天气原因，没有看到日照金山，但看到玉龙雪山的裸露的岩石，登上4600高峰（也坐了缆车）时的激动，让丽江之行的体验远大于大理。只是结尾没那么愉快，去白沙古镇才发现是个偏僻的小山村，天公不作美一直下雨，云层甚至把山的轮廓都遮住了。走的时候，托运行李都进了传送带了，临时通知飞机取消，只能加价买了晚上的飞广州的票，在机场度过了假期的最后一个下午。半夜到机场打顺风车回深圳，那个车还有点问题，胎噪巨大。唯一的算是好消息的是，司机开车很猛，原以为要两点到家的车程，一点多就到了。 赶紧休息，第二天还要上班。 希望洱海的风吹走所有负面情绪 在大理的第二天只计划了拍照这一件事，但那会我的感冒还是没有好，导致非常没有精神，昏昏欲睡。自由拍摄的过程我突然有些顿悟，我忘记是因为什么“顿悟”的。但是看着女朋友精致的妆容，以及拍照时候认真地去做动作，摆pose，努力“假笑”，突然觉得旅游不就是这样吗？不留下点什么怎么能够在以后记得当时的心情呢？我本来是认为古城没意思，应该多看一些自然风光，但古城里的生活，那些酒吧的驻唱歌手，街边的石板烧鲜花饼还有各种旅拍的店，也是一种古城风景不是吗？商业化也并不是一种罪吧。更重要的是，我之前一直在把消极的情绪传递给我的女朋友，导致给她拍的照片也没那么好看，更影响她拍照的情绪。 这个问题实际上在整个云南之旅的过程中都存在，我即使在中途意识到了这一点，也还是没有避免，这似乎成为了一种下意识的行为。让我更感到愧疚的是，我女朋友即便已经被影响到了，也只针对这一点说了我两次。曾经我介绍自己的性格的时候，总会毫不犹豫地写上乐观开朗，但现在的我似乎总是被消极情绪笼罩，试用期被裁员之后的自我怀疑，忍受不了高强度加班后主动离职之后的后悔，6个月在家待业加疫情封控导致的自闭，以及时时刻刻自己主动去比较导致的同龄人压力（peer pressure），反映到生活工作中，就是犹豫与徘徊，注意力下降，精神不集中，一度怀疑自己是不是得了焦虑症或是抑郁症。 “盖棺定论” 我是一个经常鼓励自己向前看，却又容易沉湎于过去，感慨于过去的人。 在从云南返深的飞机上，我翻开以前的录音，里面有当初被逼自己离职时候和hr的solo记录，有我从第二家公司主动离职前和CEO的谈心，两次离职时候的心情，再听录音时甚至还能回想起来。 从第一家被逼离职之后的很长一段时间，我都只觉得是领导傻逼无情，没有总结这个过程中的经验教训。我能够感受到，当初离职时候领导和HR的PUA话术，之后的自我怀疑并不是因为被裁员，毕竟欲加之罪何患无辞，而是怀疑自己到底适不适合走产品这条路。虽然比起写代码，我更愿意做产品相关工作，但总是有一些瞬间，是有些怀疑的。 这个怀疑其实还是源自于内心的怯弱，想要放弃，这是在回顾了和第二家老板谈心的录音之后才意识到的。老板给了我一些建议： 离职前先和直属领导或者mentor先沟通一下。说这一点是因为我从第二家离职的时候，看了网上离职的案例，就直接拟写了一封邮件，抄送了HR，CEO（我的名义上直属领导）,CTO。当时还真的没有意识到这样有什么不妥，所以再回顾录音的时候，能深深体会到CEO对我的行为的不解。 好好考虑好自己之后的路，也就是做好职业规划。并且对当前的行业形势做了分析：软件行业，以互联网行业为代表的即将走向下行。因为我跟他说的离职理由是我不想做硬件了（当时确实有些抵触，但实际上我后面找的还是硬件产品工作，而真正的离职原因是受不了太晚的加班。），并且他和CTO之前都是在腾讯或者小米任职了很长一段时间，给的建议我认为也非常的中肯。 最后一点也是顺着上面说的，就是不要轻易地做出放弃这个决策，因为一旦做出了一次放弃的决定之后，以后再遇到困难，就越容易倾向于选择放弃。这点我当时没有认真体会，再回顾录音的时候才发现非常正确，甚至我离职之后的一些行为都能与之对应上。 最后一点其实也是我想要写这篇文章的原因之一，我想要总结好前两段工作经历，然后“盖棺定论”。之所以加引号，是因为不可能永远都不去回顾，而且有些东西总是常看常新的，只是想用这个总结让自己不要受困于过去，而要带着过去总结下来的经验教训走好眼前的路。更重要的是，找回以前坚强乐观的自己，在自己遇到困难的时候告诉自己别那么容易放弃，努力坚持下去。这不是鸡汤，而是确实非常必要的品质。 后记 这次云南行既有难忘的风景和经历，更让我反思得更深入了一点，也或多或少缓解了当下迷茫的状态。","categories":[{"name":"生活","slug":"生活","permalink":"https://blog.five2fire.top/categories/%E7%94%9F%E6%B4%BB/"}],"tags":[{"name":"随感","slug":"随感","permalink":"https://blog.five2fire.top/tags/%E9%9A%8F%E6%84%9F/"}]},{"title":"Swift中section的header用法","slug":"Swift中section的header用法","date":"2023-09-26T09:46:38.000Z","updated":"2025-01-02T02:17:10.820Z","comments":true,"path":"article/dfd22a7f.html","permalink":"https://blog.five2fire.top/article/dfd22a7f.html","excerpt":"","text":"基本用法12345678910111213import SwiftUI struct ContentView: View&#123; var body: some View&#123; Form &#123; Section &#123; Text(&quot;123123&quot;) Text(&quot;456789&quot;) &#125; header: &#123; Text(&quot;this is header&quot;) &#125; &#125; &#125; &#125; header中可以添加其他的Viewheader可以添加Text和Color的View，同样的，对于ZVHstack，也可以组合多个Text或Color视图。也可以对这些视图加.backgroud修饰符。 12345678910111213141516171819202122import SwiftUI struct ContentView: View&#123; var body: some View&#123; Form &#123; Section &#123; Text(&quot;123123&quot;) Text(&quot;456789&quot;) &#125; header: &#123; HStack(spacing: 0.0)&#123; Text(&quot;A&quot;) //.background(.red) Text(&quot;bc&quot;) .textCase(.lowercase) //.background(.blue) //.background(.red) Color(.yellow) //TextField(&quot;123&quot;) 这种是不允许的。 &#125; &#125; &#125; &#125; &#125; section中还可以添加footer，会显示在下方12345678910Section(header: HStack &#123; Image(systemName: &quot;leaf.fill&quot;) Text(&quot;Fruits&quot;) &#125;, footer: HStack &#123; Image(systemName: &quot;heart.fill&quot;) Text(&quot;Eat healthy!&quot;) &#125;)&#123; TextField(&quot;Amount&quot;, value: $checkAmount, format: .currency(code: Locale.current.currency?.identifier ?? &quot;USD&quot;)) &#125; .headerProminence(.increased) 像上面那种写法，只能加header或footer其中之一，两个都加会报错（不知道什么原因） 添加header或footer建议都使用这种句式，一并添加，实际使用中比较少见到footer。","categories":[{"name":"技术","slug":"技术","permalink":"https://blog.five2fire.top/categories/%E6%8A%80%E6%9C%AF/"}],"tags":[{"name":"编程","slug":"编程","permalink":"https://blog.five2fire.top/tags/%E7%BC%96%E7%A8%8B/"},{"name":"Swift","slug":"Swift","permalink":"https://blog.five2fire.top/tags/Swift/"}]},{"title":"产品经理知识库","slug":"产品经理知识库","date":"2023-09-18T03:02:15.000Z","updated":"2025-01-02T02:17:10.824Z","comments":true,"path":"article/32636.html","permalink":"https://blog.five2fire.top/article/32636.html","excerpt":"","text":"本文初版思维导图参考(无法直接打开) 产品经理简介（定位）专业技能产品能力竞品分析需求分析不能先入为主，有红灯心态 B端产品需要考虑功能模块上下游的联系，前已发动全身，不能随意删除某一模块分清需要和需求的差异，从需要中挖掘需求 相关文章 B端产品经理必备工具箱：需求分析篇 需求分析模型 角色 场景 业务流程（用户行为） 解决了什么问题 需求分析工具5W1H原则 Who：产品为谁设计？目标用户是谁？谁购买，谁使用？数量有多少？ Why：用户为什么要选择我们的产品？除了我们的产品外，他还有哪些选择？产品被替代的可能性大吗？ When：用户什么时候使用我们的产品，多久用一次，会持续多久？ Where：用户在哪里使用我们的产品？ What：产品具体形式是什么？做成什么样？ How：用户是怎么使用它的？ 第一性原则KANO模型 必备属性 产品提供此类型需求，用户满意度不会提升 产品不提供此类型需求，用户满意度会大幅下降 期望属性 产品提供此类型需求，用户满意度会提升 产品不提供此类型需求，用户满意度会下降 魅力属性（用户意想不到的需求） 产品提供此类型需求，用户满意度会大幅提升 产品不提供此类型需求，用户满意度不会下降 反向属性（用户不需要的需求） 产品提供此类型需求，用户满意度会大幅下降 无差异属性（用户不会在意的需求） 无论产品是否提供此类型需求，用户满意度都不会有所改变 产品设计产品定位 消费者洞察：从消费者的角度提出其内心所关注的有关问题。 利益承诺：说明产品能为消费者提供哪些好处。 支持点：解释产品的哪些特点是怎样解决消费者洞察中所提出的问题的。 总结：用概括的语言（最好是一句话）将上述三点的精髓表达出来。 产品规划版本规划1.简建立明确的版本号标识（1）主版本号：当功能模块有较大的变动，比如增加模块或是整体架构发生变化。此版本 号由项目经理决定是否修改。 主版本号更新规则：产品功能发生全新的优化，包括页面、体验和技术上的全面更新优化。如下图所示两个产品的版本号升级。 （2）次版本号：相对于主版本号而言，次版本号的升级对应的只是局部的变动，但该局部 的变动造成程序和以前版本不能兼容，或者对该程序以前的协作关系产生了破坏，或者是功能上有大的改进或增强。此版本号由项目决定是否修改。 子版本号更新规则：1、产品新增了重要功能模块；2、在原来功能基础上作了重要更新；3、严重Bug的修复。 （3）修订版本号：一般是Bug 的修复或是一些小的变动或是一些功能的扩充，要经常发布 修订版，修复一个严重 Bug 即可发布一个修订版。此版本号由项目经理决定是否修改。 修订版本号更新规则：1、新增或优化一般的功能模块；2、一般Bug的修复。 （4）日期版本号：用于记录修改项目的当前日期，每天对项目的修改都需要更改日期版本 号。此版本号由开发人员决定是否修改。 （5）希腊字母版本号：此版本号用于标注当前版本的软件处于哪个开发阶段，当软件进入到另一个阶段时需要修改此版本号。此版本号由项目经理决定是否修改。 Alpha：内测版。此版本表示该软件在此阶段主要是以实现软件功能为主，通常只在开发者内部交流，或者提供给测试人员测试用，一般而言，该版本软件的Bug较多，需要继续修改。 Beta：公测版。该版本相对于α版已有了很大的改进，消除了严重的问题，但还是存在着一些缺陷，需要经过多次测试来进一步消除，可以提供给一定的目标用户大规模体验测试。 RC 版：候选版本。是 Release Candidate 的缩写，意思是发布倒计时，该版本已经相当成熟了，完成全部功能并清除大部分的Bug。 Release 版：该版本意味“最终版本”。是经过前面版本的一系列测试之后，最终交付给用户使用的一个版本。该版本有时也称为标准版。 2.确定版本的目标： 一个版本，就好比一个产品，产品要有自己的优势，版本也要有自己的目标和优势。 评估需求开发的成本及工作量 需求按照优先级排期:如何确定需求的优先级 3.制定版本内容:以版本目标作为依据，考虑需求池中哪些需求应该被安排到这期需求中4.设计发布的策略 直接发布 内部发布 小部分试用 灰度测试 5.验收和发版流程 产品管理流程及规范5——版本命名、验收规范、发版管理 交互设计功能逻辑生命周期管理用户体验五要素 战略层： 产品目标和用户需求 范围层： 产品阶段&#x2F;各阶段达成的目标（整理需求清单，排列优先级） 结构层： 梳理业务流程，搭建产品框架（如功能列表） 框架层： 设计具体框架（原型设计） 表现层： 填充各框架内具体内容（UI&#x2F;交互等设计） 相关文章 我是如何通过用户体验五要素，设计医疗信息系统的？ 5个要素，带你做好用户体验 产品运营市场能力市场调研用户调研项目管理基本素质学习能力学习能力标准拆解独立思考：岗位、对工作内容形成自己的理解知识内化：学会运用知识，迁移知识 执行力沟通能力关键素质行业融入感主人翁精神对自己的产品高度负责，积极推动任何环节遇到的问题 相关文章 互联网职业经理人的素养（一）：主人翁精神 产品经理必须要有主人翁意识 心态与情商独立思考与总结辅助专业知识技术知识心理学美学办公技能组织影响力方法论建设知识传承人才培养面试技巧总结STAR法则STAR法则,即为Situation Task Action Result的缩写，具体含义是: Situation: 事情是在什么情况下发生 Task: 任务 Action: 针对这样的情况分析，你采用了什么行动方式 Result: 结果怎样，在这样的情况下你学习到了什么 简而言之，STAR法则，就是一种讲述自己故事的方式，或者说，是一个清晰、条理的作文模板。不管是什么，合理熟练运用此法则，可以轻松的对面试官描述事物的逻辑方式，表现出自己分析阐述问题的清晰性、条理性和逻辑性。 简历上的任何一个信息点都有可能成为日后面试时的重点提问对象 写简历时能把面试的问题就想好，会使自己更加主动和自信，做到简历，面试关联性，逻辑性强","categories":[{"name":"产品","slug":"产品","permalink":"https://blog.five2fire.top/categories/%E4%BA%A7%E5%93%81/"}],"tags":[{"name":"产品经验","slug":"产品经验","permalink":"https://blog.five2fire.top/tags/%E4%BA%A7%E5%93%81%E7%BB%8F%E9%AA%8C/"}]},{"title":"30岁的我会是怎样的我","slug":"30岁的我会是怎样的我","date":"2023-08-28T08:40:32.000Z","updated":"2025-01-02T02:17:10.808Z","comments":true,"path":"article/687.html","permalink":"https://blog.five2fire.top/article/687.html","excerpt":"","text":"30岁的我会是怎样的我要换工作了最近处于一个很矛盾的人生节点，去年11月份由于已经裸辞待业半年整，再加上整个就业环境非常差，妥协入职到现在的这家公司也快要一年了，而我从研究生毕业到现在已经度过2年零2个月的日子。 仿佛上天跟我开了个玩笑，刚毕业时意气风发斗志昂扬的我被现实狠狠地教育了一番。遇上公司无理裁员应届生，再加上自己不能忍受太晚的加班，两年里换了3份工作，前两份都只有半年和3个月的工作时长，这也间接导致后面半年找工作不是很顺利。毕竟企业还是希望稳定的人才。 985本科国科大的硕士，让我自己不满足于现状，觉得自己有能力在更大的平台施展拳脚，当然也得到更高的酬劳。所以从5、6月份开始，我就着手总结工作，更新简历，投递大公司了。 矛盾点在于，前面提到的这三份工作，都没有一个相对完整的项目经历，这让我在面试的时候很难向面试官展现我的能力。而如果继续待在现在这家公司，把项目进行得更完整，有可能就错过了金9银10的社招季了，虽然现在的就业形势比去年并没有变好，甚至可能更糟。 自己目前处在一个温水煮青蛙的环境。虽然我觉得自己的能力能够负责更复杂更深入的工作，实际上工作中并没有相关经验，我需要证明这一点才能让面试官信任我。 回望这两年的工作，发现自己可往简历上写的内容确实寥寥无几。我也尝试了去网上搜一些写简历的技巧，然而“巧妇难为无米之炊”，实在没有业绩的话，也不好再过多粉饰。 就努力来说，我自认为毕业这两年没有很努力的，很大一部分因素是被裁员后陷入了很深的自我怀疑之中，以及在第二家主动辞职后，很深的悔恨。这个过程没有去提升自己，没有向前看，没有一个好的规划，没有强大的执行力去按照自己想去的方向一往直前。 会PUA自己配不配一份好工作，也许我的过往不配，但我还是坚信我的能力是配的。 我还是希望有一鸣惊人的那一天。 未来的我想成为什么样子？生活上，我想要活成一个自律的人，每一天都按照计划一步一步往前走。工作上，我想要像那些自由开发者一样，不追求财务自由，不追求永远不工作就能养活自己，但追求一个自由的工作时间，自由的工作地点，以及自我能够定义的工作内容。 我只想给自己打工。 然而我现在离这样的目标相去甚远。其中的原因我自己也反思了无数次，也踌躇满志了无数次，又不断地混吃等死。 下个月就是我27周岁生日了，周末也和家里人说到了结婚这个人生大事，我爸说，等你结婚之后我就彻底不管你了，心里的石头就放下了，你就自己去闯荡吧，闯荡成什么样也是你自己努力或是不努力的结果，结婚之后，你们就成立自己的家庭了。 我问自己，我以后简历的家庭应该是什么样子？没有过了那个槛，好像很难意识到自己身份应该如何转变，我甚至还没有完全从一个学生身份转换成职场人的身份，又要从一个尚未完全独立的成年人，转换成一家之主。 所以你问我未来的我会是怎样的，这谁知道呢。我甚至都不知道30岁的我是怎样的。 我能做什么？3年时间可以做什么？上完初中，上完高中，读完大半个国内大学，读完研究生。 初中的知识和小学比是一个很大的跨越，高中的知识和初中比也是一个跨越。但好像上了大学后，我的能力增长就非常缓慢了，学啥都是半吊子。 但回过头看，三年好像很长，长到足以掌握一个专业的大部分知识点，足以攻克一个课题，也足以废掉一个人。 我能做什么？ 没有结论，想做就做。实干永远大于空想！","categories":[{"name":"生活","slug":"生活","permalink":"https://blog.five2fire.top/categories/%E7%94%9F%E6%B4%BB/"}],"tags":[{"name":"随感","slug":"随感","permalink":"https://blog.five2fire.top/tags/%E9%9A%8F%E6%84%9F/"}]},{"title":"运动过程中的一些小感想","slug":"运动过程中的一些小感想","date":"2023-08-09T12:23:23.000Z","updated":"2025-01-02T02:17:10.826Z","comments":true,"path":"article/62807.html","permalink":"https://blog.five2fire.top/article/62807.html","excerpt":"","text":"运动过程中的一些小感想关于开始一直拿DOTA2里克林克兹的一句台词来勉励自己，“与其感慨路难行，不如马上出发”。 从去年年底搬到福田新家，看到楼下就有一个开放的游泳池的时候开始，就在想象着每天下班之后去游一圈的场景。泳池5月5号开始试营业，我也第一时间得到了这个消息，但是一直拖到6月27号才去办了卡。这之间只5月11号去游了一次。 那次游泳距离我上一次游泳，可能有一年多的光景了，我记得当时下水还挺冷的，5月对于深圳来说已经是半个夏天了，但水温对于好久没游泳的人来说还是有些凉了。实际上，那会的对于现在的我应该是刚好的，如果现在白天太阳高照，那晚上七点时候的水温都快接近体温了，再游几下，直接浑身冒汗。而且当时因为水温较低，很少小朋友去玩水，也很少有初学者去学习，简直是开始游泳的绝佳时机，我就这样错过了一个多月的游泳黄金期。现在只要稍微晚一些去游泳，仅有的两条泳道就有其他人了，不是标准泳道，没有水下的指引线，很容易游歪和撞到对面的人。 好在是后面咬牙办了卡，6.27号办的卡，到今天（8月9号）也已经游了13次了，基本达到了一周两次的锻炼频率（最近几乎每天都去）。 最近也正好在重读《自控力》这本书，并且在B站刷到一条短视频，讲的就是关于自我控制的脑科学&amp;神经学原理。一方面大脑是具有非常强的可塑性的，经常学习一个知识或者说做一件其他的随便什么事情，大脑中的相关区域就会不断强化，有点用进废退的感觉。另一方面，大脑又会引导你去偷懒，因为运动（或者是学习其他的知识）是一件消耗能量的过程，所以才需要自己有自控力，不被自己的大脑随意摆布。 其实刚办卡那会也不是很经常性地去游，也有非常多的时候是惰性思维让我躺在家中，看着就在楼下的泳池，虽然心里想去到水里自由自在，身体却懒得挪动一步。但是首先要有开始，然后才有后来，至于最后的结果如何，那是由过程中的努力等等因素决定的，但是不开始就一定没有结果，连过程都没有。这点道理看起来很直白，我也明白，但实际做起来是很难的。这应该总结成另一个词——“执行力”。 最后告诉自己，开始要果断。 关于成就感翻看之前的朋友圈，冲刺起来的话，自由泳是可以达到50s游50m这样的速度的，可惜没有找到1000m的数据，不过印象中应该是25min这个数字。 从第一次游泳的40分钟600米，到今天1000m自由泳重新回到30分钟内，并且游完没有感觉到很疲惫，已经是一个不错的结果了。这个过程中，Apple Watch记录了每一次游泳数据，直观的展示让我实实在在地感受到了自己在进步。 于是我也在朋友圈晒了自己最近运动的截图。不管是Apple Watch记录的数据还是发朋友圈留念，实际上都是一种激励。前段时间学习Swift的时候，老师（在一个网站跟着一个Youtuber学习的，姑且叫做老师吧）提到的很重要的一点就是每天将自己的成就发布在社交媒体上，也是同样的道理。 成就感是不断积累出来的，刚开始取得了一点成就可能会沾沾自喜，越往后，对自己的要求越高，所要求的努力应该也越多，获得的成就感我相信一定也更多。所以一件事情要坚持做，并且要越做越好，才能形成一个正反馈。这中间需要不断总结提高。然而我的总结都是脑袋里随便想一想，嘴上随便说一说，所以才总是三天打鱼两天晒网，这是万万不行的。 如何改变，这就回到上一节说的，要从现在开始。 最后其实之前也有过无数的小感想，有过无数次开始，有过无数次放弃。这次持续将这个坚持的过程不断记录下来，希望不会轻易中断。我会把这些记录同步更新到个人博客中，虽然目前还没有将这个博客广而告之，但这毕竟也是一个公共平台，在之后某一个我觉得合适的时间点，我会将这个博客发布。希望那时候的我，已经成为了现在自己想要成为的样子。 加油！","categories":[{"name":"生活","slug":"生活","permalink":"https://blog.five2fire.top/categories/%E7%94%9F%E6%B4%BB/"}],"tags":[{"name":"随感","slug":"随感","permalink":"https://blog.five2fire.top/tags/%E9%9A%8F%E6%84%9F/"}]},{"title":"Hacking With Swift —— Project1——3","slug":"Hacking With Swift Learning Notes","date":"2023-08-01T15:11:43.000Z","updated":"2025-01-02T02:17:10.808Z","comments":true,"path":"article/2441.html","permalink":"https://blog.five2fire.top/article/2441.html","excerpt":"","text":"英文原博博主是 Paul Hudson @twostraws 本文是学习Swift过程中翻译该网站的内容: https://www.hackingwithswift.com/ Hacking With Swift Learning NotesProject1. WeSplit1. Swift应用程序的基本结构&amp;emsp;&amp;emsp;按照Xcode中的默认步骤创建一个IOS项目，项目中会自动生成两个Swift文件，一个是以自定义名称命名的文件（这个项目里就是WeSplitApp），另一个是ContentView。刚开始的项目，我们都只是在ContentView这个文件中编辑代码。WeSplitApp中，调用ContentView文件即可运行程序。另外，所有项目中用到的其他文件，需要保存在Assets文件夹中。在ContentView文件中，默认会有以下这几行代码。 1234567891011121314import SwiftUIstruct ContentView: View &#123; //创建一个新的struct，符合View协议 var body: some View &#123; //定义一个新的计算属性body Text(&quot;Hello, world!&quot;)//创建一个文本视图 .padding() //修饰符，用来修饰文本视图 &#125;&#125;struct ContentView_Previews: PreviewProvider &#123; static var previews: some View &#123; ContentView() &#125;&#125; //这个结构不会显示在APP中，也不会构成最终应用的一部分，专供Xcode使用，用于预览的 这会在右侧的Canvas的预览显示一个文字框。也是最简单的结构。后面介绍许多修饰器的时候，都会在这个最简单的Text框上进行演示。下方的带有Preview字段的struct只和预览有关，不会在正式的APP中显示。如果在修改代码的过程中出错，右侧Canvas中的预览会暂停自动生成，此时使用快捷键Option+Cmd+P与单击“恢复”的效果相同，自动预览。 2. 创建表单Form是一种View，每一个Form中，可以存放最多十个SwiftUI视图——不仅仅是Form有这种限制，由于Swift内部限制，很多地方都有这个“十个”的限制。如果想要放置超过十个视图，可以通过Group来进行打包，如果想在视觉上把每组视图去分开，用Section视图替代Group视图。 将基本的文本视图包装在基础表单视图内的效果，与单纯一个文本视图是不一样的，以前 Hello World 位于白色屏幕的中心，但现在屏幕是浅灰色的，Hello World 以白色显示在左上角。代码如下 123456var body: some View &#123; Form &#123; Text(&quot;Hello, world!&quot;) .padding() &#125;&#125; 一个Form内最多限制10个视图，这在Swift中很多地方都有这个“10”的限制。超出10个可以使用Group或者Section视图进行包装之后再放入Form中。 Section的最后可以加上header，并使用一个Text视图表现标题 12345678910Section &#123; Picker(&quot;Tip percentage&quot;, selection: $tipPercentage) &#123; ForEach(tipPercentages, id: \\.self) &#123; Text($0, format: .percent) &#125; &#125; .pickerStyle(.segmented)&#125; header: &#123; Text(&quot;How much tip do you want to leave?&quot;)&#125; 3. 创建导航栏导航栏视图——NavigationView。可以使用.navigationTitle()来修饰该视图，还有其他的修饰器。 对比一下两种实际效果（Xcode中预览） 123456789struct ContentView: View &#123; var body: some View &#123; Form &#123; Section &#123; Text(&quot;Hello, world!&quot;) &#125; &#125; &#125;&#125; 1234567891011var body: some View &#123; NavigationView &#123; Form &#123; Section &#123; Text(&quot;Hello, world!&quot;) &#125; &#125; &#125; //.navigationTitle(&quot;SwiftUI&quot;) //添加导航栏标题（会创建新视图 //.navigationBarTitleDisplayMode(.inline) //导航栏标题变成小字体&#125; 4. 修改程序状态属性包装器：@State。一般在struct中创建一些变量时会用到，通常与private连用，@State private var + 变量名 当创建想要更改属性的结构体方法时，我们需要添加关键字mutating。mutating func doSomeWork() 5. 值绑定使用美元符号进行值与界面中元素的双向绑定。$比如以下代码。在文本框中填写文本时，会自动将填写的内容赋值给变量name。 123456789struct ContentView: View &#123; @State private var name = &quot;&quot; var body: some View &#123; Form &#123; TextField(&quot;Enter your name&quot;, text: $name) Text(&quot;Hello, world!&quot;) &#125; &#125;&#125; 6. 在循环中创建视图（这一部份需要多练习透）想要在循环内创建多个 SwiftUI 视图是很常见的。例如，我们可能想要循环遍历一组名称，并让每个名称都是一个文本视图，或者循环遍历一组菜单项，并将每个名称显示为图像。 SwiftUI 为此目的提供了一个专用的视图类型，称为ForEach. 这可以循环数组和范围，根据需要创建尽可能多的视图。更好的是，ForEach如果我们手动输入视图，就不会受到 10 次视图限制的影响。 在创建视图的时候加上ForEach，会为循环的每一个项目都运行一次闭包。 123456```swiftForm &#123; ForEach(0..&lt;100) &#123; number in Text(&quot;Row \\(number)&quot;) &#125;&#125; 7. 获取用户的输入（为输入框加入format修饰）本项目中的例子是输入美元，USD，使用了 1TextField(&quot;Amount&quot;, value: $checkAmount, format: .currency(code: &quot;USD&quot;)) 上面的表述固定了输入为美元，更好的格式是 123TextField(&quot;Amount&quot;, value: $checkAmount, format: .currency(code: Locale.current.currencyCode ?? &quot;USD&quot;)) .keyboardType(.decimalPad) 最后的.keyboradType可以制定键盘类型。 8. 在表单中添加选择器123456Picker(&quot;Number of people&quot;, selection: $numberOfPeople) &#123; ForEach(2 ..&lt; 100) &#123; Text(&quot;\\($0) people&quot;) &#125;&#125;.pickerStyle(.segmented) 可以使用pickerStyle来修饰选择器的样式 9. 隐藏键盘监测文本框的聚焦状态，当焦点聚焦于文本框时，出现键盘，点击键盘上的Done取消聚焦状态。使用一个变量来保存这个聚焦状态。详情见https://www.hackingwithswift.com/books/ios-swiftui/hiding-the-keyboard Project2. Guess the flag1. 使用堆栈来排列视图HStack&#x2F;VStack&#x2F;ZStack分别是水平，垂直和堆叠视图。类似于前面提到的Group还有Section的视图，堆栈可以将很多歌some View视图组合起来展示。 2. 颜色和框架可以为上述的some View视图加一些修饰，比如.backgroud(.red)可以为背景加上红色。如果想要整个视图的背景都是红色，可以将Color.red视图堆叠在Text视图下（使用ZStack）。如果想要限制背景颜色区域大小，可以为Color.red加上框架——使用.frame(wideth: 200, height: 200)。 frame中可以限制最小&#x2F;最大宽度。最大宽度可以设置为.infinity来适应不同的屏幕。 默认的视图并不会完全的充满整个屏幕，因为还存在SafeArea，为视图添加.ignoreSafeArea()来让视图充满整个空间。一般不要将重要的内容放入安全区域，只有一些装饰性的内容可以拓展到安全区域之外。可以为视图添加不同的效果，比如.background(.ultraThinMaterial)可以添加磨砂玻璃的背景颜色效果，.foregroundColor(.secondary)或者是.foregroundStyle(.secondary)。可以查看不同的前景效果。 3. 渐变色（梯度）三种方式：LinearGradient和RadialGradient以及AngularGradient。具体方式可以参考下面的内容 12345678LinearGradient(gradient: Gradient(stops: [ .init(color: .white, location: 0.45), .init(color: .black, location: 0.55),]), startPoint: .top, endPoint: .bottom)RadialGradient(gradient: Gradient(colors: [.blue, .black]), center: .center, startRadius: 20, endRadius: 200)AngularGradient(gradient: Gradient(colors: [.red, .yellow, .green, .blue, .purple, .red]), center: .center) 4. 按钮和图像按钮的基本格式 123Button（“description text”）&#123; print(&quot;blablabla...&quot;)&#125; 这里使用了闭包的形式，也可以是任何一个函数 12345678struct ContentView: View &#123; var body: some View &#123; Button(&quot;Delete selection&quot;, action: executeDelete) &#125;func executeDelete() &#123; print(&quot;Now deleting…&quot;) &#125;&#125; 使用.buttonStyle来更改按钮样式，使用尾随闭包来定义标签。 5.显示提示对话框先定义一个对话框是否显示的变量来记录对话框显示状态 1@State private var showingAlert = false 最简单的显示警报的代码： 123456789101112struct ContentView: View &#123; @State private var showingAlert = false var body: some View &#123; Button(&quot;Show Alert&quot;) &#123; showingAlert = true &#125; .alert(&quot;Important message&quot;, isPresented: $showingAlert) &#123; Button(&quot;OK&quot;) &#123; &#125; &#125; &#125;&#125; 当点击按钮的时候，修改刚才定义的状态变量，这个变量在.alert中作为参数传入isPresent中。 可以向提醒框添加多个按钮，并添加按钮的角色 1234.alert(&quot;Important message&quot;, isPresented: $showingAlert) &#123; Button(&quot;Delete&quot;, role: .destructive) &#123; &#125; Button(&quot;Cancel&quot;, role: .cancel) &#123; &#125;&#125; 最后，您可以在标题旁边添加消息文本，并带有第二个尾随闭包，如下所示： 12345678Button(&quot;Show Alert&quot;) &#123; showingAlert = true&#125;.alert(&quot;Important message&quot;, isPresented: $showingAlert) &#123; Button(&quot;OK&quot;, role: .cancel) &#123; &#125;&#125; message: &#123; Text(&quot;Please read this.&quot;)&#125; 6. 堆叠按钮先定义国家和答案，然后在按钮上加入label并引用这个图片样式（图片已经添加到asset文件夹）。 1234567891011var countries = [&quot;Estonia&quot;, &quot;France&quot;, &quot;Germany&quot;, &quot;Ireland&quot;, &quot;Italy&quot;, &quot;Nigeria&quot;, &quot;Poland&quot;, &quot;Russia&quot;, &quot;Spain&quot;, &quot;UK&quot;, &quot;US&quot;]var correctAnswer = Int.random(in: 0...2)ForEach(0..&lt;3) &#123; number in Button &#123; // flag was tapped &#125; label: &#123; Image(countries[number]) .renderingMode(.original) &#125;&#125; 7.使用修饰符升级设计例如在VStack后添加如下修饰符 1234.frame(maxWidth: .infinity).padding(.vertical, 20).background(.regularMaterial).clipShape(RoundedRectangle(cornerRadius: 20)) 这样就可以调整大小以占据所需的所有水平空间，添加一点垂直填充，应用背景材料，使其从背景的红蓝色渐变中脱颖而出，最后将整个内容剪辑成圆角矩形的形状。 Project3. Views and modifiers1.视图和修饰符的简介在这个项目中，我们将弄明白为什么Swift中使用结构体而不是用类来编程，以及为什么some View有那么多。 在项目结尾希望你能够彻底了解Swift是通过什么运转起来的。 2.为什么 SwiftUI 对视图使用结构体？一个是为了性能考虑，结构体的创建很简单，可以包含一个整数，也可以包含一个复杂结构。 另外，除了性能方面，还有一个很重要的原因，就是隔离。我们可以更改类中的值，这会导致混乱，但想要更改结构体中的值，需要使用特定的方法。 3.SwiftUI 主视图的背后是什么？在刚创建一个新项目的时候，会有以下默认代码，如果希望修改背景颜色，仅仅做出以下改变是不够的： 1234567struct ContentView: View &#123; var body: some View &#123; Text(&quot;Hello, world!&quot;) .padding() .background(.red) &#125;&#125; 因为这里的.background(.red)只作用于Text这么大小的视图，并不能应用于整个背景，事实上，整个视图除了这个Text视图外，并没有一个叫“背景”的视图，如果你想要填充背景，正确的解决方案就是让文本视图占用更多空间，可以使用frame()修饰符来做到这一点。 123Text(&quot;Hello, world!&quot;) .frame(maxWidth: .infinity, maxHeight: .infinity) .background(.red) 4.修饰顺序也很重要每个修饰符都创建一个应用了该修饰符的新结构，而不是仅仅在视图上设置一个属性。 使用修饰符的一个重要副作用是我们可以多次应用相同的效果：每个都只是添加到之前的任何内容上。 例如，SwiftUI 为我们提供了padding()修饰符，它在视图周围增加了一点空间，这样它就不会向上推到其他视图或屏幕边缘。如果我们应用 padding 然后是背景颜色，然后是更多的 padding 和不同的背景颜色，我们可以给视图多个边框，像这样： 123456789Text(&quot;Hello, world!&quot;) .padding() .background(.red) .padding() .background(.blue) .padding() .background(.green) .padding() .background(.yellow) 5.为什么 SwiftUI 使用“some View”作为它的视图类型？表示这个结构中包含不同种视图类型，如果只包含一种，比如Text类型，也可以使用Text作为视图类型，例如 12345struct ContentView: View &#123; var body: Text &#123; Text(&quot;Hello World&quot;) &#125;&#125; 这个也是完全合法的 6.条件修饰符使用三元运算符替代if语句，if语句在一些情况下效率比较低，使用三元运算符会大大简化代码。例如： 1234567891011struct ContentView: View &#123; @State private var useRedText = false var body: some View &#123; Button(&quot;Hello World&quot;) &#123; // flip the Boolean between true and false useRedText.toggle() &#125; .foregroundColor(useRedText ? .red : .blue) &#125;&#125; 因此，当useRedText为 true 时，修饰符有效地读取.foregroundColor(.red)，而当它为false时，修饰符变为.foregroundColor(.blue)。因为 SwiftUI 会监视我们@State属性的变化并重新调用我们的body属性，所以只要该属性发生变化，颜色就会立即更新。 7.环境修饰符许多修饰符可以应用于容器，这允许我们同时将相同的修饰符应用于多个视图。 例如，如果我们在一个 VStack中有四个文本视图，并希望为它们提供相同的字体修饰符，我们可以直接将修饰符应用于VStack并将该更改应用于所有四个文本视图： 1234567VStack &#123; Text(&quot;Gryffindor&quot;) Text(&quot;Hufflepuff&quot;) Text(&quot;Ravenclaw&quot;) Text(&quot;Slytherin&quot;)&#125;.font(.title) 这称为环境修改器，不同于应用于视图的常规修改器。 从编码的角度来看，这些修饰符的使用方式与常规修饰符完全相同。但是，它们的行为略有不同，因为如果这些子视图中的任何一个覆盖了相同的修饰符，则子视图的版本优先。 例如，这显示了我们的四个带有标题字体的文本视图，但其中一个标题较大： 12345678VStack &#123; Text(&quot;Gryffindor&quot;) .font(.largeTitle) Text(&quot;Hufflepuff&quot;) Text(&quot;Ravenclaw&quot;) Text(&quot;Slytherin&quot;)&#125;.font(.title) 那里有font()一个环境修饰符，这意味着 Gryffindor 文本视图可以用自定义字体覆盖它。 但是，这对VStack然后尝试在其中一个文本视图上禁用模糊应用了模糊效果： 12345678VStack &#123; Text(&quot;Gryffindor&quot;) .blur(radius: 0) Text(&quot;Hufflepuff&quot;) Text(&quot;Ravenclaw&quot;) Text(&quot;Slytherin&quot;)&#125;.blur(radius: 5) 这不会以相同的方式工作：blur()是常规修改器，因此应用于子视图的任何模糊都将添加到VStack模糊而不是替换它。 但我们没有办法提前知道哪些修改器是环境修改器，哪些是常规修改器，除非阅读每个修改器的单独文档并希望它被提及。尽管如此，有总比没有好。 8.视图作为属性有很多方法可以让 SwiftUI 中的复杂视图层次结构更容易使用，其中一种选择是使用属性——创建一个视图作为你自己视图的属性，然后在你的布局中使用该属性。 例如，我们可以像这样创建两个文本视图作为属性，然后在一个VStack中使用它们： 1234567891011struct ContentView: View &#123; let motto1 = Text(&quot;Draco dormiens&quot;) let motto2 = Text(&quot;nunquam titillandus&quot;) var body: some View &#123; VStack &#123; motto1 motto2 &#125; &#125;&#125; 你甚至可以在使用这些属性时直接将修饰符应用于它们，如下所示： 123456VStack &#123; motto1 .foregroundColor(.red) motto2 .foregroundColor(.blue)&#125; 将视图创建为属性有助于使你的body代码更清晰——它不仅有助于避免重复，而且还可以从body属性中获取更复杂的代码。 9.查看组成SwiftUI 让我们可以将复杂的视图分解成更小的视图，而不会对性能产生太大影响。这意味着我们可以将一个大视图拆分为多个较小的视图，而 SwiftUI 会负责为我们重新组装它们。 例如，在这个视图中，我们有一种特殊的方式来设置文本视图的样式——它们有一个大字体、一些填充、前景色和背景色，以及一个胶囊形状： 12345678910111213141516171819struct ContentView: View &#123; var body: some View &#123; VStack(spacing: 10) &#123; Text(&quot;First&quot;) .font(.largeTitle) .padding() .foregroundColor(.white) .background(.blue) .clipShape(Capsule()) Text(&quot;Second&quot;) .font(.largeTitle) .padding() .foregroundColor(.white) .background(.blue) .clipShape(Capsule()) &#125; &#125;&#125; 因为这两个文本视图除了文本之外是相同的，所以我们可以将它们包装在一个新的自定义视图中，如下所示： 123456789101112struct CapsuleText: View &#123; var text: String var body: some View &#123; Text(text) .font(.largeTitle) .padding() .foregroundColor(.white) .background(.blue) .clipShape(Capsule()) &#125;&#125; 然后我们可以在原始视图中使用该CapsuleText视图，如下所示： 12345678struct ContentView: View &#123; var body: some View &#123; VStack(spacing: 10) &#123; CapsuleText(text: &quot;First&quot;) CapsuleText(text: &quot;Second&quot;) &#125; &#125;&#125; 当然，我们也可以在视图中存储一些修饰符，在使用时自定义其他的。例如，如果我们从CapsuleText中删除foregroundColor()，那么我们可以在创建该视图的实例时应用自定义颜色，如下所示： 123456VStack(spacing: 10) &#123; CapsuleText(text: &quot;First&quot;) .foregroundColor(.white) CapsuleText(text: &quot;Second&quot;) .foregroundColor(.yellow)&#125; 不要担心这里的性能问题——以这种方式分解 SwiftUI 视图非常有效。 10.自定义修饰符要创建自定义修饰符，请创建一个符合ViewModifier协议的新结构。这只有一个要求，即一种被调用的方法body，它接受要处理的任何内容，并且必须返回some View。 例如： 12345678910struct Title: ViewModifier &#123; func body(content: Content) -&gt; some View &#123; content .font(.largeTitle) .foregroundColor(.white) .padding() .background(.blue) .clipShape(RoundedRectangle(cornerRadius: 10)) &#125;&#125; 我们现在可以将它与modifier()修饰符一起使用——是的，它是一个名为“modifier”的修饰符，但它允许我们将任何类型的修饰符应用于视图，如下所示： 12Text(&quot;Hello World&quot;) .modifier(Title()) 创建自定义View之后，创建扩展以View使其更易于使用 例如，我们可以将Title修饰符包装在这样的扩展中： 12345extension View &#123; func titleStyle() -&gt; some View &#123; modifier(Title()) &#125;&#125; 我们现在可以像这样使用修饰符： 12Text(&quot;Hello World&quot;) .titleStyle() 自定义修饰符可以做的不仅仅是应用其他现有修饰符——它们还可以根据需要创建新的视图结构。请记住，修饰符返回新对象而不是修改现有对象，因此我们可以创建一个将视图嵌入堆栈并添加另一个视图的对象： 1234567891011121314151617181920struct Watermark: ViewModifier &#123; var text: String func body(content: Content) -&gt; some View &#123; ZStack(alignment: .bottomTrailing) &#123; content Text(text) .font(.caption) .foregroundColor(.white) .padding(5) .background(.black) &#125; &#125;&#125;extension View &#123; func watermarked(with text: String) -&gt; some View &#123; modifier(Watermark(text: text)) &#125;&#125; 有了它，我们现在可以像这样向任何视图添加水印： 123Color.blue .frame(width: 300, height: 200) .watermarked(with: &quot;Hacking with Swift&quot;) 提示：通常人们想知道什么时候添加自定义视图修饰符比只添加一个新方法给View更好，实际上这归结为一个主要原因：自定义视图修饰符可以有自己的存储属性，而扩展View则不能。 11.定制容器利用泛型创建一些自定义容器，并在容器中加入任何自定义内容。 在 Swift 中，我们会这样写： 123456789struct GridStack&lt;Content: View&gt;: View &#123; //这一部分是Swift的一个高级特性，称为泛型。 let rows: Int let columns: Int let content: (Int, Int) -&gt; Content var body: some View &#123; // more to come &#125;&#125; 特别注意这一let content行——它定义了一个必须能够接受两个整数并返回某种我们可以显示的内容的闭包。拥有这一行所以才叫做定制容器。 在body中我们可以这么写 1234567891011var body: some View &#123; VStack &#123; ForEach(0..&lt;rows, id: \\.self) &#123; row in HStack &#123; ForEach(0..&lt;columns, id: \\.self) &#123; column in content(row, column) &#125; &#125; &#125; &#125;&#125; 现在我们有了一个自定义容器，我们可以像这样使用它编写一个视图： 1234567struct ContentView: View &#123; var body: some View &#123; GridStack(rows: 4, columns: 4) &#123; row, col in Text(&quot;R\\(row) C\\(col)&quot;) &#125; &#125;&#125; Milestone Project1-3挑战制作一款大脑训练游戏，挑战玩家在剪刀石头布中输赢。 以下是简单的游戏规则： 游戏的每一轮，应用程序都会随机选择石头、布或剪刀，并提示玩家这轮应该赢或者是输。（可以输赢交替也可以随机） 然后玩家必须点击正确的选项来根据提示赢得或输掉游戏。 如果玩家选择正确（按照提示：让你输你就输，让你赢你就赢），玩家得分；否则玩家失去一分。 游戏在 10 个问题后结束，此时会显示玩家最终所得的分数。 因此，如果应用程序选择“Rock”和“Win”，则玩家需要选择“Paper”，但如果应用程序选择“Rock”和“Lose”，则玩家需要选择“Scissors”。 复习前面所学内容（预计挑战中要用到的） 使用堆栈排列视图：这个游戏里需要以下几个视图： 一个导航视图NavigationView，展示该游戏的名称“石头剪刀布智力训练” 一个记录当前得分的文本视图 一个展示电脑选的手势（石头剪刀布）以及电脑要求本轮游戏的结果（win or lose）的视图 一个展示玩家选择的手势的视图（包含三个按钮） 玩家每轮选择手势后，实时结果反馈的视图（可选，也可以所有轮次结束后直接给出游戏得分） 提前结束游戏的按钮视图（可选） 选择游戏总轮次视图（可选） 值绑定：需要将当前玩家所选手势赋值给一个变量。 教程所给的提示要解决这个挑战，你需要利用在教程 1 和 2 中学到的技能： 从一个 App 模板开始，然后创建一个属性来存储三种可能的移动：石头、布和剪刀。 你需要创建两个@State属性来存储应用程序的当前选择以及玩家应该赢还是输。 你可以使用Int.random(in:)来选择一个随机移动。如果你愿意，你可以用它来决定玩家是否也应该赢，但还有一个更简单的选择：Bool.random()随机为真或为假。在初始值之后，toggle()在两轮之间使用，因此它总是在变化。 创建一个VStack显示玩家得分、应用程序移动以及玩家应该赢还是输的图表。你可以使用if shouldWin返回两个不同文本视图之一。 重要的部分是制作三个响应玩家移动的按钮：Rock、Paper 或 Scissors。 使用font()修饰符调整文本的大小。如果你在这三个动作中使用表情符号，它们也会缩放。提示：你可以要求使用非常大的系统字体.font(.system(size: 200))——它们将是固定大小，但至少你可以确保它们既漂亮又大！ 提示： 从最简单的逻辑开始：三个按钮，每个按钮都有这样的逻辑：“玩家点击了石头，玩家试图获胜，应用程序选择了剪刀，所以加 1 分。” 一旦你有了这个工作，寻找一种方法来简化你的逻辑，例如一个数组，其中的项目击败了每一步。例如，如果你的移动数组是[“Rock”, “Paper”, “Scissors”]你的获胜移动数组[“Paper”, “Scissors”, “Rock”]。 如果你不想，你不需要添加图形；只需一些文本视图和按钮就足够了。为什么不试试表情符号？","categories":[{"name":"技术","slug":"技术","permalink":"https://blog.five2fire.top/categories/%E6%8A%80%E6%9C%AF/"}],"tags":[{"name":"编程","slug":"编程","permalink":"https://blog.five2fire.top/tags/%E7%BC%96%E7%A8%8B/"}]},{"title":"CodeingDiaries","slug":"CodeingDiaries","date":"2023-07-21T04:23:12.000Z","updated":"2025-01-02T02:17:10.808Z","comments":true,"path":"article/46888.html","permalink":"https://blog.five2fire.top/article/46888.html","excerpt":"","text":"2023年3月2023年3月19日 23:21:43昨天Mac mini到了，就产品来说，感觉macos系统并没有想象中的好，那个质感给我一种十年前的Linux系统的感觉。我之前用的Ubuntu20的界面都已经还可以了，苹果的IOS和iPadOS界面都美化得挺好的，MacOS给我的感觉就很旧。 没办法，想做IOS开发就是要用MacOS，所以上面也就是简单的吐槽。 新买的4K显示器下面的接口都已经被我插满了，周六忙了一个下午和半个晚上，终于把双屏双主机的方案搞得让我满意80%了，不得不赞一下显示器支架，真的能让桌面整洁很多，一点缺点就是桌夹式的安装之后桌子就不能靠墙了，但是打孔的话，就得靠桌子很前了，需要一个很宽的桌子，也没有100%完美的方案。 装Xcode和自带的Git就花了好久，根本还是没有明白git的工作原理，就目前也还是只知道改了文件要commit顺便push，也没有完全明白。感觉属实不应该花这么长时间，但每次时间一眨眼就过去了。项目的计划已经基本上做好了，剩下的就是认认真真执行了，加油。 成果总结 * Mac mini到货 * 安装Xcode和git，简单熟悉了一下界面 * 已做基本的项目计划 To do List: * 做详细的项目计划 * 学习Swift语言 * 调研学习Swift和学习APP开发的先后顺序 2023年3月24日 23:12:34开始有点明白git的工作机制了，不过也只是懂了一点皮毛。不过应该能够对付日常的代码修改更新了。要记住，commit-pull-push三步走。另外这周基本也都没有碰个人的这个项目，只是预先画了画圆形图 成果总结 熟悉git 修改界面里的一些参数 2023年4月3日 22:34:53跟着Hack With Swift学习了第一天的课程，因为之前有编程基础了，这部分非常简单，也不需要自己花时间去理解。 成果总结 * Day1 complete * 知道了在Xcode中，playground和project的区别 To do List: * 功能列表计划（初步完成） * 原型图计划，计划是在5月1日画完初稿原型图 * Day2（已经完成Day1-Day15的学习） 2023年4月24日 21:57:07目前已经把HackingWithSwift-100Day of SwiftUI的前面Day15学习完了。不过只认真学习到了闭包那里就已经看不懂了，毕竟自己的编程基础也不是特别好。它类似于Python中的匿名函数，听说在Swift编程中使用得还挺频繁的，那就之后实际用的过程中慢慢学习体会吧！ 接下来没有立马就跟着教程学下面的Project1，而是去苹果官网跟着tutorial先预习了一下SwiftUI，写了第一个小程序（不算Hello, world！的那种）。体会到了Xcode编写IOS应用的便捷，感受到了苹果开发Swift语言的直观。起码没有打消积极性，哈哈哈，继续加油吧。 成果总结 * 跟着tutorial写了第一个超级简单的程序 * 程序内容包括文字、文字的格式修改；图片、图片的形状修改以及添加轮廓；还添加了一个地图视图 * 初步了解了一个IOS程序的文件组成部分（Asset以及SwiftView的意思，创建了Swiftview之后，在另一个View文件中添加已创建在其他View中的view） To do List: * 熟悉Markdown语法，本地搭建Markdown知识库并使用Gitbook渲染 * 将飞书文档转移至本地知识库 2023年6月28日 17:39:265月份准备NPDP考试，6月份躺平了一个月，独立开发进度基本为0.如果非要说进度的话，那就是把HackingWithSwift的视频下下来了。并且第一个项目已经完成了。挑战也完成了，就是做了一个单位转换的小APP。 非常简单的一个小程序，刚做出来的时候还是很有成就感的，但之后觉得，那么简单是不是不应该值得骄傲的事情。但是呢，导师说是每一个小的progress都要记录下来，接下来继续学习！ 2023年7月18日 23:14:45今天是实践“每天坚持一点点”的第一天，所以没有实践太多，也是特别容易分心，很多语法不会，基础很差，所以写代码的时候非常多的错误。 主要实践了Swift中Foreach的用法，以及如何分割数组，索引部分数据。HackingWithSwift并没有学新内容。 最后还搜索了一下Xcode以及macos系统里面的一些快捷键。加入收藏夹了，用起来！","categories":[{"name":"技术","slug":"技术","permalink":"https://blog.five2fire.top/categories/%E6%8A%80%E6%9C%AF/"}],"tags":[{"name":"编程","slug":"编程","permalink":"https://blog.five2fire.top/tags/%E7%BC%96%E7%A8%8B/"}]},{"title":"产品经理知识体系","slug":"PMNotes","date":"2023-03-14T02:50:28.000Z","updated":"2025-01-02T02:17:10.809Z","comments":true,"path":"article/36304.html","permalink":"https://blog.five2fire.top/article/36304.html","excerpt":"","text":"产品经理知识体系一.基本素质学习能力 学习能力标准拆解 独立思考：岗位、对工作内容形成自己的理解 知识内化：学会运用知识，迁移知识 执行力 沟通能力 二.关键素质行业融入感 主人翁精神 对自己的产品高度负责，积极推动任何环节遇到的问题 https://www.woshipm.com/zhichang/3514812.html https://www.woshipm.com/pmd/3548085.html 心态与情商 独立思考与总结 三.组织影响力方法论建设 知识传承 人才培养 四.专业技能产品能力市场能力五.专业知识项目管理 技术知识 心理学 美学 办公技能 六.面试技巧STAR法则 * STAR法则,即为Situation Task Action Result的缩写，具体含义是: * Situation: 事情是在什么情况下发生 * Task: 任务 * Action: 针对这样的情况分析，你采用了什么行动方式 * Result: 结果怎样，在这样的情况下你学习到了什么 简而言之，STAR法则，就是一种讲述自己故事的方式，或者说，是一个清晰、条理的作文模板。不管是什么，合理熟练运用此法则，可以轻松的对面试官描述事物的逻辑方式，表现出自己分析阐述问题的清晰性、条理性和逻辑性。 简历上的任何一个信息点都有可能成为日后面试时的重点提问对象 写简历时能把面试的问题就想好，会使自己更加主动和自信，做到简历，面试关联性，逻辑性强","categories":[{"name":"产品","slug":"产品","permalink":"https://blog.five2fire.top/categories/%E4%BA%A7%E5%93%81/"}],"tags":[{"name":"产品经验","slug":"产品经验","permalink":"https://blog.five2fire.top/tags/%E4%BA%A7%E5%93%81%E7%BB%8F%E9%AA%8C/"}]},{"title":"律持隐私政策","slug":"private","date":"2019-11-14T03:42:45.000Z","updated":"2025-01-02T02:17:10.821Z","comments":true,"path":"article/36665.html","permalink":"https://blog.five2fire.top/article/36665.html","excerpt":"","text":"律持隐私政策生效日期：2024年11月11日 引言律持（以下简称”我们”）非常重视用户的隐私保护。本隐私政策旨在帮助您了解我们如何收集、使用和保护您的个人信息。 信息收集我们仅收集应用正常运行所必需的最小数据范围： 基础功能数据习惯打卡记录（包含打卡时间、完成状态）习惯任务信息（包含标题、描述、创建时间等） 系统权限通知权限：用于发送打卡提醒 数据存储与使用所有数据均存储在您的设备本地我们使用 Apple 的 SwiftData 框架进行数据管理不会将任何数据上传至云端或服务器数据仅用于实现应用的基本功能 数据安全我们采取以下措施保护您的数据：使用系统标准的数据存储方案仅在应用内部访问数据不与第三方共享任何用户数据 通知服务通知功能完全基于本地数据您可以随时在系统设置中管理通知权限通知内容仅包含习惯提醒信息 数据删除您可以通过以下方式删除您的数据：直接在应用内删除单个习惯记录卸载应用将删除所有相关数据重置手机将清除所有应用数据 儿童隐私本应用适合所有年龄段使用，不会特别收集儿童的个人信息。 隐私政策更新我们可能会不时更新本隐私政策。更新后的版本将在应用内发布，并注明更新日期。 联系我们如果您对本隐私政策有任何疑问，请通过以下方式联系我们：邮箱：[您的联系邮箱]微信：[您的微信号] 法律信息本应用遵守中华人民共和国相关法律法规，包括但不限于《中华人民共和国网络安全法》、《中华人民共和国个人信息保护法》等。 声明： 使用律持即表示您同意本隐私政策的所有条款。如果您不同意本政策的任何部分，请停止使用本应用。","categories":[],"tags":[]}],"categories":[{"name":"学习","slug":"学习","permalink":"https://blog.five2fire.top/categories/%E5%AD%A6%E4%B9%A0/"},{"name":"生活","slug":"生活","permalink":"https://blog.five2fire.top/categories/%E7%94%9F%E6%B4%BB/"},{"name":"技术","slug":"技术","permalink":"https://blog.five2fire.top/categories/%E6%8A%80%E6%9C%AF/"},{"name":"书影音","slug":"书影音","permalink":"https://blog.five2fire.top/categories/%E4%B9%A6%E5%BD%B1%E9%9F%B3/"},{"name":"产品","slug":"产品","permalink":"https://blog.five2fire.top/categories/%E4%BA%A7%E5%93%81/"}],"tags":[{"name":"粤语","slug":"粤语","permalink":"https://blog.five2fire.top/tags/%E7%B2%A4%E8%AF%AD/"},{"name":"反思","slug":"反思","permalink":"https://blog.five2fire.top/tags/%E5%8F%8D%E6%80%9D/"},{"name":"CloudFlare","slug":"CloudFlare","permalink":"https://blog.five2fire.top/tags/CloudFlare/"},{"name":"心理学","slug":"心理学","permalink":"https://blog.five2fire.top/tags/%E5%BF%83%E7%90%86%E5%AD%A6/"},{"name":"影评","slug":"影评","permalink":"https://blog.five2fire.top/tags/%E5%BD%B1%E8%AF%84/"},{"name":"财务","slug":"财务","permalink":"https://blog.five2fire.top/tags/%E8%B4%A2%E5%8A%A1/"},{"name":"自律","slug":"自律","permalink":"https://blog.five2fire.top/tags/%E8%87%AA%E5%BE%8B/"},{"name":"读书笔记","slug":"读书笔记","permalink":"https://blog.five2fire.top/tags/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"},{"name":"副业","slug":"副业","permalink":"https://blog.five2fire.top/tags/%E5%89%AF%E4%B8%9A/"},{"name":"产品","slug":"产品","permalink":"https://blog.five2fire.top/tags/%E4%BA%A7%E5%93%81/"},{"name":"效率","slug":"效率","permalink":"https://blog.five2fire.top/tags/%E6%95%88%E7%8E%87/"},{"name":"编程","slug":"编程","permalink":"https://blog.five2fire.top/tags/%E7%BC%96%E7%A8%8B/"},{"name":"Swift","slug":"Swift","permalink":"https://blog.five2fire.top/tags/Swift/"},{"name":"Hacking with Swift","slug":"Hacking-with-Swift","permalink":"https://blog.five2fire.top/tags/Hacking-with-Swift/"},{"name":"系统","slug":"系统","permalink":"https://blog.five2fire.top/tags/%E7%B3%BB%E7%BB%9F/"},{"name":"产品经验","slug":"产品经验","permalink":"https://blog.five2fire.top/tags/%E4%BA%A7%E5%93%81%E7%BB%8F%E9%AA%8C/"},{"name":"远程","slug":"远程","permalink":"https://blog.five2fire.top/tags/%E8%BF%9C%E7%A8%8B/"},{"name":"Apple","slug":"Apple","permalink":"https://blog.five2fire.top/tags/Apple/"},{"name":"评测","slug":"评测","permalink":"https://blog.five2fire.top/tags/%E8%AF%84%E6%B5%8B/"},{"name":"Hexo","slug":"Hexo","permalink":"https://blog.five2fire.top/tags/Hexo/"},{"name":"随感","slug":"随感","permalink":"https://blog.five2fire.top/tags/%E9%9A%8F%E6%84%9F/"}]}